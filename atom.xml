<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hope_Y&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-23T13:28:38.185Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Hope_Y</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Day10(毛概题)</title>
    <link href="http://yoursite.com/2020/03/23/Day10(%E6%AF%9B%E6%A6%82%E9%A2%98)/"/>
    <id>http://yoursite.com/2020/03/23/Day10(毛概题)/</id>
    <published>2020-03-23T12:41:43.424Z</published>
    <updated>2020-03-23T13:28:38.185Z</updated>
    
    <content type="html"><![CDATA[<p>第四次毛概作业</p><a id="more"></a><p><strong>1</strong></p><p>【单选题】毛泽东指出中国工业化道路中最重要的问题是(B)。<br>A、  中央与地方的关系<br>B、  重工业、轻工业和农业的关系<br>C、  沿海工业和内地工业的关系<br>D、  国家、生产单位和生产者个人的关系</p><p><strong>2</strong></p><p>【单选题】</p><p>实现(D)是中国近代以来历史发展的必然要求,也是国家独立和富强的必要条件。<br>A、  集体化<br>B、  农业化<br>C、  现代化<br>D、  工业化</p><p><strong>3</strong></p><p>【单选题】在中共八大上,关于经济体制提出了“三个主体,三个补充”重要思想的中共领导人是(A)。<br>A、  陈 云<br>B、  周恩来<br>C、  邓子恢<br>D、  毛泽东</p><p><strong>4</strong></p><p>【单选题】在中国工业化道路问题上,国民经济发展的次序为(B)。<br>A、  重工业、轻工业、农业<br>B、  农业、轻工业、重工业<br>C、  农业、重工业、轻工业<br>D、  工业农业并举</p><p><strong>5</strong></p><p>【单选题】要把我国建设成为一个社会主义强国,其关键是(B)。<br>A、  加强人民民主专政<br>B、  实现科学技术的现代化<br>C、  加强党的建设<br>D、  发展社会生产力</p><p><strong>6</strong></p><p>【单选题】我国社会生产力落后,经济基础薄弱,所以要优先发展(B)。<br>A、  农业<br>B、  重工业<br>C、  轻工业<br>D、  国防工业</p><p><strong>7</strong></p><p>【单选题】毛泽东提出,社会主义现代化的战略目标,是要把中国建设成为一个具有(B)的强国。<br>A、  现代农业、现代工业、现代服务业和现代科学技术<br>B、  现代农业、现代工业、现代国防和现代科学技术<br>C、  现代农业、现代工业、现代服务业和现代教育<br>D、  现代农业、现代工业、现代国防和现代教育</p><p><strong>8</strong></p><p>【多选题】毛泽东提出了一整套“两条腿走路”的方针包括以下哪些内容?(ABCD)。<br>A、  沿海工业和内地工业同时并举<br>B、  重工业和轻工业同时并举<br>C、  中央工业和地方工业同时并举<br>D、  大型企业和中小型企业同时并举</p><p><strong>9</strong></p><p>【多选题】毛泽东关于中国工业化道路的正确思想包括(ABCD)。<br>A、  实质问题是农、轻、重的发展关系问题<br>B、  工业为主导,优先和重点建设重工业<br>C、  发展工业和发展农业同时并举<br>D、  安排国民经济应以农、轻、重为序</p><p><strong>10</strong></p><p>【多选题】毛泽东在读苏联《政治经济学(教科书)》时,把社会主义社会划分为(AB)。<br>A、  不发达的社会主义<br>B、  比较发达的社会主义<br>C、  完全发达的社会主义<br>D、  社会主义初级阶段</p><p><strong>11</strong></p><p>【判断题】(错)中国共产党和民主党派“长期共存,互相监督”,实质上就是要在中国实行多党制。</p><p><strong>12</strong></p><p>【判断题】(错)推动社会主义社会向前发展的基本动力是阶级斗争。</p><p><strong>13</strong></p><p>【判断题】(对)三大改造完成后,国家政治生活的主题是正确处理人民内部矛盾。</p><p><strong>14</strong></p><p>[判断题] (对)在我国,工人阶级同资产阶级的矛盾是非对抗性矛盾。</p><p><strong>15</strong></p><p>【判断题】(对)解决社会主义社会基本矛盾的途径是依靠社会主义制度本身的力量进行改革。</p><p><strong>16</strong></p><p>【判断题】(对)社会主义社会的基本矛盾是在生产关系和生产力基本适应、上层建筑和经济基本适应条件下的矛盾,是在人民根本利益一致基础上的矛盾,是非对抗性的矛盾。</p><p><strong>17</strong></p><p>【判断题】(对)中国社会主义社会存在两类不同性质的矛盾。</p><p><strong>18</strong></p><p>【判断题】(对)社会主义社会基本矛盾运动的特点是既相适应又相矛盾。</p><p><strong>19</strong></p><p>【判断题】(错)在社会主义制度下,解决我国各民族之间矛盾的正确方针是“一国两制”。</p><p><strong>20</strong></p><p>[判断题] (错)在我国,由于民族资产阶级有两面性,工人阶级同民族资产阶级的矛盾属于敌我矛盾。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第四次毛概作业&lt;/p&gt;
    
    </summary>
    
      <category term="day++" scheme="http://yoursite.com/categories/day/"/>
    
    
  </entry>
  
  <entry>
    <title>Day9(毛概题)</title>
    <link href="http://yoursite.com/2020/03/16/Day9(%E6%AF%9B%E6%A6%82%E9%A2%98)/"/>
    <id>http://yoursite.com/2020/03/16/Day9(毛概题)/</id>
    <published>2020-03-16T13:04:03.086Z</published>
    <updated>2020-03-23T12:42:05.276Z</updated>
    
    <content type="html"><![CDATA[<p>第三次毛概作业题</p><a id="more"></a><p><strong>1</strong></p><p>【单选题】在我国,剥削阶级和剥削制度被消灭的标志是()。</p><ul><li>A、中华人民共和国的建立</li><li>B、全国大陆的统一</li><li>C、社会主义改造的完成</li><li>D、土地改革的完成</li></ul><p>正确答案： C</p><p><strong>2</strong></p><p>【单选题】党在过渡时期的总路线被概括为()。</p><ul><li>A、“四清五反”</li><li>B、“一化三改”</li><li>C、“两个转变”</li><li>D、“一个中心,两个基本点”</li></ul><p>正确答案： B</p><p><strong>3</strong></p><p>【单选题】我国农业合作化采取的第一个步骤是()。</p><ul><li>A、互助组</li><li>B、初级农业生产合作社</li></ul><p>正确答案： A</p><p><strong>4</strong></p><p>【单选题】社会主义改造中最具有中国特色的对马克思主义社会主义学说贡献最大的是对()。</p><ul><li>A、对资本主义工商业的社会主义改造</li><li>B、对农业的社会主义改造</li><li>C、对手工业的社会主义改造</li><li>D、社会主义工业化道路</li></ul><p>正确答案： A</p><p><strong>5</strong></p><p>【单选题】在农业社会主义改造中建立的初级农业生产合作社属于()。</p><ul><li>A、新民主主义性质</li><li>B、社会主义萌芽性质</li><li>C、半社会主义性质</li><li>D、社会主义性质</li></ul><p>正确答案： C</p><p><strong>6</strong></p><p>【单选题】</p><p>中华人民共和国的成立,标志着中国进入了()。</p><ul><li><p>A、</p><p>社会主义社会</p></li><li><p>B、</p><p>社会主义初级阶段</p></li><li><p>C、</p><p>新民主主义社会</p></li><li><p>D、</p><p>资本主义社会</p></li></ul><p>正确答案： C</p><p><strong>7</strong></p><p>【单选题】我国进行社会主义革命所用的方法是()。</p><ul><li>A、暴力</li><li>B、革命</li><li>C、和平</li><li>D、暴力与和平相结合</li></ul><p>正确答案： C</p><p><strong>8</strong></p><p>【单选题】党的过渡时期总路线所指的过渡时期是()。</p><ul><li>A、从中华人民共和国成立到国民经济恢复</li><li>B、从国民经济恢复到社会主义改造基本完成</li><li>C、从中华人民共和国成立到党的十一届三中全会召开</li><li>D、从中华人民共和国成立到社会主义改造基本完成</li></ul><p>正确答案： D</p><p><strong>9</strong></p><p>【单选题】在新民主主义社会中存在多种经济成分,其中掌握了国家主要经济命脉的是()。</p><ul><li>A、国营经济</li><li>B、合作社经济</li><li>C、个体经济</li><li>D、私人资本主义经济</li></ul><p>正确答案： A</p><p><strong>10</strong></p><p>【单选题】资本主义工商业社会主义改造采取从低级到高级的( )过渡形式。</p><ul><li>A、和平赎买</li><li>B、国家资本主义</li><li>C、暴力革命</li><li>D、集体没收</li></ul><p>正确答案： B</p><p><strong>11</strong></p><p>【单选题】关于新民主主义社会的性质,以下不正确的说法是()。</p><ul><li>A、不是一个独立的社会形态</li><li>B、是属于社会主义体系的过渡性社会</li><li>C、是属于资本主义体系的过渡性社会</li><li>D、是一个既有社会主义因素又有非社会主义因素的过渡性社会</li></ul><p>正确答案： C</p><p><strong>12</strong></p><p>【单选题】我国农业合作化过程中建立的高级农业生产合作社的性质是()。</p><ul><li>A、具有社会主义萌芽性质</li><li>B、完全社会主义性质</li></ul><p>正确答案： B</p><p><strong>13</strong></p><p>【单选题】民族资产阶级在社会主义改造时期仍具有两面性,主要表现为()。</p><ul><li>A、革命性和妥协性</li><li>B、主动性和被动性</li><li>C、剥削工人的一面和接受共产党领导和改造的一面</li><li>D、有进步性和顽固性</li></ul><p>正确答案： C</p><p><strong>14</strong></p><p>【单选题】新民主主义社会向社会主义社会转变的根本保证是()。</p><ul><li>A、马克思主义指导思想地位的确立</li><li>B、人民民主专政政权在全国范围的建立</li><li>C、社会主义国营经济领导地位的确立</li><li>D、共产党领导的人民武装力量的壮大</li></ul><p>正确答案： B</p><p><strong>15</strong></p><p>【多选题】新中国成立初期,中国处于新民主主义社会,其经济成分有()。</p><ul><li>A、社会主义性质的国营经济</li><li>B、个体经济</li><li>C、私人资本主义经济</li><li>D、半社会主义性质的合作社经济</li></ul><p>正确答案： ABCD </p><p><strong>16</strong></p><p>【多选题】20世纪50年代中期,社会主义改造基本完成,标志着()。</p><ul><li>A、社会主义制度在我国已经确立</li><li>B、我国进入了社会主义初级阶段</li></ul><p>正确答案： AB </p><p><strong>17</strong></p><p>【多选题】在对资本主义工商业进行社会主义改造过程中采取的国家资本主义的初级形式有()。</p><ul><li>A、计划订货</li><li>B、统购包销</li><li>C、经销代销</li><li>D、租赁承包</li></ul><p>正确答案： ABC </p><p><strong>18</strong></p><p>【多选题】关于社会主义改造说法正确的是()。</p><ul><li>A、社会主义改造的基本完成,使我国社会经济结构发生了根本变化</li><li>B、社会主义改造的基本完成,使我国社会的阶级关系发生了根本变化</li><li>C、社会主义改造的基本完成,表明我国的一切剥削现象都已经被消灭</li><li>D、社会主义改造的基本完成,表明社会主义制度已经基本确立</li></ul><p>正确答案： ABD </p><p><strong>19</strong></p><p>【多选题】我的社会主义改造也出现了一些失误和偏差,主要是农业合作化以及手工业和个体商业的改造()。</p><ul><li>A、要求过急</li><li>B、工作过粗</li></ul><p>正确答案： AB </p><p><strong>20</strong></p><p>【判断题】</p><p>党在过渡时期总路线的主体是完成对农业、手工业和资本主义工商业的社会主义改造。</p><p>正确答案：<strong>×</strong> </p><p><strong>21</strong></p><p>【判断题】我国社会主义改革的实质是对20世纪50年代中期社会主义改造的否定。</p><p>正确答案：<strong>×</strong> </p><p><strong>22</strong></p><p>【判断题】社会主义改造时期,国家对私人资本主义经济采取的是剥夺政策.</p><p>正确答案：<strong>×</strong> </p><p><strong>23</strong></p><p>【判断题】社会主义改造时期,国家对私人资本主义经济采取的是和平赎买政策。</p><p>正确答案：<strong>√</strong> </p><p><strong>24</strong></p><p>【判断题】在个别企业的公私合营阶段,企业利润的分配实行“四马分肥”的形式。</p><p>正确答案：<strong>√</strong> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第三次毛概作业题&lt;/p&gt;
    
    </summary>
    
      <category term="day++" scheme="http://yoursite.com/categories/day/"/>
    
    
  </entry>
  
  <entry>
    <title>Day8不确定推理</title>
    <link href="http://yoursite.com/2020/03/14/Day8%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%8E%A8%E7%90%86/"/>
    <id>http://yoursite.com/2020/03/14/Day8不确定推理/</id>
    <published>2020-03-14T14:26:15.208Z</published>
    <updated>2020-03-16T13:03:14.479Z</updated>
    
    <content type="html"><![CDATA[<p>补充内容</p><a id="more"></a><h1 id="不确定性推理方法"><a href="#不确定性推理方法" class="headerlink" title="不确定性推理方法"></a>不确定性推理方法</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>略</p><h2 id="概率方法"><a href="#概率方法" class="headerlink" title="概率方法"></a>概率方法</h2><h3 id="经典概率方法"><a href="#经典概率方法" class="headerlink" title="经典概率方法"></a>经典概率方法</h3><p>产生式规则：$IF \ \  E \ \  THEN \ \ H_i \ \  i =1,2,…,n$</p><p>$P(H_i | E)$：在证据$E$出现的条件下，结论$H_i$成立的确定性程度</p><p>复合条件：$E = E_1 \ AND  \ E_2 \ AND \ …\ AND \ E_m$</p><p>$P(H_i|E_1,E_2,…,E_m)$：在证据$E_1,E_2,…,E_m$出现时结论的确定程度</p><p>$P(H) = P(H|E)P(E) + P(H|\neg E)P(\neg E)$</p><p><strong>条件概率、先验概率和后验概率</strong></p><p>假设迟到的原因有2个：天气不好、起床晚了</p><p>先验概率：迟到的概率</p><p>条件概率：已知天气不好的条件下，迟到的概率</p><p>后验概率：已经迟到了，因为天气原因迟到的概率</p><h3 id="逆概率方法"><a href="#逆概率方法" class="headerlink" title="逆概率方法"></a>逆概率方法</h3><p>Bayes定理：$P(E|H_i) \rightarrow P(H_i|E)$</p><p><strong>Bayes公式</strong><br>$$<br>P(H|E) = \frac{P(E|H)P(H)}{ P(E)}<br>$$</p><p>$$<br>P(H_i|E) = \frac{P(E|H_i)P(H_i)}{\sum_{j=1}^{n}P(E|H_j)P(H_j)}\ \ i = 1,2,…,n<br>$$<br><strong>推广</strong></p><p>多个证据$E_1,E_2,…,E_m$，多个结论$H_1,H_2,…,H_n$，每个证据都以一定程度支持结论<br>$$<br>P(H_i|E_1E_2…E_m) = \frac{P(E_1|H_i)P(E_2|H_i)…P(E_m|H_i)P(H_i)}{\sum_{j=1}^{n}P(E_1|H_j)P(E_2|H_j)…P(E_m|H_j)P(H_j)}<br>$$</p><h2 id="主观Bayes方法"><a href="#主观Bayes方法" class="headerlink" title="主观Bayes方法"></a>主观Bayes方法</h2><h4 id="知识的不确定性的表示"><a href="#知识的不确定性的表示" class="headerlink" title="知识的不确定性的表示"></a>知识的不确定性的表示</h4><p>知识：$IF \ \ E  \ \ THEN \ \ (LS,LN) \ \ H \ \ (P(H))$</p><p>$E$：前提条件（简单条件和复合条件）</p><p>$H$：结论</p><p>$(LS,LN)$：规则强度<br>$$<br>LS = \frac{P(E|H)}{P(E| \neg H)}<br>$$</p><p>$$<br>LN = \frac{P(\neg E|H)}{P(\neg E| \neg H)} = \frac{1 - P(E|H)}{1 - P(E|\neg H)}<br>$$</p><p>特别说明一种情况，自己没怎么看清，太菜了，上面两式直接可以消去$P(E|H)$或者$P(E|\neg H)$，不就可以得到一个新的式子了吗<del>一直以为作业题是假的，错怪出题人了！</del><br>$$<br>P(E|H) = \frac{LN \times LS - LS}{LN -LS}<br>$$</p><h4 id="证据的不确定性的表示"><a href="#证据的不确定性的表示" class="headerlink" title="证据的不确定性的表示"></a>证据的不确定性的表示</h4><p>$P(E|S)$：对于初始证据$E$，由用户根据观察结果$S$给出概率，由结果推原因</p><p>$C(E|S)$：可信度，对所提供的证据可以相信的程度</p><h4 id="组合证据不确定性算法"><a href="#组合证据不确定性算法" class="headerlink" title="组合证据不确定性算法"></a>组合证据不确定性算法</h4><p>合取$\wedge$</p><p>$P(E|S) = min${$P(E_1|S),P(E_2|S),…,P(E_n|S)$}</p><p>析取$ \vee$</p><p>$P(E|S) = max${$P(E_1|S),P(E_2|S),…,P(E_n|S)$}</p><p>非$\neg$</p><p>$P(\neg E|S) = 1- P(E|S)$</p><h4 id="不确定性传递算法"><a href="#不确定性传递算法" class="headerlink" title="不确定性传递算法"></a>不确定性传递算法</h4><p>$P(H)[先验概率]通过P(E),LS,LN,得到P(H|E)或者P(H|\neg E) [后验概率]$</p><ul><li><p>证据肯定存在时，即$P(E) = P(E|S) = 1$<br>$$<br>\frac{结论H成立的概率}{结论H不成立的概率} = \frac{P(H|E)}{P(\neg H|E)} = \frac{P(E|H) P(H)}{P(E|\neg H)P(\neg H)}<br>$$</p><ul><li><p>几率($odds$)函数：$O(x) =\frac{P(x)}{P(\neg x)} =  \frac{P(x)}{1-P(x)}$</p></li><li><p>概率：$P(x) = \frac{O(x)}{1+O(x)}$</p></li><li><p>$P(x) \in [0,1] \ \ \ O(x) \in [0,\infty)$</p></li><li><p>几率函数和概率函数具有相同的单调性</p></li><li><p>有了几率函数，原上式可转变如下（Bayes修正公式）：<br>$$<br>O(H|E) = LS \times O(H)<br>$$</p><p>$$<br>P(H|E) = \frac{LS \times P(H)}{(LS - 1)\times P(H)+1}<br>$$</p><ul><li>$LS &gt; 1 , O(H|E) &gt; O(H) \rightarrow P(H|E) &gt; P(H)$</li><li>$LS = 1 , O(H|E) = O(H)$</li><li>$LS &lt; 1 , O(H|E) &lt; O(H)$</li><li>$LS = 0,O(H|E) = 0$</li></ul></li></ul></li><li><p>证据肯定不存在时，即$P(E) = P(E|S) = 0 , P(\neg E) =1$<br>$$<br> \frac{P(H|\neg E)}{P(\neg H|\neg E)} = \frac{P(\neg E|H) P(H)}{P(\neg E|\neg H)P(\neg H)}<br>$$</p><ul><li><p>Bayes修正公式<br>$$<br>O(H|\neg E) = LN \times O(H)<br>$$</p><p>$$<br>P(H|\neg E) = \frac{LN \times P(H)}{(LN-1)\times P(H)+1}<br>$$</p><ul><li>$LS &gt; 1 , O(H|\neg E) &gt; O(H) \rightarrow P(H|\neg E) &gt; P(H)$</li><li>$LS = 1 , O(H|\neg E) = O(H)$</li><li>$LS &lt; 1 , O(H|\neg E) &lt; O(H)$</li><li>$LS = 0,O(H|\neg E) = 0$</li></ul></li></ul></li><li><p>由于$E$和$\neg E$不可能同时成立，以下情况不存在</p><ul><li>$LS &gt;1 , LN &gt;1$</li><li>$LS &lt;1 , LN &lt;1$</li></ul></li><li><p>证据不确定的情况<br>$$<br>P(H|S) = P(H|E) \times P(E|S) + P(H | \neg E) \times P(\neg E |S)<br>$$</p><ul><li><p>$P(E|S) =1$</p><p>$P(H|S) = P(H|E)=\frac{LS \times P(H)}{(LS-1) \times P(H)+1}$</p></li><li><p>$P(E|S)=0$</p><p>$P(H|S) = P(H|\neg E) = \frac{LN \times  P(H)}{(LN-1)\times P(H)+1 }$</p></li><li><p>$P(E|S)=P(E)$</p><p>$P(H|S)=P(H)$</p></li><li><p>$P(E|S)$为其他值</p><p>通过Bayes公式来求$P(E)$<br>$$<br>P(H|S) = \begin{cases}<br>P(H|\neg E)+\frac{P(H)-P(H|\neg E)}{P(E)} \times P(E|S) &amp;  0\leq P(E|S) &lt; P(E) \newline<br>P(H)+\frac{P(H|E)-P(H)}{1-P(E)} \times [P(E|S)-P(E)]  &amp; P(E) \leq P(E|S) \leq 1<br>\end{cases}<br>$$</p><p>$$<br>P(H|S) = \begin{cases}<br>P(H|\neg E)+[P(H)-P(H|\neg E)] \times [\frac{1}{5}C(E|S)+1] &amp;  C(E|S) \leq 0 \newline<br>P(H)+[P(H|E)-P(H)] \times [\frac{1}{5 C(E|S)}]  &amp; C(E|S)&gt;0<br>\end{cases}<br>$$</p></li></ul></li></ul><h4 id="结论不确定性合成算法"><a href="#结论不确定性合成算法" class="headerlink" title="结论不确定性合成算法"></a>结论不确定性合成算法</h4><p>若$n$条知识都支持相同的结论，且每条知识的前提条件所对应的证据$E_i(i=1,2,…,n)$都有相应的观察$S_i$与之对应，则先对每条知识分别求出$O(H|S_i)$，然后求出$O(H|S_1,S_2,…,S_n)$：<br>$$<br>O(H|S_1,S_2,…,S_n) = \frac{O(H|S_1)}{O(H)} \frac{O(H|S_2)}{O(H)}…\frac{O(H|S_n)}{O(H)}O(H)<br>$$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;补充内容&lt;/p&gt;
    
    </summary>
    
      <category term="day++" scheme="http://yoursite.com/categories/day/"/>
    
    
  </entry>
  
  <entry>
    <title>Day7—第三周毛概题</title>
    <link href="http://yoursite.com/2020/03/09/Day7(%E6%AF%9B%E6%A6%82%E9%A2%98)/"/>
    <id>http://yoursite.com/2020/03/09/Day7(毛概题)/</id>
    <published>2020-03-09T13:39:03.665Z</published>
    <updated>2020-03-14T14:27:29.411Z</updated>
    
    <content type="html"><![CDATA[<p>新民主主义革命理论</p><a id="more"></a><p>1、(D)【单选题】农村包围城市、武装夺取政权道路理论成为全党的指导思想,是在()。<br>  A八七会议后<br>  B中共六大后<br>  C古田会议后<br>  D遵义会议后<br>2、(D)【单选题】新旧民主主义革命区别的根本标志是()。<br>  A革命对象不同<br>  B革命前途不同<br>  C革命动力不同<br>  D革命领导阶级不同<br>3、(D)【单选题】1948年,毛泽东完整地提出新民主主义革命总路线和总政策的文章是()。<br>  A《中国社会各阶级的分析》<br>  B《新民主主义论》<br>  C《论人民民主专政》<br>  D《在晋绥干部会议上的讲话》<br>4、(A)【单选题】近代中国历史发展的客观规律,决定了中国新民主主义社会必然转向()。<br>  A社会主义社会<br>  B资本主义社会<br>  C封建社会<br>  D共产主义社会<br>5、(D)【单选题】中国共产党人从中国国情出发,逐渐认识到中国革命的主要形式是()。<br>  A开展工农运动<br>  B开展地下斗争<br>  C开展合法斗争<br>  D开展武装斗争<br>6、(D)【单选题】实现无产阶级领导权的根本保证是()。<br>  A建立以工农联盟为基础的广泛统一战线<br>  B实行独立自主的方针<br>  C建立一支强大的革命武装<br>  D加强无产阶级政党的建设<br>7、(A)【单选题】()是中国革命的首要问题<br>  A分清敌友<br>  B分清主次矛盾<br>  C明确革命对象<br>  D明确革命动力<br>8、(B)【单选题】在下列著作中毛泽东第一次提出“三大法宝”的是()。<br>  A《新民主主义论》<br>  B《〈共产党人〉发刊词》<br>  C《中国革命和中国共产党》<br>  D《论联合政府》<br>9、(C)【单选题】中国共产党领导中国革命斗争,建立统一战线,必须认清中国社会是一个()。<br>  A小资产阶级众多的社会<br>  B农民众多的社会<br>  C“两头小中间大”的社会<br>  D敌人异常强大的社会<br>10、(A)【单选题】中国社会进步的主要障碍是()。<br>  A封建主义<br>  B帝国主义<br>  C资本主义<br>  D保守主义<br>11、(A)【单选题】旧民主主义革命失败的最根本的原因是()。<br>  A中国资产阶级的软弱性和妥协性<br>  B帝国主义与封建势力过于强大<br>  C缺乏强有力的领导核心<br>  D没有发动农民<br>12、(D)【单选题】中国革命的主力军和生力军是()。<br>  A工人<br>  B城市小资产阶级<br>  C民族资产阶级<br>  D农民<br>13、(A)【单选题】中国革命的中心问题是()。<br>  A无产阶级的领导权问题<br>  B对国情分析问题<br>  C国家政权问题<br>  D统一战线问题<br>14、(B)【单选题】中国共产党内产生“左”、“右”倾机会主义错误的主要思想根源是()。<br>  A资产阶级思想<br>  B小资产阶级思想<br>  C封建主义思想<br>  D修正主义思想<br>15、(B)【单选题】无产阶级及其政党在资产阶级民主革命中的领导作用,最主要的就是实现对()。<br>  A小资产阶级的领导<br>  B农民阶级的领导<br>  C民族资产阶级的领导<br>  D资产阶级的领导<br>16、(A)【单选题】中国革命的基本问题是()。<br>  A农民问题<br>  B土地问题<br>  C政权问题<br>  D军事问题<br>17、(A)【单选题】认清中国一切革命问题的基本依据是()。<br>  A认清国情<br>  B认清中国社会的主要矛盾<br>  C认清革命的领导权<br>  D认清中国农民问题的重要性<br>18、(D)【单选题】新民主主义革命的指导思想是()。<br>  A三民主义<br>  B新三民主义<br>  C民主主义<br>  D马克思主义<br>19、(A)【单选题】新民主主义革命总路线的核心是()。<br>  A无产阶级的领导<br>  B人民大众的参与<br>  C工农联盟的巩固<br>  D人民军队的建设<br>20、(B)【单选题】“工农武装割据”的中心内容是()。<br>  A武装斗争<br>  B土地革命<br>  C革命根据地建设<br>  D党的领导<br>21、(C)【单选题】新民主主义革命的中心内容是()。<br>  A没收封建地主阶级的土地归新民主主义国家所有<br>  B没收官僚垄断资本归新民主主义国家所有<br>  C没收封建地主阶级的土地归农民所有<br>  D保护民族工商业<br>22、(C)【单选题】中国共产党抗日民族统一战线的策略总方针是()。<br>  A“一切经过统一战线”、“一切服从统一战线”<br>  B又联合又斗争,以斗争求团结<br>  C发展进步势力,争取中间势力,孤立顽固势力<br>  D独立自主,自力更生<br>23、(B)【单选题】中国共产党建设的特殊困难首先表现在()。<br>  A资产阶级思想影响比较严重<br>  B小资产阶级思想影响比较严重<br>  C改良主义思想影响比较严重<br>  D修正主义思想影响比较严重<br>24、(A)【单选题】中国人民最凶恶的敌人是()。<br>  A帝国主义<br>  B封建主义<br>  C官僚资本主义<br>  D民族资本主义<br>25、(A)【单选题】中国革命统一战线最根本的问题是()。<br>  A革命领导权问题<br>  B工农联盟问题<br>  C政策和策略问题<br>  D分清敌友问题<br>26、(D)【单选题】解放战争时期的革命统一战线是()。<br>  A国民革命联合战线<br>  B工农民主统一战线<br>  C抗日民族统一战线<br>  D人民民主统一战线<br>27、(D)【单选题】半殖民地半封建中国社会最主要的矛盾是()。<br>  A地主阶级与农民阶级的矛盾<br>  B无产阶级与资产阶级的矛盾<br>  C人民大众与封建主义的矛盾<br>  D帝国主义与中华民族的矛盾<br>28、(A)【单选题】帝国主义奴役近代中国的社会基础是()。<br>  A封建主义<br>  B帝国主义<br>  C小资产阶级<br>  D民族资产阶级<br>29、(D)【单选题】近代中国之所以沦为半殖民地半封建社会的根本原因是()。<br>  A农民革命斗争的失败<br>  B中国封建主义的统治<br>  C中国资本主义的软弱<br>  D帝国主义的侵略<br>30、(B)【单选题】建设新型人民军队的根本原则是()。<br>  A枪指挥党<br>  B坚持党对军队的绝对领导<br>  C官兵一致的原则<br>  D军民一致的原则<br>31、(B)【单选题】中国新民主主义革命的开端是()。<br>  A新文化运动<br>  B五四运动<br>  C中国共产党的成立<br>  D五卅运动<br>32、(C)【单选题】毛泽东着重强调党的()。<br>  A政治建设<br>  B组织建设<br>  C思想建设<br>  D作风建设<br>33、(D)【单选题】新民主主义的政权政治纲领是建立()。<br>  A无产阶级专政的共和国<br>  B资产阶级专政的共和国<br>  C无产阶级与资产阶级联合专政的共和国<br>  D无产阶级领导的各个革命阶级联合专政的民主共和国<br>34、(B)【单选题】在中国革命进程中,具有新民主主义革命和社会主义革命双重性质的事件是()。<br>  A没收封建阶级的土地归农民所有<br>  B没收官僚资本归新民主主义国家所有<br>  C接收帝国主义在华企业归新民主主义国家所有<br>  D.赎买民族工商业归人民民主专政国家所有<br>35、(D)【单选题】建设新型人民军队的基本前提是()。<br>  A坚持党对军队的绝对领导<br>  B以少胜多,以弱胜强<br>  C集中优势兵力,各个歼灭敌人<br>  D坚持全心全意为人民服务的宗旨<br>36、(A)【单选题】中国革命红色政权能够存在和发展的根本原因是()。<br>  A中国的政治经济发展不平衡<br>  B共产党的正确领导<br>  C有相当力量的正式红军的存在<br>  D有良好的群众基础<br>37、(A)【单选题】中国革命武装斗争的实质是无产阶级领导下的()。<br>  A农民战争<br>  B土地革命<br>  C政治革命<br>  D群众运动<br>38、(B)【单选题】中国的新民主主义革命是()。<br>  A旧式的资产阶级民主革命<br>  B新式的特殊的资产阶级民主革命<br>  C无产阶级社会主义革命<br>  D带有社会主义性质的革命<br>39、(ABCD)【多选题】中国共产党人从国民革命失败的经验教训中,深刻认识到具有极端重要性的问题有()。<br>  A无产阶级领导权问题<br>  B中国农民问题的重要性<br>  C武装斗争问题的极端重要性<br>  D统一战线的必要性问题<br>40、(CD)【多选题】新民主主义革命和社会主义革命的关系是()。<br>  A新民主主义革命与社会主义革命可以“毕其功于一役”<br>  B两个革命之间需要有一个资本主义的过渡阶段<br>  C新民主主义革命是社会主义革命的必要准备<br>  D社会主义革命是新民主主义革命的必然趋势<br>41、(BCD)【多选题】新民主主义文化的基本特征是()。<br>  A革命的<br>  B民族的<br>  C科学的<br>  D大众的<br>42、(BCD)【多选题】中国官僚资本主义的主要特点是()。<br>  A落后性<br>  B买办性<br>  C封建性<br>  D垄断性<br>43、(ABC)【多选题】民主革命时期党的优良作风是()。<br>  A理论联系实际<br>  B密切联系群众<br>  C批评与自我批评<br>  D解放思想<br>44、(ABCD)【多选题】中国革命统一战线建立和发展经历的阶段有()。<br>  A国民革命联合战线<br>  B工农民主统一战线<br>  C抗日民族统一战线<br>  D人民民主统一战线<br>45、(ABCD)【多选题】民主革命时期党的建设的主要内容是()。<br>  A必须把思想建设始终放在首位<br>  B必须重视党的组织建设<br>  C必须重视党的作风建设<br>  D必须联系党的政治路线加强党的建设<br>46、(ABCD)【多选题】新民主主义革命时期红色政权产生和发展的原因和条件是()。<br>  A半殖民地半封建的中国政治经济发展的极端不平衡<br>  B有良好的群众基础<br>  C有不断向前发展的革命形势<br>  D有相当力量的红军的存在和党的领导有力量及其政策的不错误<br>47、(ABC)【多选题】中国的武装斗争实质上是无产阶级领导下的农民战争,其原因是()。<br>  A农民是中国革命的主要力量,是中国革命的最广大的动力<br>  B农民是中国革命军队的主要来原,不同时期的人民武装力量,绝大部分是穿着军装的农民<br>  C中国革命斗争主要是党领导下的农民游击战争<br>  D中国工人阶级部分是由农民转化而来的,与农民有着天然的联系<br>48、(BC)【多选题】毛泽东认为中国资产阶级包括()。<br>  A城市小资产阶级<br>  B大资产阶级<br>  C民族资产阶级<br>  D富豪<br>49、(ABCD)【多选题】新民主主义革命的动力,包括()。<br>  A无产阶级<br>  B农民阶级<br>  C城市小资产阶级<br>  D民族资产阶级<br>50、(ABC)【多选题】毛泽东在《&lt;共产党人&gt;发刊词》中指出中国革命的基本武器是()。<br>  A党的建设<br>  B统一战线<br>  C武装斗争<br>  D土地革命<br>51、(AC)【多选题】近代中国社会的阶级结构是“两头小中间大”,“两头”是指()。<br>  A无产阶级<br>  B农民阶级<br>  C地主大资产阶级<br>  D城市小资产阶级<br>52、(ABCD)【多选题】邓小平指出:“马克思、列宁从来没有说过农村包围城市,这个原理在当时世界上还是没有的。但是毛泽东同志根据中国的具体条件指明了革命的具体道路”。毛泽东找到农村包围城市、武装夺取政权这条道路的根据是()。<br>  A中国内无民主制度,外无民族独立<br>  B农民占人口绝大多数,是民主革命的主力军<br>  C中国革命的敌人长期占据着中心城市,农村是其统治的薄弱环节<br>  D中国经济政治发展的不平衡<br>53、(ABCD)【多选题】中国革命战争的特点是()。<br>  A敌人总是长期占据着中心城市<br>  B敌人异常强大<br>  C红军相对弱小<br>  D农村是敌人相对薄弱的地区<br>54、(BCD)【多选题】在新民主主义革命运动中处于中间地位的阶级和阶层有()。<br>  A无产阶级<br>  B农民阶级<br>  C城市小资产阶级<br>  D民族资产阶级<br>55、(ABCD)【多选题】新旧民主主义革命的区别是()。<br>  A时代背景不同<br>  B领导权不同<br>  C指导思想不同<br>  D前途不同<br>56、(BCD)【多选题】“工农武装割据”的思想是指在中国共产党领导下,以()。<br>  A农村政权为根本<br>  B土地革命为中心内容<br>  C武装斗争为主要形式<br>  D革命根据地为战略阵地<br>57、(错)【判断题】新旧民主革命的根本区别在于革命任务不同。</p><p>58、(错)【判断题】中国共产党在中国革命中战胜敌人的三大法宝是指统一战线、武装斗争和土地革命。</p><p>59、(错)【判断题】人民军队的唯一宗旨是坚持党对军队的绝对领导。</p><p>60、(对)【判断题】革命统一战线的最根本问题是领导权问题。</p><p>61、(对)【判断题】毛泽东十分强调从思想上建党。</p><p>62、(错)【判断题】中国革命要一切经过统一战线,一切服从统一战线。</p><p>63、(对)【判断题】红色政权存在和发展的根本原因是政治经济发展极端不平衡。</p><p>64、(错)【判断题】中国革命最广大的动力是无产阶级。</p><p>65、(对)【判断题】三大作风是中国共产党区别于其他任何政党的显著标志。</p><p>66、(错)【判断题】中国革命的主要斗争形式是政治斗争。</p><p>67、(错)【判断题】新民主主义共和国属无产阶级专政的社会主义国家。</p><p>68、(对)【判断题】新民主主义革命的前途是社会主义。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新民主主义革命理论&lt;/p&gt;
    
    </summary>
    
      <category term="day++" scheme="http://yoursite.com/categories/day/"/>
    
    
  </entry>
  
  <entry>
    <title>Day6</title>
    <link href="http://yoursite.com/2020/03/04/Day6/"/>
    <id>http://yoursite.com/2020/03/04/Day6/</id>
    <published>2020-03-04T14:03:49.881Z</published>
    <updated>2020-03-05T13:28:50.047Z</updated>
    
    <content type="html"><![CDATA[<p>链式前向星 &amp;&amp; 手写Hash</p><a id="more"></a><h4 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h4><p>对于图来说，链式前向星的概念就不得不提及了，其中的链表的思想也是手写Hash的重要一环</p><p>什么是链式前向星，就是利用链表的方式存图</p><p>定义一个结构体，其中包含next和to</p><p>next：表示与这个边起点相同的上一条边的编号</p><p>to：表示这条边的终点</p><p>ecnt：表示边的编号</p><p>还要定义一个head数组，head[i]表示以i为起点的最后一条边的编号</p><p>最开始head数组赋值为-1</p><p>加边操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    e[ecnt].nex=head[from];</span><br><span class="line">    e[ecnt].to=to;</span><br><span class="line">    head[from]=ecnt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过加边操作我们可以记录所有从from出去的边，然后把每条边的前面的值放入next值中。</p><p>那么我们遍历每个点的边是，只要递归地寻找head[i]，然后再往E[i].next找即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=head[i]; ~j; j=e[j].nex)&#123;</span><br><span class="line">        <span class="comment">//这条边就是i-&gt;e[j].to</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">egde</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> nex,to;</span><br><span class="line">&#125;e[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn],ecnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="built_in">memset</span>(in,<span class="number">0</span>,<span class="keyword">sizeof</span> in);</span><br><span class="line">    ecnt=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    e[ecnt].nex=head[from];</span><br><span class="line">    e[ecnt].to=to;</span><br><span class="line">    head[from]=ecnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=head[i]; ~j; j=e[j].nex)&#123;</span><br><span class="line">        <span class="comment">//这条边就是i-&gt;e[j].to</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="手写Hash"><a href="#手写Hash" class="headerlink" title="手写Hash"></a>手写Hash</h4><p>c++的STL有hash的两个函数，一个是map一个是unorder_map，都可以标记哪个数是否出现过，效率还可以$logn$，但是常数大。</p><p>我们可以直接手写Hash，利用链式前向星的思想，找一个不是特别大的质模数，然后对于每个模数相当于建立一个点，每次出现一个同模的就可以建立一条边，比如模数为$mod$，就会有$mod$个余数，每次加数的时候先求余数，然后加到那个余数集合里面，存储就用链式前向星的方法。</p><p>当数不是特别大特别多的时候，这个效率还可以。</p><p>但是这种一般题目可以用，（一般还是用unorder_map，这里只是介绍一种思想），如果卡模数就没办法了，只能更换模数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hash</span>&#123;</span></span><br><span class="line">    ll mod = <span class="number">2908361</span>;</span><br><span class="line">    ll cnt = <span class="number">0</span>, Head[<span class="number">2908361</span>], nxt[<span class="number">1000006</span>];</span><br><span class="line">    ll val[<span class="number">1000006</span>], pos[<span class="number">1000006</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(Head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(Head)); cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(ll x, ll v)</span></span>&#123;</span><br><span class="line">        ll key = x % mod;</span><br><span class="line">        pos[cnt] = x, val[cnt] = v, nxt[cnt] = Head[key];</span><br><span class="line">        Head[key] = cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">Find</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">        ll key = x % mod;</span><br><span class="line">        <span class="keyword">for</span>(ll i = Head[key]; ~i; i = nxt[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(pos[i] == x) <span class="keyword">return</span> val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1l</span>l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;hs;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链式前向星 &amp;amp;&amp;amp; 手写Hash&lt;/p&gt;
    
    </summary>
    
      <category term="day++" scheme="http://yoursite.com/categories/day/"/>
    
    
  </entry>
  
  <entry>
    <title>Day5</title>
    <link href="http://yoursite.com/2020/03/03/Day5/"/>
    <id>http://yoursite.com/2020/03/03/Day5/</id>
    <published>2020-03-03T12:10:33.534Z</published>
    <updated>2020-03-04T14:02:53.634Z</updated>
    
    <content type="html"><![CDATA[<p>拓扑排序</p><a id="more"></a><p>对于一个有向无环图，我们可以需要求一个特定的序列。</p><p>比如说一个很经典的例子，先修课程例子，必须先修完先修课程才能修本课。</p><pre class="mermaid">graph LRA((A)) --> B((B));A --> C((C));B --> D((D));C --> D;</pre><pre class="mermaid">graph LRB1((B)) --> D1((D));C1((C)) --> D1;</pre><pre class="mermaid">graph LR;D2((D));</pre><p>很简单的一个排序就是ABCD或者ACBD。</p><p>那么怎么通过程序得到这个拓扑排序呢</p><p>我们需要知道图中的点有出度和入度，当一个点没有入度，我们就可以知道这个点没有先修课程，这个点就可以当作目前的第一个选择。</p><p>然后我们选择了这个点，那么我们就需要把这点以及所有从这点出去的线都删除。然后再进行后续操作。</p><p>由此我们可以写出拓扑排序的模板</p><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3342" target="_blank" rel="noopener">HDU-3342</a></p><p>题意：问一个图是否有拓扑序列，点从0开始</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">egde</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> nex,to;</span><br><span class="line">&#125;e[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> in[maxn]; <span class="comment">//入度</span></span><br><span class="line"><span class="keyword">int</span> intmp[maxn]; </span><br><span class="line"><span class="keyword">int</span> seq[maxn]; <span class="comment">//一种可能的拓扑序</span></span><br><span class="line"><span class="keyword">int</span> head[maxn],ecnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="built_in">memset</span>(in,<span class="number">0</span>,<span class="keyword">sizeof</span> in);</span><br><span class="line">    ecnt=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    e[ecnt].nex=head[from];</span><br><span class="line">    e[ecnt].to=to;</span><br><span class="line">    head[from]=ecnt++;</span><br><span class="line">    in[to]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">topo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q; <span class="comment">//利用队列来进行存储seq序列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        intmp[i]=in[i];</span><br><span class="line">        <span class="keyword">if</span>(!intmp[i]) q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> ok=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(q.size()!=<span class="number">1</span>) ok=<span class="literal">true</span>; <span class="comment">//如果每次找点都有不止一个点符合入度为0,那么答案seq就不止一种</span></span><br><span class="line">        <span class="keyword">int</span> x=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        seq[num++]=x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x]; ~i; i=e[i].nex)&#123; <span class="comment">//链式前向星进行检索</span></span><br><span class="line">            <span class="keyword">int</span> son=e[i].to;</span><br><span class="line">            intmp[son]--; <span class="comment">//相当于删除边的操作,因为删除边就相当于减少了连接的点的入度</span></span><br><span class="line">            <span class="keyword">if</span>(!intmp[son]) q.push(son);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; n) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//没有拓扑序列</span></span><br><span class="line">    <span class="keyword">if</span>(ok) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//存在不止一个拓扑序列,seq是其中一种拓扑序列</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//seq是唯一的拓扑序列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m)&amp;&amp;n)&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x,y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x,&amp;y);</span><br><span class="line">            add(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp=topo();</span><br><span class="line">        <span class="keyword">if</span>(tmp != <span class="number">-1</span>) <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;拓扑排序&lt;/p&gt;
    
    </summary>
    
      <category term="day++" scheme="http://yoursite.com/categories/day/"/>
    
    
  </entry>
  
  <entry>
    <title>Day4—第二周毛概题</title>
    <link href="http://yoursite.com/2020/03/02/Day4(%E6%AF%9B%E6%A6%82%E9%A2%98)/"/>
    <id>http://yoursite.com/2020/03/02/Day4(毛概题)/</id>
    <published>2020-03-02T13:55:21.748Z</published>
    <updated>2020-03-03T12:10:55.327Z</updated>
    
    <content type="html"><![CDATA[<p>还是乱序，有点<del>sangxinbingkuang</del></p><a id="more"></a><p>1、【单选题】毛泽东思想开始萌芽是在(A)。<br>  A 中国共产党创建和国民革命时期<br>  B 土地革命战争前中期<br>  C 土地革命战争后期和抗日战争时期<br>  D 解放战争时期<br>2、【单选题】集中概括毛泽东思想的文献是(D)。<br>  A 毛泽东的诗词<br>  B 毛泽东的言论<br>  C 毛泽东晚年的实践<br>  D 毛泽东的科学著作<br>3、【单选题】毛泽东思想被确立为党的指导思想是在(C)。<br>  A 党的五大<br>  B 党的六大<br>  C 党的七大<br>  D 党的八大<br>4、【单选题】毛泽东关于党的建设理论最核心的内容和最重要的特点是(A)。<br>  A 着重于从思想上建设党<br>  B 着重于从组织上建设党<br>  C 着重于从政治上建设党<br>  D 着重于从作风上建设党<br>5、【单选题】毛泽东思想形成的时期是(B)。<br>  A 国民革命时期<br>  B 土地革命战争时期<br>  C 土地革命战争后期<br>  D 抗日战争时期<br>6、【单选题】毛泽东思想产生不是偶然的,它是现实需要的必然产物。这种现实需要主要表现为(B)。<br>  A 近代中国地主阶级和农民阶级矛盾激化的结果<br>  B 近代中国社会矛盾发展和人民斗争深入发展的需要<br>  C 近代激进知识分子活动的需要<br>  D 近代中国资产阶级革命的需要<br>7、【单选题】毛泽东思想形成和发展的实践基础是(C)。<br>  A 革命与战争<br>  B 和平与发展<br>  C 党领导的革命和建设实践<br>  D 新文化运动<br>8、【单选题】毛泽东思想科学体系的主要创立者是(A)。<br>  A 毛泽东<br>  B 周恩来<br>  C 朱德<br>  D 刘少奇<br>9、【单选题】对毛泽东和毛泽东思想做了新的实事求是的评价的是(B)。<br>  A 《党的若干历史问题的决议》<br>  B 《关于建国以来党的若干历史问题的决议》<br>  C 《论联合政府》<br>  D 《新民主主义论》<br>10、【单选题】毛泽东思想形成的时代背景是(D)。<br>  A 世界进入多极化<br>  B 全球化加速<br>  C 和平与发展成为时代主题<br>  D 战争与革命成为时代主题<br>11、【单选题】毛泽东思想走向成熟的时期是(C)。<br>  A 第一次国共合作时期<br>  B 解放战争前期<br>  C 土地革命后期和抗日战争时期<br>  D 党的七大召开前后<br>  //毛泽东思想走向成熟时期，即“毛泽东思想得到系统总结和多方面展开而达到成熟的阶段”，时间大体上是自1935年至1945年，即土地革命后期和抗日战争时期。<br>12、【单选题】在土地革命战争后期和抗日战争时期,毛泽东思想得到系统总结和全面展开而达到成熟,其成熟的主要标志是(C)。<br>  A 毛泽东同志在党的领导地位的确立<br>  B 党的理论素养的加强<br>  C 新民主主义革命理论的系统阐述<br>  D 党的思想路线的端正<br>13、【单选题】中国共产党成立前后,为毛泽东思想的萌芽准备了科学的世界观和方法论基础的是(B)。<br>  A 工人阶级队伍的壮大及工人运动发展<br>  B 马克思列宁主义在中国的广泛传播<br>  C 俄国十月革命的胜利成果的总结<br>  D 新文化运动中激进知识分子的参加<br>14、【单选题】毛泽东思想初步形成的标志是(A)。<br>  A 提出并阐述农村包围城市、武装夺取政权的思想<br>  B 提出人民民主专政的思想<br>  C 提出枪杆子出政权的思想<br>  D 完整阐述新民主主义革命总路线<br>15、【多选题】新民主主义革命理论的主要内容有(ABCD)。<br>  A 新民主主义革命的总路线<br>  B 农村包围城市、武装夺取政权的革命道路理论<br>  C 统一战线<br>  D 武装斗争和党的领导<br>16、【多选题】关于对毛泽东的评价正确的是(ACD)。<br>  A 毛泽东是伟大的马克思主义者<br>  B “文化大革命”的错误应完全归咎于毛泽东个人<br>  C 毛泽东是伟大的无产阶级理论家<br>  D 在一定意义上,毛泽东为中国特色社会主义道路的开创准备了条件<br>17、【多选题】毛泽东论述了革命斗争中政策和策略的重要性并提出了许多重要的思想,包括(ABC)。<br>  A 战略上要藐视敌人,战术上要重视敌人<br>  B 要掌握斗争的主要方向,不要四面出击<br>  C 对敌人区别对待、分化瓦解<br>  D 对被打倒的反动统治阶级成员和反动分子,不能给予生活出路<br>18、【多选题】毛泽东思想经历的历史进程主要有(ABC)。<br>  A 新民主义主义革命<br>  B 社会主义革命<br>  C 社会主义建设<br>  D 旧民主主义革命<br>19、【多选题】毛泽东认为社会主义社会的基本矛盾仍然是(AB)<br>  A 生产关系和生产力之间的矛盾<br>  B 上层建筑和经济基础之间的矛盾<br>  C 敌我之间的矛盾<br>  D 人民内部之间的矛盾<br>20、【多选题】毛泽东思想初步形成的主要代表作有(ABCD)。<br>  A 《中国的红色政权为什么能够存在》<br>  B 《反对本本主义》<br>  C 《井冈山的斗争》<br>  D 《星星之火,可以燎原》<br>21、【多选题】毛泽东思想经历多个发展阶段才最终走向成熟。在抗日战争期间,毛泽东思想得到多方面展开而达到成熟的主观条件是(ACD)。<br>  A 中国共产党理论素养的提高<br>  B 抗日战争的复杂环境和丰富实践<br>  C 毛泽东成为党的领导核心<br>  D 中国共产党思想路线的端正<br>22、【多选题】实事求是是指(ABC)。<br>  A 一切从实际出发<br>  B 理论联系实际<br>  C 坚持在实践中检验和发展真理<br>  D 从事物的表象出发<br>23、【多选题】十月革命对中国的影响主要表现在(AB)。<br>  A 它使中国的民主革命从旧的世界资产阶级民主革命转变为世界无产阶级社会主义革命的一部分。<br>  B 它为中国送来了马克思列宁主义,帮助中国的先进分子用无产阶级的世界观作为观察国家命运的工具。<br>  C 它为中国开辟了社会主义建设的道路<br>  D 它为中国进行社会主义改造提供了指导<br>24、【多选题】毛泽东思想是马克思主义中国化的重要理论成果,它是(ABC)<br>  A 马克思列宁主义在中国的运用和发展<br>  B 关于中国革命和建设的正确理论原则和经验总结<br>  C 中国共产党集体智慧的结晶<br>  D 毛泽东个人思想的集中体现<br>25、【多选题】毛泽东思想形成阶段的主要表现为(ABCD)。<br>  A 开辟了农村包围城市、武装夺取政权的道路<br>  B 同将马克思主义教条化的错误倾向做斗争<br>  C 同将共产国际决议神圣化的错误倾向做斗争<br>  D 同将苏联经验神圣化的错误倾向做斗争<br>26、【多选题】第一次国内革命战争时期,毛泽东在哪些著作中分析了中国社会各阶级在革命中的地位和作用,提出了新民主主义革命的基本思想(AB)。<br>  A 《中国社会各阶级的分析》<br>  B 《湖南农民运动考察报告》<br>  C 《中国革命和中国共产党》<br>  D 《新民主主义论》<br>27、【多选题】毛泽东关于社会主义革命和社会主义建设的思想集中体现在毛泽东以下哪些著作中(BCD)。<br>  A 《新民主主义论》<br>  B 《论人民民主专政》<br>  C 《论十大关系》<br>  D 《关于正确处理人民内部矛盾的问题》<br>28、【多选题】20世纪20年代后期和30年代前期,以毛泽东为代表的中国共产党人在党内反对的主要倾向是(ABC)。<br>  A 把马克思主义教条化<br>  B 把共产国际决议神圣化<br>  C 把苏联经验神圣化<br>  D 把中国经验神圣化<br>29、【多选题】毛泽东思想活的灵魂是(ABC)。<br>  A 实事求是<br>  B 群众路线<br>  C 独立自主<br>  D 勇于创新<br>30、【多选题】中国共产党建设的三大作风是(ACD)。<br>  A 理论联系实际<br>  B 实事求是<br>  C 密切联系群众<br>  D 批评与自我批评<br>31、【多选题】毛泽东思想的历史地位是(ABC)。<br>  A 马克思主义中国化第一次历史性飞跃的理论成果<br>  B 中国革命和建设的科学指南<br>  C 党和人民宝贵的精神财富<br>  D 中国社会主义现代化建设的理论基础<br>32、【多选题】以下对毛泽东思想的正确理解是(BCD)。<br>  A 毛泽东思想就是毛泽东的思想<br>  B 毛泽东思想是中国共产党集体智慧的结晶<br>  C 毛泽东思想是马克思主义中国化的第一大理论成果<br>  D 毛泽东思想是革命和建设的科学指南</p><p>33、(错)【判断题】毛泽东思想是中国化的马克思主义,因此,毛泽东思想不完全是马克思主义的。//毛泽东思想是马克思主义中国化</p><p>34、(错)【判断题】毛泽东关于社会主义建设的思想已经不符合实际,没有指导作用。</p><p>35、(对)【判断题】独立自主就是坚持民族自尊心,坚定不移走自己的路。</p><p>36、(对)【判断题】毛泽东第一个明确提出了“马克思主义中国化”的科学命题和重大任务。</p><p>37、(对)【判断题】新民主主义革命理论是毛泽东思想达到成熟的主要标志。</p><p>38、(错)【判断题】毛泽东思想指的就是新民主主义革命时期和社会主义改造时期的正确思想。</p><p>39、(错)【判断题】毛泽东的思想就是毛泽东思想。</p><p>40、(错)【判断题】毛泽东思想仅仅包括新民主主义革命时期的正确思想。</p><p>41、(对)【判断题】毛泽东是伟大的战略家和理论家。</p><p>42、(错)【判断题】“文化大革命”的错误都是毛泽东造成的。</p><p>43、(错)【判断题】毛泽东认为中国资产阶级有大资产阶级和小资产阶级两部分。//买办资产阶级和民资产阶级两个部分</p><p>44、(对)【判断题】全盘否定毛泽东和毛泽东思想与制造毛泽东的个人崇拜,都是错误的。出现这两种错误的其原因在于没有把毛泽东思想和毛泽东晚年所犯的错误区别开。</p><p>45、(错)【判断题】毛泽东认为经济工作是思想政治工作和其他一切工作的生命线。//政治工作是经济工作的生命线</p><p>46、(对)【判断题】批评与自我批评是马克思主义思想教育的整风形式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;还是乱序，有点&lt;del&gt;sangxinbingkuang&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="day++" scheme="http://yoursite.com/categories/day/"/>
    
    
  </entry>
  
  <entry>
    <title>Day3</title>
    <link href="http://yoursite.com/2020/03/01/Day3/"/>
    <id>http://yoursite.com/2020/03/01/Day3/</id>
    <published>2020-03-01T08:17:32.981Z</published>
    <updated>2020-03-02T13:58:57.934Z</updated>
    
    <content type="html"><![CDATA[<p>上一天了解了Dijkstra算法和Floyd两大最短路算法，但是如果图中有负环，那么每次更新就不会对了，那么我们需要另一个特殊的算法SPFA算法。</p><a id="more"></a><p>$SPFA$算法的全称就是Shortest Path Faster Algorithm，但是，在某些大型场合会被万恶的出题人卡掉<del>（丧心病狂）</del>，但是对于稀疏图和判断负环，这个算法的优越性还是有的。复杂度为$O(ke)$$(k \le 2)$，比Dijikstra和Floyd算法要低很多。</p><p>所谓负环，就是边权和为负数的环。</p><p>我们知道，一般情况下，图上的最短路都是确定的。但是一旦图上有一个负环，$s$到$t$的最短路就会不远千里的去覆盖上这个环（只要能够到达），并且不厌其烦的走上一遍又一遍。由于负环的边权和是负的，并且它是一个环，也就是说走一遍和走无数遍都停留在进入的那个点。那么最短路每经过一次这个负环，这个费用都会缩小一点，如果经过了无数次，也就是无穷小，也就是<strong>不存在最短路</strong>。当然这里有一个限定，就是每个点经过的次数不能超过$1$次。</p><p>$SPFA$与$Dijkstra$算法的主要区别就是一个是用$dfs$的方式来松弛操作，将dfs改成bfs之后，再来个计数操作判断负环。</p><p>$SPFA$的判定方式就是不断地收紧每个点到起点的最短路径，每次都不一定会收到最紧，但只要有解，最终一定会收成最紧（这也正是它这么好卡的原因，一点一点的，能不慢吗）。我们前面提到过，如果存在负环，那么最短路会不断缩小至无穷小。那么这里我们就可以应用它的这一特点。在$SPFA$中，每个点最短被其他$n−1$个点各收紧一次，如果被收紧了$n$次，显然是不合理的。那么我们就记录每个点被收紧的次数，有任何点超过$n$次，就可以判定存在负环了，如果$SPFA$成功运行完了，就证明不存在负环。</p><p>来个例题康康吧</p><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2066" target="_blank" rel="noopener">HDU-2066</a></p><p>题意：有T条路径，S个起点，D个终点，问你$S_i$到$D_j$最短路径是多少。</p><p>题解：对于每个$S_i$都跑一遍最短路就好了（这里直接用dijkstra也可以的）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;E[maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn],inq[maxn],num[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;maxn; i++)&#123;</span><br><span class="line">        E[i].clear();</span><br><span class="line">        inq[i]=<span class="number">0</span>;</span><br><span class="line">        dis[i]=inf;</span><br><span class="line">        num[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    q.push(s);</span><br><span class="line">    inq[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> now=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        inq[now]=<span class="number">0</span>;</span><br><span class="line">        num[now]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;(<span class="keyword">int</span>)E[now].size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> val=E[now][i].second;</span><br><span class="line">            <span class="keyword">int</span> j=E[now][i].first;</span><br><span class="line">            <span class="keyword">if</span>(dis[j]&gt;dis[now]+val)&#123;</span><br><span class="line">                dis[j]=dis[now]+val;</span><br><span class="line">                <span class="keyword">if</span>(!inq[j])&#123;</span><br><span class="line">                    q.push(j);</span><br><span class="line">                    inq[j]=<span class="number">1</span>;</span><br><span class="line">                    num[j]++;</span><br><span class="line">                    <span class="keyword">if</span>(num[j] &gt; n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,s,d,n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;t,&amp;s,&amp;d))&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;t; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x,y,z;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">            n=max(n,x);</span><br><span class="line">            n=max(n,y);</span><br><span class="line">            E[x].push_back(make_pair(y,z));</span><br><span class="line">            E[y].push_back(make_pair(x,z));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;d; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b[i]);</span><br><span class="line">        <span class="keyword">int</span> ans=inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s; i++)&#123;</span><br><span class="line">            SPFA(a[i],n);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;d; j++) ans=min(ans,dis[b[j]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看一个直接判断负环的题目</p><p><a href="https://www.luogu.com.cn/problem/P3385" target="_blank" rel="noopener">P3385 【模板】负环</a></p><p>题意：一个n，m。n代表n个点，m代表m条边，当边权为正表示双向边，否则为单向，求是否有负环。</p><p>有负环输出”YE5”，否则输出”N0”，来自出题人满满的恶意，YE5最后一个字符是5，N0最后一个字符是0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;E[maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn],inq[maxn],num[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;maxn; i++)&#123;</span><br><span class="line">        E[i].clear();</span><br><span class="line">        inq[i]=<span class="number">0</span>;</span><br><span class="line">        dis[i]=inf;</span><br><span class="line">        num[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    q.push(s);</span><br><span class="line">    inq[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> now=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        inq[now]=<span class="number">0</span>;</span><br><span class="line">        num[now]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;(<span class="keyword">int</span>)E[now].size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> val=E[now][i].second;</span><br><span class="line">            <span class="keyword">int</span> j=E[now][i].first;</span><br><span class="line">            <span class="keyword">if</span>(dis[j]&gt;dis[now]+val)&#123;</span><br><span class="line">                dis[j]=dis[now]+val;</span><br><span class="line">                <span class="keyword">if</span>(!inq[j])&#123;</span><br><span class="line">                    q.push(j);</span><br><span class="line">                    inq[j]=<span class="number">1</span>;</span><br><span class="line">                    num[j]++;</span><br><span class="line">                    <span class="keyword">if</span>(num[j] &gt; n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x,y,z;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">            E[x].push_back(make_pair(y,z));</span><br><span class="line">            <span class="keyword">if</span>(z&gt;=<span class="number">0</span>) E[y].push_back(make_pair(x,z));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(SPFA(<span class="number">1</span>,n)) <span class="built_in">puts</span>(<span class="string">"N0"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"YE5"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一天了解了Dijkstra算法和Floyd两大最短路算法，但是如果图中有负环，那么每次更新就不会对了，那么我们需要另一个特殊的算法SPFA算法。&lt;/p&gt;
    
    </summary>
    
      <category term="day++" scheme="http://yoursite.com/categories/day/"/>
    
    
  </entry>
  
  <entry>
    <title>Day2</title>
    <link href="http://yoursite.com/2020/02/29/Day2/"/>
    <id>http://yoursite.com/2020/02/29/Day2/</id>
    <published>2020-02-29T12:14:30.866Z</published>
    <updated>2020-03-01T08:17:43.210Z</updated>
    
    <content type="html"><![CDATA[<p><del>在要咕的边缘疯狂试探</del>是时候补齐自己的图论知识了——Dijkstra算法和Floyd算法</p><a id="more"></a><p>首先这是一个对于无负权边的图的一个判别方法，如果有负权边那么就要使用另一个算法叫SPFA算法（先不深究）</p><h4 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h4><p>Dijlstra也就是单源最短路算法，能求出某个点到其他所有点的最短路</p><p>首先对于一个空集合，最少要进行$n$次操作，才能把所有点加入集合</p><p>然后对于每次加点，就要循环$n$次找出离集合最近的点，然后再次更新，dis数组</p><p>复杂度：$O(n^2)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//x是原点</span></span><br><span class="line">    <span class="built_in">memset</span>(dis,inf,<span class="keyword">sizeof</span> dis); <span class="comment">//先把dis赋值成一个巨大的数，为不可到达</span></span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis); <span class="comment">//标记数组，vis[i]=0表示i不在集合里面</span></span><br><span class="line">    vis[x]=<span class="number">1</span>;  <span class="comment">//初始集合只有x一个点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) dis[i]=g[x][i]; <span class="comment">//初始化，更新所有离x的点i的距离，放进dis数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123; <span class="comment">// 循环n次</span></span><br><span class="line">        <span class="keyword">int</span> mark=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxdis=-inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j] &amp;&amp; maxdis&gt;dis[j])&#123; <span class="comment">//找出未加入集合的点mark，这个mark点是集合外点中离x最近的</span></span><br><span class="line">                maxdis=dis[j];</span><br><span class="line">                mark=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mark == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        vis[mark]=<span class="number">1</span>;  <span class="comment">//加入集合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[j])</span><br><span class="line">                dis[j]=min(dis[j],dis[mark]+g[mark][j]); <span class="comment">//再次更新dis数组</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="堆优化Dijkstra算法"><a href="#堆优化Dijkstra算法" class="headerlink" title="堆优化Dijkstra算法"></a>堆优化Dijkstra算法</h4><p>万一$n$很大，上面的算法就会力不从心，我们用到c++的优先队列，priority_queue​</p><p>假定我们知道优先队列怎么用<del>（<a href="https://en.cppreference.com/w/cpp/container/priority_queue" target="_blank" rel="noopener">cppreference</a>）</del>，我们可以$logn$的找出集合外中哪个点的dis[i]最小，那么就把复杂度降低到$nlogn$，一般用上面足够了，下面还包含链式前向星的写法，可以学习一波哦</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val,id;</span><br><span class="line">    node(<span class="keyword">int</span> id,<span class="keyword">int</span> val):id(id),val(val) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node &amp;hs)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val&gt;hs.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to,w;</span><br><span class="line">&#125;e[maxm*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn],cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++cnt]=edge&#123;head[u],v,w&#125;;</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[maxn],vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> from)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dis[i]=INF;</span><br><span class="line">        vis[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    priority_queue&lt;node&gt;q;</span><br><span class="line">    q.push(node(from,<span class="number">0</span>));</span><br><span class="line">    dis[from]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> cur=q.top().id;</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis[cur])<span class="keyword">continue</span>;</span><br><span class="line">        vis[cur]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[cur]; i ; i=e[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dis[cur]+e[i].w &lt; dis[v])&#123;</span><br><span class="line">                dis[v]=dis[cur]+e[i].w;</span><br><span class="line">                q.push(node(v,dis[v]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h4><p>单源最短路我们已经解决，如果问你每个点到每个点的最短路呢？就是说我要问任意一点的最短路，那么我们如果用Dijkstra算法，即使用了堆优化也需要$n^3logn$的时间复杂度，Floyd要好那么一点点，只要$n^3$<del>（真的只是一点点）</del></p><p>Floyd的思想很简单，先枚举两个点 $i$ 、$j$点，我再枚举一个$k$点，那么$i$到$j$的最短路，要么通过$k$要么不通过，那么我们取最小值实现局部最优就能使总体最优，代码很简洁</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>其实上面的算法都是贪心的思想，这是基于无负权边的前提下的，这点需要注意，这就是贪心思想的局限性，局部最优无法使整体最优。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;del&gt;在要咕的边缘疯狂试探&lt;/del&gt;是时候补齐自己的图论知识了——Dijkstra算法和Floyd算法&lt;/p&gt;
    
    </summary>
    
      <category term="day++" scheme="http://yoursite.com/categories/day/"/>
    
    
  </entry>
  
  <entry>
    <title>Day1</title>
    <link href="http://yoursite.com/2020/02/28/Day1/"/>
    <id>http://yoursite.com/2020/02/28/Day1/</id>
    <published>2020-02-28T02:50:35.256Z</published>
    <updated>2020-02-28T12:23:19.727Z</updated>
    
    <content type="html"><![CDATA[<p>数论<del>共产党</del>$gcd$，欧拉函数</p><a id="more"></a><h5 id="CF-1295D"><a href="#CF-1295D" class="headerlink" title="CF-1295D"></a><a href="https://codeforces.com/contest/1295/problem/D" target="_blank" rel="noopener">CF-1295D</a></h5><p>题意：</p><p>给定两个整数$a$和$m$，计算使得$gcd(a+x,m)=gcd(a,m) \ (0\le x \le m \ \  1\le a &lt; m \le  10^{10} )$成立的$x$的数量</p><p>题解：</p><p>如果$a\ge b$，$gcd(a,b)=gcd(a-b,b)$</p><p>如果$a+x \ge m$</p><p>那么$gcd(a+x,m)=gcd(a+x-m,m)$</p><p>$a+x-m=(a+x)%m$</p><p>$x’=(a+x)%m \ (0 \le x’ &lt; m)$</p><p>$gcd(x’,m)=gcd(a,m)=d$</p><p>$gcd(\frac{x’}{d},\frac{m}{d})=1$</p><p>答案就是在区间$(0,\frac{m}{d}]$中与$\frac{m}{d}$互质的个数，即$\varphi (\frac{m}{d})$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">phi</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    ll i,rea=n;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">            rea=rea-rea/i;</span><br><span class="line">            <span class="keyword">while</span>(n%i==<span class="number">0</span>)</span><br><span class="line">                n/=i;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>)</span><br><span class="line">        rea=rea-rea/n;</span><br><span class="line">    <span class="keyword">return</span> rea;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll a,m,d;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;a,&amp;m);</span><br><span class="line">    d=__gcd(a,m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,phi(m/d));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T_T=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">clock_t</span> t0=clock();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T_T);</span><br><span class="line">    <span class="keyword">while</span>(T_T--)&#123;</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">clock_t</span> t1=clock();</span><br><span class="line">    <span class="comment">//printf("%.3fms\n",(double)(t1-t0)/CLOCKS_PER_SEC*1000.0);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数论&lt;del&gt;共产党&lt;/del&gt;$gcd$，欧拉函数&lt;/p&gt;
    
    </summary>
    
      <category term="day++" scheme="http://yoursite.com/categories/day/"/>
    
    
  </entry>
  
  <entry>
    <title>软件工程</title>
    <link href="http://yoursite.com/2020/02/27/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/02/27/软件工程/</id>
    <published>2020-02-27T07:47:16.752Z</published>
    <updated>2020-03-11T03:26:11.618Z</updated>
    
    <content type="html"><![CDATA[<p>软件工程笔记</p><a id="more"></a><h1 id="第一章-软件与软件工程的概念"><a href="#第一章-软件与软件工程的概念" class="headerlink" title="第一章 软件与软件工程的概念"></a>第一章 软件与软件工程的概念</h1><h2 id="1-1-软件的概念、特性和分类"><a href="#1-1-软件的概念、特性和分类" class="headerlink" title="1.1 软件的概念、特性和分类"></a>1.1 软件的概念、特性和分类</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>$$<br>软件（与硬件相互依存）<br>\begin{cases}<br>程序：按事先设计的功能和性能要求执行的指令序列<br>\newline<br>数据：使程序能正常操纵信息的数据结构<br>\newline<br>文档：与程序开发、维护和使用有关的图文材料<br>\end{cases}<br>$$</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>形态特性：无形的逻辑实体</p><p>智能特性：复杂的智力产品</p><p>开发特性：软件的开发至今没有完全摆脱手艺的开发方式</p><p>质量特性：目前还没有得到完全没有缺陷的软件产品</p><p>生产特性：无明显制造过程，按需制作</p><p>管理特性：开发管理特性</p><p>环境特性：依赖编译环境</p><p>维护特性：比硬件更加复杂的维护</p><p>废弃特性：没有老化而被废弃的问题，但是存在退化问题</p><p>应用特性：无可取代的地位</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>系统软件：底层软件，服务于其他程序的程序</p><p>应用软件：解决特定业务所需要的独立应用程序</p><p>工程/科学软件：“数值计算”</p><p>嵌入式软件：某个产品中特定功能的软件</p><p>产品线软件：为多个不同用户提供特定功能</p><p>Web/移动应用软件：App</p><p>人工智能软件：智能</p><h2 id="1-2-软件危机与软件工程"><a href="#1-2-软件危机与软件工程" class="headerlink" title="1.2 软件危机与软件工程"></a>1.2 软件危机与软件工程</h2><p>软件危机：计算机软件的开发、运行和维护过程所遇到的一系列严重问题</p><p>主要表现（征兆）：软件发展速度远远滞后于硬件的发展（判断时只需判断是否对该软件有负面反馈）</p><p>原因：开发周期长、成本高、质量差、维护困难</p><h2 id="1-3-软件工程的目标"><a href="#1-3-软件工程的目标" class="headerlink" title="1.3 软件工程的目标"></a>1.3 软件工程的目标</h2><p>运用先进的开发技术和管理方法提高软件的质量和生产率（花更少的代价做最好产品）</p><p>功能性、可靠性、易于使用性、效率、可维护性、可移植性</p><h2 id="1-4-软件生存期"><a href="#1-4-软件生存期" class="headerlink" title="1.4 软件生存期"></a>1.4 软件生存期</h2><p>三时期：软件定义（做什么）—-&gt;软件开发（如何做）—-&gt;运行维护（使软件持久地满足用户的需要）</p><h2 id="1-5-软件工程方法概述"><a href="#1-5-软件工程方法概述" class="headerlink" title="1.5 软件工程方法概述"></a>1.5 软件工程方法概述</h2><p>软件开发全过程中使用的一整套技术方案成为方法学（范型）</p><p>方法学三要素：过程、方法和工具</p><p>传统方法、面向对象方法、面向服务方法、面向数据方法、形式化方法</p><h2 id="1-6-软件工具概述"><a href="#1-6-软件工具概述" class="headerlink" title="1.6 软件工具概述"></a>1.6 软件工具概述</h2><p>支持软件开发过程的工具、支持软件维护过程的工具、支持软件管理过程和支持过程的工具</p><h2 id="1-7-软件工程知识体系及知识域"><a href="#1-7-软件工程知识体系及知识域" class="headerlink" title="1.7 软件工程知识体系及知识域"></a>1.7 软件工程知识体系及知识域</h2><p>四个基础类的知识域：软件工程经济学、计算基础、工程基础和教学基础</p><h2 id="小测验"><a href="#小测验" class="headerlink" title="小测验"></a>小测验</h2><p>1、( <strong>D</strong> ) 下列的叙述中，_ (1)_ 不 是软件危机的征兆。</p><p>A.软件产品往往不满足用户的真实需求</p><p>B.软件产品常常是不可维护的</p><p>C.软件开发成本和进度的估计不准确.</p><p>D.随着软件规模的增大，其复杂性不断增加</p><p>2、( <strong>A</strong> ) 下列的叙述中，(2)_ 不是软件危机发 生的主要原因。</p><p>A.缺乏可视化的开发工具</p><p>B.随着软件规模的增大，其复杂性不断增加</p><p>c.需求说明不充分或存在错误</p><p>D.软件开发过程不规范，缺少方法论和规范的指导</p><p>3、( <strong>A</strong> ) 下面的_ (3)_ 不再是现代软件 工程师关注的问题。</p><p>A.为什么计算机硬件的成本这么高?</p><p>B.为什么软件需要很长时间才能完成?</p><p>c.为什么开发一个软件的成本这么高?</p><p>D.为什么不能在产品发布前去除软件错误?</p><p>4、( <strong>C</strong> )软件会逐渐退化而不会磨损，其原因在于_ (4)_ 。</p><p>A.软件通常暴露在恶劣的环境下</p><p>B.软件错误通常发生在使用之后</p><p>C.不断的变更使组件接口之间引起错误</p><p>D.软件备件很难订购  </p><p>5、( <strong>B</strong> ) 软件工程的基本目标是_ (5)_ 。</p><p>A.消除软件固有的复杂性</p><p>B.开发高质量的软件</p><p>C.努力发挥开发人员的创造性潜能</p><p>D.更好地维护正在使用的软件产品  </p><h1 id="第二章-软件生存期模型"><a href="#第二章-软件生存期模型" class="headerlink" title="第二章 软件生存期模型"></a>第二章 软件生存期模型</h1><h2 id="2-1-瀑布模型"><a href="#2-1-瀑布模型" class="headerlink" title="2.1 瀑布模型"></a>2.1 瀑布模型</h2><p><img src="/images/%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B.jpg" alt="alt"></p><p>1）阶段间具有顺序性和依赖性。其中包含两重含义：</p><p>​        必须等前一阶段的工作完成之后，才能开始后一阶段的工作。</p><p>​        前一阶段的输出文档就是后一阶段的输入文档。</p><p>2）推迟实现的观点。</p><p>​        瀑布模型在编码之前设置了系统分析和系统设计的各个阶段。分析与设计阶段的基本任务规定，在这两个阶段主要考虑目标系统的逻辑模型，不涉及软件的物理实现。</p><p>​        清楚地区分逻辑设计与物理设计，尽可能推迟程序的物理实现，是按照瀑布模型开发软件的一条重要的指导思想。</p><p>3）质量保证的观点。</p><p>​        每个阶段都必须完成规定的文档，没有交出合格的文档就是没有完成该阶段的任务。</p><p>​        每个阶段结束前都要对所完成的文档进行评审，以便及时发现问题，改正错误。</p><p>在实际开发过程中，瀑布模型是带有反馈的，图中实线箭头表示开发过程，虚线箭头表示维护过程。当在后面阶段发现前面阶段的错误时，需要沿图中左侧的反馈线返回前面的阶段，修正前面阶段的产品之后再回来继续完成后面阶段的任务。</p><p><img src="/images/%E5%AE%9E%E9%99%85%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B.jpg" alt="alt"></p><p>瀑布模型的变体：V模型</p><p><img src="/images/V%E6%A8%A1%E5%9E%8B.jpg" alt="alt"></p><p>优点：可强迫开发人员采用规范化的方法、严格地规定了每个阶段必须提交的文档、要求每个阶段交出的所有产品都必须是经过验证（评审）的。</p><p>缺点：由于瀑布模型几乎完全依赖于书面的规格说明，很可能导致最终开发出的软件产品不能真正满足用户的需要。如果需求规格说明与用户需求之间有差异，就会发生这种情况、瀑布模型只适用于项目开始时需求已确定的情况。</p><h2 id="2-2-快速原型模型"><a href="#2-2-快速原型模型" class="headerlink" title="2.2 快速原型模型"></a>2.2 快速原型模型</h2><p>快速原型是快速建立起来的可以在计算机上运行的程序，它所能完成的功能往往是最终产品功能的一个子集。</p><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%9E%8B.jpg" alt="alt"></p><p>优点：</p><p>有助于满足用户的真实需求。</p><p>原型系统已经通过与用户的交互而得到验证，据此产生的规格说明文档能够正确地描述用户需求。</p><p>软件产品的开发基本上是按线性顺序进行。</p><p>因为规格说明文档正确地描述了用户需求，所以在开发过程的后续阶段不会因发现规格说明文档的错误而进行较大的返工。</p><p>开发人员通过建立原型系统已经学到了许多东西，因此，在设计和编码阶段发生错误的可能性比较小，这自然减少了在后续阶段需要改正前面阶段所犯错误的可能性。</p><p>快速原型的本质是“快速”。开发人员应该尽可能快地建造出原型系统，以加速软件开发过程，节约软件开发成本。原型的用途是获知用户的真正需求，一旦需求确定了，原型就可以抛弃，当然也可以在原型的基础上进行开发。</p><h2 id="2-3-增量模型"><a href="#2-3-增量模型" class="headerlink" title="2.3 增量模型"></a>2.3 增量模型</h2><p>使用增量模型开发软件时，把软件产品作为一系列的增量构件来设计、编码、集成和测试。</p><p>如果客户要求你在一个短期很难完成的产品，那么就适合增量模型，先提交一个或几个增量，后续再做补充</p><p>使用增量模型时，第一个增量构件往往实现软件的基本需求，提供最核心的功能。；第二个增量构件提供更完善的编辑和文档生成功能；第三个增量构件实现拼写和语法检查功能；第四个增量构件完成高级的页面排版功能。</p><p><img src="/images/%E5%A2%9E%E9%87%8F%E6%A8%A1%E5%9E%8B.jpg" alt="alt"></p><p>优点：风险低、适用于紧急项目、由于核心功能是最先交付的，后续测试多，故不易失败、制作者有较长时间学习，减少失败风险</p><p>注意：在把每个新的增量构件集成到现有软件体系结构中时，必须不破坏原来已经开发出来的产品；软件体系结构必须是开放的，即向现有产品中加入新构件的过程必须简单、方便。</p><h2 id="2-4-螺旋模型"><a href="#2-4-螺旋模型" class="headerlink" title="2.4 螺旋模型"></a>2.4 螺旋模型</h2><p>螺旋模型最初是Boehm于1988年提出来的。该模型将瀑布模型与快速原型模型结合起来，并且加入两种模型均忽略了的风险分析。螺旋模型的基本思想是，使用原型及其他方法来尽量降低风险。</p><p>理解这种模型的一个简便方法，是把它看作在每个阶段之前都增加了风险分析过程的快速原型模型，如图2-7所示。</p><p><img src="/images/%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B.jpg" alt="alt"></p><p>优点：</p><p>对可选方案和约束条件的强调有利于已有软件的重用，也有助于把软件质量作为软件开发的一个重要目标。</p><p>减少了过多测试或测试不足所带来的风险。</p><p>在螺旋模型中维护只是模型的另一个周期，因而在维护和开发之间并没有本质区别。</p><p>注意：螺旋模型是风险驱动的，因此要求软件开发人员必须具有丰富的风险评估经验和这方面的专门知识。</p><h2 id="2-5-喷泉模型"><a href="#2-5-喷泉模型" class="headerlink" title="2.5 喷泉模型"></a>2.5 喷泉模型</h2><p>喷泉模型是典型面对对象生命周期模型</p><p>“喷泉”一词体现了迭代和无间隙特性。图中代表不同阶段的圆圈相互重叠，这明确表示两个活动之间存在重叠。用面向对象方法开发软件时，在分析、设计和编码等项开发活动之间并不存在明显的边界，而各阶段在表示方法上的一致性也保证了各项开发活动之间的无缝过渡。图中一个阶段内的向下箭头代表该阶段中的迭代或求精。</p><p><img src="/images/%E5%96%B7%E6%B3%89%E6%A8%A1%E5%9E%8B.jpg" alt="alt"></p><h2 id="2-6-统一过程"><a href="#2-6-统一过程" class="headerlink" title="2.6 统一过程"></a>2.6 统一过程</h2><p>统一建模语言UML</p><p>初始阶段 —-&gt; 细化节点 —-&gt; 构造（构建）阶段 —-&gt; 移交阶段</p><p><img src="/images/%E7%BB%9F%E4%B8%80%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B.jpg" alt="alt"></p><h2 id="2-7-基于构件的开发模型"><a href="#2-7-基于构件的开发模型" class="headerlink" title="2.7 基于构件的开发模型"></a>2.7 基于构件的开发模型</h2><p><img src="/images/%E5%9F%BA%E4%BA%8E%E6%9E%84%E4%BB%B6%E7%9A%84%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B.jpg" alt="alt"></p><h2 id="2-8-敏捷过程"><a href="#2-8-敏捷过程" class="headerlink" title="2.8 敏捷过程"></a>2.8 敏捷过程</h2><p>一种较为广泛的敏捷过程—-&gt;极限编程过程</p><p><img src="/images/%E6%9E%81%E9%99%90%E7%BC%96%E7%A8%8B%E8%BF%87%E7%A8%8B.jpg" alt="alt"></p><h2 id="小测试"><a href="#小测试" class="headerlink" title="小测试"></a>小测试</h2><p>  1、( A )某公司要开发一个软件产品，产品的某些需求是明确的，而某些需求则需要进一步细化。由于市场竞争的压力，产品需要尽快上市，则开发该软件产品最不适合采用_ (1)_ 过程模型。</p><p>(1): A.瀑布 B.快速原型 C.增量 D.螺旋</p><p>2、( B ) 某软件公司欲开发-一个基于Web的考勤管理系统。在项目初期,客户对系统的基本功能、表现形式等要求并不明确，在这种情况下，采用_ (2)_ 比较合适。</p><p>(2): A.瀑布模型 B.螺旋模型 C.喷泉模型 D.极限编程</p><p>3 4、( A )（ C ）某开发小组欲为一公司开发一个产品控制软件,监控产品的生产和销售过程,从购买各种材料开始,到产品的加工和销售进行全程跟踪。购买材料的流程、产品的加工过程以及销售过程可能会发生变化。该软件的开发最不适宜采用_ (3)_ 模型，主要是因为这种模型_ (4)_</p><p>(3): A.瀑布 B.快速原型 C.增量 D.喷泉</p><p>(4): A.不能解决风险 B.不能快速提交软件</p><p>C.难以适应变化的需求 D.不能理解用户的需求</p><p>5、( B )新软件项目与过去成功开发过的一个项目类似，但规模更大，此时比较适合使用(5) 进行项目开发设计。</p><p>(5): A.快速原型法B .变换模型</p><p>C.瀑布模型 D.螺旋模型  </p><p> 6、( A ) 某开发小组欲开发一个超大规模软件:使用通信卫星,在订阅者中提供、监视和控制移动电话通信,则最不适宜采用(6) 过程模型。</p><p>(6): A.瀑布 B.快速原型 C.螺旋 D.喷泉</p><p>7 8、( B ) ( A ) 若用户需求不清晰且经常发生变化，但系统规模不太大且不太复杂，则最适宜采用_ (7)_ 过程模型，对于数据处理领域的问题，若系统规模不太大且不太复杂，需求变化也不大，则最适宜采用_ (8)过程模型。</p><p>(7): A.瀑布模型B.螺旋模型C.快速原型D.喷泉模型</p><p>(8): A.瀑布模型 B.螺旋模型 C.快速原型 D.喷泉模型</p><p>9、( A ) 支持面向对象技术的软件过程模型是_ (9)</p><p>(9): A.喷泉模型B .螺旋模型</p><p>C.增量模型</p><p>D.瀑布模型</p><p>10、( C ) 某企业拟开发-个企业信息管理系统，系统功能与多个部门的业务相关。现希望该系统能够尽快投入使用，系统功能可以在使用过程中改善，则最适宜采用的软件过程模型为_ (10)_ 。</p><p>(10): A.瀑布模型 B. 原型模型 C.增量模型 D.螺旋模型  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;软件工程笔记&lt;/p&gt;
    
    </summary>
    
      <category term="课堂笔记" scheme="http://yoursite.com/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>工程经济学</title>
    <link href="http://yoursite.com/2020/02/26/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    <id>http://yoursite.com/2020/02/26/工程经济学/</id>
    <published>2020-02-26T06:36:24.612Z</published>
    <updated>2020-03-19T09:52:08.892Z</updated>
    
    <content type="html"><![CDATA[<p>工程经济学笔记</p><a id="more"></a><hr><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>企业的目的：赚钱、全社会范围内利益团体价值最大化</p><p>工程-经济系统：资金投入（投资）—&gt;工程准备阶段的经济性（工程）—&gt;产品卖出（经济）【社会环境产生巨大的影响，是社会环境的很小的系统】</p><pre class="mermaid">graph LR    A[投资] --> B[工程]    B --> C[经济]    C --> A</pre><p>如何有效达成投资的目的：<strong>前期做好论证、评估、选择（工程经济的使命）</strong> ,中期做好监管；后期做好运营</p><p>工程经济学的概念：工程经济学是研究工程与经济相结合的发展规律的学科，<strong>以工程经济关系为起点</strong>，<strong>以工程-经济系统为客体</strong>，以实现工程中资源的合理配置和有效使用，<strong>提高工程有效性为目的</strong>。</p><p>工程师最基本的责任：分析成本，以达到真正的经济性，即赢得最大可能数量的货币，获得最佳财务效率</p><p>发展：1930年格兰特，以复利计算为基础，讨论判别因子（影响因素）和短期投资评价的重要性</p><p>工程经济分析的原则：</p><ol><li><p>经济效益原则（核心）：经济效益是一个比较的概念</p><p>绝对量的比较：净效益=效益-耗费</p><p>相对量的比较：（净）效益耗费比=（净）效益/耗费</p><p>效益分为有形和无形；直接和相关；宏观和微观等</p></li><li><p>可持续发展原则：首先要注意资源的可持续利用；其次应该注意项目和生态-社会系统的协调与优化；再次要在长远和全局角度来分析问题、研究问题。</p></li><li><p>资源合理配置和有效使用原则</p></li><li><p>可比性原则：需求、价格、时间可比</p></li><li><p>“有无对比”原则：分别对有项目和五项目两种状态进行对比</p></li><li><p>定量分析和定性分析相结合定量为主原则：以定量分析为重点</p></li><li><p>静态评价与动态评价相结合动态评价为主原则</p></li><li><p>利益和风险权衡原则</p></li></ol><p>边际收益：是指增加一单位产品的销售所增加的收益，即最后一单位产品的售出所取得的收益</p><p>资源的合理配置 具体举措有哪些：</p><p>工程-经济系统，工程经济与环境，工程经济学概念，工程经济学发展史，工程经济学方法和原则，课程思政重点</p><hr><h1 id="资金的时间价值与现金流量"><a href="#资金的时间价值与现金流量" class="headerlink" title="资金的时间价值与现金流量"></a>资金的时间价值与现金流量</h1><p>社会生产再生产过程（类似工程-经济系统）</p><p>资金时间价值的影响因素：时间、本金、利率</p><p>边际收益就是指一个增加资金而使收益减少的一个点，相当于导数为0</p><p>社会资金时间价值(率)=边际项目的边际受益</p><p>资金时间价值（率）=资金的机会成本（选择$A$放弃其他方案而带来的损失的成本）+投资风险率+通货膨胀率</p><p>单利：$F=P * (1+n * i)$</p><p>复利：$F=P * (1+i)^n$</p><p>现金是价值风险最小的一种资产</p><p>现金流入和流出主要的鉴别依据是：目标价值政策</p><p>​    在微观层面，主要对于个人或企业，如果是亏损就是流出，否则为流入<br>​    在宏观层面，主要对于国家层面，如果对于社会福利做出正贡献，则是流入，否则是流出</p><p>​        税金在微观属于现金流出，宏观属于现金流入</p><p>NCF 净现金流量图三要素：<strong>大小、流向、时点</strong></p><p>​    坐标轴以上就是增加的钱，坐标轴以下就是减少的钱</p><p>在工程经济分析实务中，一般认为：建设项目的<strong>投资活动</strong>现金流发生在<strong>期初</strong>，建设项目的<strong>生产活动</strong>现金流发生在<strong>期末</strong><br>建设项目的计算期一般以其<strong>经济寿命期</strong>计算</p><p>由于资金时间价值的客观存在，存在于不同时点 的两笔或多笔绝对值不相等的现金流，当其具有 相同的经济价值时，称之为<strong>资金等值</strong>。最为明显的例子就是向银行存钱，最初的本金和取出来的钱为资金等值</p><p>将现金流由一种时点分布换算为另一种时点分布 的过程称之为资金的<strong>等值换算</strong></p><p>影响资金等值的因素有：资金的数额、资金发生的时点、期利率</p><p>现值$P$：建设初期0时坐标轴以上的资金价值</p><p>终值$F$：计算期期末的资金价值</p><p>年金$A$：连续地发生在每年年末且绝对数值相等的现金流序列</p><p><strong>六大公式</strong></p><p>1、一次支付终值公式</p><p>​        已知$P,i,n$，求$F$<br>$$<br>F=P * (1+i)^n=P(F/P,i,n)<br>$$<br>2、一次支付现值公式</p><p>​        已知$F,i,n$，求$P$<br>$$<br>P=F * (1+i)^{-n}=F(P/F,i,n)<br>$$<br>3、年金终值公式</p><p>​        已知$A,i,n$，求$F$</p><p>​        每次所产生的利息就是$A*(1+i)^{n-1}$<br>$$<br>F=\sum_{j=0}^{n}{A * (1+i)^{j-1}}=\frac{A * [(1+i)^n-1]}{i}=A(F/A,i,n)<br>$$<br>4、偿债基金公式</p><p>​        已知$F,i,n$，求$A$</p><p>​<br>$$<br>A=\frac{F * i}{(1+i)^n-1}=F(A/F,i,n)<br>$$<br>5、年金现值公式</p><p>​        已知$A,i,n$，求$P$</p><p>​        由于上面两个$F$的公式，联立得<br>$$<br>P * (1+i)^n= \frac{A * [(1+i)^n-1]}{i}<br>$$</p><p>$$<br>P=\frac{A * [(1+i)^n-1]}{i * (1+i)^n}=A(P/A,i,n)<br>$$<br>​        例题：小A从建设银行贷款60万付首套房按揭，贷款利率为4.9%，按年计息，贷款15年，等额本息还款，试计算每年应还银行本金，利息分别是多少。<br>$$<br>F=P(F/P,i,n)=P * (1+i)^n = 60 * (1+0.049)^{10} = 122.97(万元)<br>$$</p><p>$$<br>F=A(F/A,i,n)=\frac{A * [(1+i)^n-1]}{i}<br>$$</p><p>联立上两式，可以得到$A$<br>$$<br>A=\frac{F * i}{(1+i)^n-1}=\frac{122.97 * 0.049}{1.049^{10}-1}=5.74(万元)<br>$$<br>第一年利息：$60 * 0.049=2.94(万元)$</p><p>第一年本金：$5.74-2.94=2.80(万元)$</p><p>第二年利息：$(60-2.80) * 0.049 = 2.80(万元)$</p><p>第二年本金：$5.74-2.80=2.94(万元)$</p><p>第三年利息：$(60-2.80-2.94) * 0.049 = 2.66(万元)$</p><p>第三年本金：$5.74-2.66=3.08(万元)$</p><p>…</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> F,A,i,P;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"请输入贷款金额,利率,年份:(单位:万元)"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lf %lf %d"</span>,&amp;P,&amp;i,&amp;n);</span><br><span class="line">    <span class="keyword">double</span> tmp=<span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++) tmp*=(<span class="number">1.0</span>+i);</span><br><span class="line">    F=P*tmp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"F=%.6f(万元)\n"</span>,F);</span><br><span class="line">    A=F*i/(tmp<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"A=%.6f(万元)\n"</span>,A);</span><br><span class="line">    <span class="keyword">double</span> pre=P;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)&#123;</span><br><span class="line">        <span class="keyword">double</span> l=pre*i;</span><br><span class="line">        <span class="keyword">double</span> x=A-l;</span><br><span class="line">        pre-=x;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"第%d年利息:%.6f(万元)\t第%d年本金:%.6f(万元)\n"</span>,j,l,j,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、资金回收公式</p><p>​        已知$P,i,n$，求$A$<br>$$<br>A=\frac {P * i * (1+i)^n} {(1+i)^n-1} =A(A/P,i,n)<br>$$</p><p>例题：某人计划用购房的方式解决住房问 题。房价50万元。某人只有12万元资金，余款需贷款解决，贷款年利率4%，在未来10年内等额偿还。若基准折现率为5% ，问某人购房总支出相当于现在一次性付款多少？</p><p>解：首先我们可以求出每年所还的钱</p><p>​<br>$$<br>A=\frac{F * i} {(1+i)^n-1} = 4.685<br>$$</p><p>$$<br>S = 12 * (1+0.05)^{10} + \sum_{j=0}^{n-1}A*(1+i)^j = 75.796  \ \<br>$$</p><p>$$<br>P=\frac{S}{(1+0.05)^{10}} = 46.53<br>$$</p><p>​            相当于12w以5%增值，每年的$A$按4%增值，到最后变成$S$，最后通过$S$返回求$P$</p><p><strong>永久年金</strong><br>$$<br>P = \lim_{n \to \infty} \frac{A * [(1+i)^n-1]}{i * (1+i)^n} = \frac{A}{i}<br>$$<br><strong>名义利率与实际利率</strong></p><p>年利率为$r$，一年计息$m$次，当$m \neq 1$时，称$r$为名义利率。</p><p>实际利率即实际上以年为计息周期的利率。</p><p>假设名义利率为$r$，每年计息$m$次，则实际利率$i$<br>$$<br>i=(1+\frac{r}{m})^m-1<br>$$<br>广义年金：连续分布在每期期末，且绝对数值相等的序列。</p><hr><h1 id="建设项目评价的基本经济要素"><a href="#建设项目评价的基本经济要素" class="headerlink" title="建设项目评价的基本经济要素"></a>建设项目评价的基本经济要素</h1><p>投资反映了项目对生产力要素的占用。</p><p>$$<br>固定资产原值=固定资产净值+固定资产折旧<br>$$</p><p>$$<br>流动资金 = 流动资产 - 流动负债<br>$$</p><p>流动资金是项目投产运营后，为维持项目正常生产运营所占用的全部周转资金，它是在生产期内位来保持生产经营的永续性和连续状态而垫付的资金，<strong>流动资金在生产经营期间被项目长期占用，在项目终了时被全额回收</strong><br>$$<br>某年应计利息 = （年初借款资金累计 + \frac{当年借款}{2}）\times  借款年利率<br>$$<br><strong>建设期利息即资本化利息，仅发生在建设期</strong></p><p>折旧（摊销）是固定（其他）资产价值磨损的补偿金。</p><p>建设项目总投资</p><pre class="mermaid">graph LR    A(建设项目总投资) --> B(建设投资)    A --> C(建设期利息)    A --> D(流动资金)    B --> E(工程费用)    B --> F(预备费用)    B --> G(其他费用)    E --> H(固定资产)    F --> H    G --> H    C --> H    G --> I(其它资产)    D --> J(流动资产)</pre><p>成本：为了获得未来受益而付出的代价</p><p>成本反映了项目对劳动的消耗</p><p>$经营成本 = 总成本－折旧、摊销费－财务费用$</p><p>$经营成本 = 外购原材料、燃料、动力费+工资及福利费+修理费+其他费用$</p><p>经营成本是现金流概念下的成本，所以，非现金支出的项目不包含在经营成本中</p><p>例：某项目使用1000万元建设投资（含其他资产200万元）进行建设。其中，借款300万元。借款利率为8%。利息照付，本金从第三年开始还，3年内等额偿还。固定资产净残值率2%， 其他资产无残值，均5年内线性折旧和摊销。 求年总成本。</p><table><thead><tr><th><strong>年    份</strong></th><th>1</th><th><strong>2</strong></th><th><strong>3</strong></th><th><strong>4</strong></th><th><strong>5</strong></th><th><strong>6</strong></th><th><strong>7</strong></th></tr></thead><tbody><tr><td><strong>建设投资</strong></td><td><strong>800</strong></td><td><strong>200</strong></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>贷款</strong></td><td><strong>300</strong></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>经营成本</strong></td><td></td><td></td><td><strong>100</strong></td><td><strong>140</strong></td><td><strong>140</strong></td><td><strong>140</strong></td><td><strong>140</strong></td></tr></tbody></table><p>解：这道题由于是利息照付，就是按单利来计算，不存在复利。</p><p>​        第一年利息：$(0 + \frac{300}{2}) * 0.08 = 12$</p><p>​        第二年利息：$(300 + \frac{0}{2}) * 0.08 = 24$</p><p>​        由于是利息照付，当年就把利息算完了，利息就是300w所产生的。</p><p>​        固定资产原值=固定资产投资+建设期利息=(1000-200)+12+24=836</p><p>​        固定资产残值=836*2%=16.72    </p><p>​        固定资产年折旧额=(原值-残值)/年限=(836-16.72)/5=163.86</p><p>​        其他资产摊销=原值/年限=200/5=40</p><p>​        财务费用： 第三年=300*8%=24</p><p>​                            第四年=200*8%=16</p><p>​                            第五年=100*8%=8</p><p>​        （这里不需要计算第三年到第五年的偿还的本金的钱）</p><table><thead><tr><th>年份</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td><strong>经营成本</strong></td><td></td><td></td><td>100</td><td>140</td><td>140</td><td>140</td><td>140</td></tr><tr><td><strong>折旧</strong></td><td></td><td></td><td>163.86</td><td>163.86</td><td>163.86</td><td>163.86</td><td>163.86</td></tr><tr><td><strong>摊销</strong></td><td></td><td></td><td>40</td><td>40</td><td>40</td><td>40</td><td>40</td></tr><tr><td><strong>财务费用</strong></td><td></td><td></td><td>24</td><td>16</td><td>8</td><td></td><td></td></tr><tr><td><strong>总成本</strong></td><td></td><td></td><td>327.86</td><td>359.86</td><td>351.86</td><td>343.86</td><td>343.86</td></tr></tbody></table><p>机会成本：在决策过程中，因选择某一方案而放弃另外的方案所付出的代价</p><p>沉没成本：发生在决策之前，与决策问题无关的费用</p><p>变动成本：其大小与工作量成正比例变化的成本要素</p><p>固定成本：其大小与工作量无关的成本要素</p><p>税收：国家为了实现其职能，凭借政治权利参与国民收入分配和再分配，无偿取得财政收入的形式，具有强制性、无偿性、固定性。</p><p>关税：以进出口的应税货物为纳税对象的税种， 在应税货物进口、出口或过境环节征收。用关税率即可计算。</p><p>增值税：以应税产品所增加的价值</p><p>增值税额 = 销项税额－进项税额 = 销售额（不含税）× 增值税率 - 进项额（不含税）× 增值税率</p><p>注意：一般题目出现的收的钱都是含税的，所以我们应该先除以(1+增值税率)，算出不含税的价格</p><p>个人所得税：纳税人每一纳税年度的营业总额扣减准予扣除的与纳税人取得利润有关的成本、费用、税金和损失后的余额</p><p>影子价格：市场的资源配置达到合理配置时的价格，也成为最优计划价格</p><p>一般来说，当进行国民经济评价时，采用影子价格，当对项目进行财务评价时，采用现行市场价格</p><p><strong>基价、时价和实价</strong></p><p>基价是基年的绝对价格，指以基年价格水平表示的不变价格</p><p>时价是指某时点的市场价格，包含了相对价格变动和绝对价格变动的影响。</p><p>$P_{cn} = P_b(1+c_1)(1+c_2) … (1+c_n)$ $P_b$基价，$c_j$第$j$年的时价变动率，$c_j$取决于市场相对价格变动（实价变动）和物价总水平变动（绝对价格变动）</p><p>实价是指以基价水平表示的，只考虑相对价格变动因素影响的价格</p><p>$P_{rn} = \frac{P_{cn}}{(1+f_n)}$ $P_{rn}$第$n$年的实价，$f_n$物价总水平变动率</p><p>$$<br>P_{rn} = P_b (1+实价变动率)<br>$$<br>在进行财务盈利能力分析时，我们采用实价，以消除通货膨胀的影响，但是在进行财务清偿能力分析时，我们则需使用时价，以反映通货膨胀的影响</p><p>利润：反映劳动净成果的效益类指标，包括营业 利润、投资净收益以及营业外收支净额。</p><p>营业利润=营业收入－总成本－营业税及附加</p><p>投资净收益是投资收益扣除投资损失后的余额。</p><p>营业外收支净额指营业外收入减去营业外支出后的数额。</p><p>利润总额＝营业利润＋投资净收益＋营业外收支净额</p><p>净利润＝利润总额－所得税</p><hr><h1 id="经济评价指标体系"><a href="#经济评价指标体系" class="headerlink" title="经济评价指标体系"></a>经济评价指标体系</h1><p><strong>投资回收期${P_t}$</strong></p><p>从项目投资开始算起，用产出的受益全部收回所需要的时间长度，单位为年。<br>$$<br>\sum_{t=0}^{P_t} (CI-CO)_t = 0<br>$$<br>$P_t$ 投资回收期；$(CI-CO)_t$第$t$年的净现金流量$NCF$<br>$$<br>P_t = T-1 + \frac{第(T-1)年净现金流累计值的绝对值}{第T年的现金流<br>}<br>$$<br>$T$ 累积净现金流量首次为非负值所对应的年份</p><p>上面为静态的计算方法，即不考虑利率变化</p><p>实际情况我们可能需要计算动态的投资回收期，即用现金折现率求未来的钱现在为多少，$P = NCF_n * (1+i)^{-n}$，然后再按照公式计算。</p><p>优点：概念明确，简单易算；既反映方案的盈利性又反映方案的风险</p><p>缺点：只反映投资回收前的盈利情况，不够全面。</p><p><strong>净现值${NPV}$</strong></p><p>建设项目在整个寿命期内，各年的净现金流按既定的折现率折算到计算期初的现值之和</p><p>净现值是考察建设项目在其计算期内盈利能力的主要动态评价指标<br>$$<br>NPV = \sum_{t=0}^{n} {NCF_t(P/F,ic,t)} = \sum_{t=0}^{n} {NCF_t* (1+ic)^{-t}}<br>$$<br>当$NPV \geq 0$时，说明经济可行性为合理的，反之不可行。</p><p><strong>内部收益率${IRR}$</strong></p><p>得项目计算期内各年净现金流量的现值累计值，即净现值等于零时的折现率<br>$$<br>\sum_{t=0}^{n} NCF_t(1+IRR)^{-t} = 0<br>$$<br>线性内插法求解内部收益率</p><p><img src="/images/%E7%BA%BF%E6%80%A7%E5%86%85%E6%8F%92%E6%B3%95%E6%B1%82%E8%A7%A3IRR.jpg" alt="alt"><br>$$<br>IRR = i_1 + \frac{NPV_1}{NPV_1+|NPV_2|} * (i_2 - i_1)<br>$$<br>为保证计算的精度，一般要求$i_2 - i_1 &lt;$ 5%</p><p>经济意义：方案存在于项目中的投资（未被回收的投资）可以实现的盈利（收益）能力</p><p>$IRR$经济可行性的评价标准为$IRR \geq ic$，$ic$为社会折现率</p><p>一般地，当建设项目在计算期的净现金流 符号变化不超过一次时（所谓常规建设项 目），净现值方程有唯一的实数解，即方案的内部收益率。</p><p><strong>投资收益率$ROI$</strong></p><p>单位总投资能实现的息税前利润，即$ROI = \frac{EBIT}{TI}$</p><p>$EBIT$：息税前利润     $TI$：投资总额</p><p>$EBIT$=毛（净）利润+所得税税金（+还的利息）</p><p>反映全部投资（存在于项目中的投资与已收回投资之和）收益能力的静态指标</p><p><strong>资本金利润率$ROE$</strong></p><p>单位资本金可以实现的净利润，即$ROE = \frac{NP}{EC} = \frac{年净利润}{项目资本金}$</p><p><strong>利息备付率$ICR$</strong></p><p>利息备付率也称已获利息倍数，是指项目在借款偿还期内各年可用于支付利息的息税前利润与当期应付利息费用的比值，即$ICR = \frac{EBIT}{PI}$</p><p>$PI$：计入成本的应付利息。注意：建设期的利息最后是折算到固定资产中去了，$PI$应该是运营期还的利息</p><p>利息备付率从付息资金来源的充裕性角度反映项 目偿付债务利息的保障程度。一般来说，利息备付率应大于$2$</p><p><strong>偿债备付率$DSCR$</strong></p><p>偿债备付率是指借款偿还期内，各年可用于还本付息的资金与当年应还本付息额的比值。即</p><p>$DSCR = \frac{(EBITAD - TAX)}{PD}$</p><p>$EBITAD$：息税折旧摊销前利润</p><p>$EBITAD = EBIT + 折旧 + 摊销$</p><p>$TAX$：企业所得税额</p><p>$PD$：应还本付息金额</p><p>偿债备付率表示用于还本付息的资金偿还债务资金本息 的保障程度，理论上讲，偿债备付率应大于$1$</p><p>例题：某项目2006年利润总额200万元，所得税率25% ，当年在成本中列支的利息67万元，折旧、摊销20万元，还借款本金80万元。计算该项目当年的利息备付率、偿债备付率</p><p>$EBIT = 200+67 = 267w$</p><p>$ICR = \frac{EBIT}{PI} = \frac{267}{67} = 3.99$</p><p>$EBITAD = EBIT + 折旧 + 摊销 = 267+20 = 287w$</p><p>$DSCR = \frac {(EBITAD - TAX) }{PD} = \frac{287-200 * 25 \% }{80+67} = 1.61$</p><hr><h1 id="多方案比较选择"><a href="#多方案比较选择" class="headerlink" title="多方案比较选择"></a>多方案比较选择</h1><p><strong>方案之间的相互关系</strong></p><ul><li>独立方案：方案各自独立存在，不受其他方案的任何状态影响</li><li>互斥方案：互相排斥不可兼容的方案</li><li>依存方案：方案之间相互依存，互为续存条件</li><li>资金约束条件下的相关方案：独立方案的一种特例，受到资金的约束</li><li>混合方案</li></ul><p><strong>互斥方案的检验</strong></p><ul><li>合格性检验：备选方案的绝对经济效益检验，考察方案的经济可行性</li><li>最优性检验：可行方案的相对经济效益检验，对可行方案进行经济性排序，提示优选目标</li><li>以上两种方案缺一不可</li></ul><p><strong>寿命相等的互斥方案经济性比选</strong></p><ul><li><p>合格性检验（绝对效益检验） $NPV \geq 0$</p></li><li><p>最优性检验（相对效益检验）</p><p>定义投资小的方案为基础方案$B$；投资次小的方案为相对方案$A$</p><p>若$\Delta_{A-B} NPV \geq 0$，则相对方案优；否则，基础方案优</p></li></ul><p><strong>内部收益率法</strong></p><ul><li><p>合格性检验 $IRR \geq i_c$</p></li><li><p>最优性检验 </p><p>若$\Delta _{A-B} IRR \geq i_c$，则相对方案优；否则，基础方案优</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工程经济学笔记&lt;/p&gt;
    
    </summary>
    
      <category term="课堂笔记" scheme="http://yoursite.com/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>人工智能</title>
    <link href="http://yoursite.com/2020/02/26/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    <id>http://yoursite.com/2020/02/26/人工智能/</id>
    <published>2020-02-26T06:36:24.557Z</published>
    <updated>2020-03-14T14:38:34.279Z</updated>
    
    <content type="html"><![CDATA[<p>人工智能学习笔记</p><a id="more"></a><h1 id="第一讲-人工智能概述"><a href="#第一讲-人工智能概述" class="headerlink" title="第一讲 人工智能概述"></a>第一讲 人工智能概述</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>1956年正式提出，被誉为20世纪三大科学技术成就（空间技术、原子能技术、人工智能技术）</p><h2 id="1-2-人工智能的概念"><a href="#1-2-人工智能的概念" class="headerlink" title="1.2 人工智能的概念"></a>1.2 人工智能的概念</h2><p>对于智能到现在为止暂时没有一个准确的定义，只有一些主要流派。计算机人工智能暂时定义为<strong>智能是知识与智力的总和</strong>。</p><p>智能的特征：</p><p>1、感知能力（感知外部世界的能力，主要是视觉和听觉）</p><p>2、记忆与思维能力（存储与对于记忆信息的处理）</p><p>3、学习能力（分自主和无意识的学习）</p><p>4、行为能力（对于信息的输出）</p><h2 id="1-3-人工智能的发展简史"><a href="#1-3-人工智能的发展简史" class="headerlink" title="1.3 人工智能的发展简史"></a>1.3 人工智能的发展简史</h2><p>提出(-1956年)-&gt;形成(1956-1969)-&gt;发展(1970-)</p><h2 id="1-4-人工智能研究的基本内容"><a href="#1-4-人工智能研究的基本内容" class="headerlink" title="1.4 人工智能研究的基本内容"></a>1.4 人工智能研究的基本内容</h2><p>机器学习：监督学习、强化学习、非监督学习</p><h1 id="第二讲-一阶谓词逻辑知识表示法"><a href="#第二讲-一阶谓词逻辑知识表示法" class="headerlink" title="第二讲 一阶谓词逻辑知识表示法"></a>第二讲 一阶谓词逻辑知识表示法</h1><h2 id="2-1-命题逻辑"><a href="#2-1-命题逻辑" class="headerlink" title="2.1 命题逻辑"></a>2.1 命题逻辑</h2><p>$$<br>逻辑<br>\begin{cases}<br>经典逻辑(二值逻辑)<br>\begin{cases}<br>经典命题逻辑<br>\newline<br>一阶谓词逻辑<br>\end{cases}<br>\newline<br>非经典逻辑<br>\begin{cases}<br>三值逻辑<br>\newline<br>多值逻辑<br>\newline<br>模糊逻辑<br>\end{cases}<br>\end{cases}<br>$$</p><p>命题：一个<strong>非真即假</strong>的<strong>陈述句</strong></p><h2 id="2-2-谓词逻辑"><a href="#2-2-谓词逻辑" class="headerlink" title="2.2 谓词逻辑"></a>2.2 谓词逻辑</h2><p> 谓词</p><p>一般形式：$P(X_1,X_2,…,X_N)$</p><p>个体$P(X_1,X_2,…,X_N)$：某个独立存在的事物或者某个抽象的概念。</p><p>谓词名$P$：刻画个体的性质、状态或个体间的关系。</p><p>个体是一个常量；一个或者一组指定的个体，一元谓词、二元谓词…</p><p>个体也可以是一个变量；此时真假可能不确定</p><p>个体还可以是函数；一个个体到另一个个体的映射</p><p>个体可以是谓词；二阶谓词等</p><p> 谓词公式</p><p>非($\neg $)；或($\vee$)；与($\wedge$)；蕴含，表如果…那么…($\rightarrow $)；等价($\leftrightarrow$)</p><p>谓词逻辑真值表<del>(或且非就不列了)</del></p><table><thead><tr><th align="center">$P$</th><th align="center">$Q$</th><th align="center">$P \rightarrow Q$ （真假即假）</th><th align="center">$P \leftrightarrow Q$ （相当于同或）</th></tr></thead><tbody><tr><td align="center">$T$</td><td align="center">$T$</td><td align="center">$T$</td><td align="center">$T$</td></tr><tr><td align="center">$T$</td><td align="center">$F$</td><td align="center">$F$</td><td align="center">$F$</td></tr><tr><td align="center">$F$</td><td align="center">$T$</td><td align="center">$T$</td><td align="center">$F$</td></tr><tr><td align="center">$F$</td><td align="center">$F$</td><td align="center">$T$</td><td align="center">$T$</td></tr></tbody></table><p>全称量词$\forall$；存在量词$\exists$</p><p>全称量词和存在量词的次序可能会影响命题的真假性</p><p>连接词的优先级从高到低($\neg \ &gt;\ \wedge \ &gt;\  \vee \  &gt; \ \rightarrow \  &gt; \ \leftrightarrow $)</p><p>量词的辖域：位于两次后面的单个谓词或者用括弧括起来的谓词公式（一般用全称量词和存在量词表示）</p><p>约束变量与自由变元：辖域内的变量就是约束变元，其他就是自由变元，但是这个是相对的。</p><p> 谓词公式的性质</p><p>假言推理：$P, P \rightarrow Q \Rightarrow Q$</p><p>拒取式推理：$\neg Q , P \rightarrow Q \Rightarrow \neg P$</p><p>假言三段论：$A \rightarrow B , B \rightarrow C \Rightarrow A \rightarrow C$</p><p>反证法：正难则反</p><h2 id="2-3-一阶谓词逻辑知识表示法"><a href="#2-3-一阶谓词逻辑知识表示法" class="headerlink" title="2.3 一阶谓词逻辑知识表示法"></a>2.3 一阶谓词逻辑知识表示法</h2><p> 一阶谓词逻辑知识表示法</p><p>1、定义谓词及个体</p><p>2、变元赋值</p><p>3、用连接词连接各个谓词，形成谓词公式</p><p> 一阶谓词逻辑知识表示法特点</p><p>优点：自然性；精确性；严密性；容易实现</p><p>缺点：不能表示不确定的知识；组合爆炸；效率低</p><p>应用：自动问答系统；机器人行动规划系统；机器博弈系统；问题求解系统</p><h1 id="第三讲-产生式表示法和框架表示法"><a href="#第三讲-产生式表示法和框架表示法" class="headerlink" title="第三讲 产生式表示法和框架表示法"></a>第三讲 产生式表示法和框架表示法</h1><h2 id="3-1-产生式表示法"><a href="#3-1-产生式表示法" class="headerlink" title="3.1 产生式表示法"></a>3.1 产生式表示法</h2><p>确定性规则知识产生式表示、不确定性规则知识产生式表示（加上置信度）、确定性事实性知识的产生式表示（三元组表示）、不确定性事实性知识的产生式表示（在前面的基础上机上置信度）</p><p>产生式与崔此逻辑中蕴含式的区别</p><p>1、产生式除了能表示蕴含，还可以表示操作规则、变换、函数等</p><p>2、蕴含只能表达精确的知识（非真即假），而产生式还能表示“可能”</p><p>巴克斯范式$BNF$：定义描述，$::=$表示定义为，$|$表示或，$[]$表示可缺省</p><pre class="mermaid">graph LR    A[控制] --> B[规则库]    A --> C[推理机]    A --> D[综合数据库]    B --> C    D --> C    C --> D</pre><p>规则库：用于描述相应领域内知识的产生式集合。<br>综合数据库（事实库、上下文、黑板等）：一个用于存放问题求解过程中各种当前信息的数据结构。<br>控制系统（推理机构）：由一组程序组成，负责整个产生式系统的运行，实现对问题的求解。</p><p>产生式优点：自然性、模块性、有效性、清晰性</p><p>缺点：效率不高、不能表达结构性知识</p><p>适用场合：1、领域知识间关系不密切，不存在结构关系。2、经验性及不确定性的知识，且相关领域中对这些知识 没有严格、统一的理论。3、领域问题的求解过程可被表示为一系列相对独立的操作，且每个操作可被表示为一条或多条产生式规则。</p><h2 id="3-2-框架表示法"><a href="#3-2-框架表示法" class="headerlink" title="3.2 框架表示法"></a>3.2 框架表示法</h2><p>框架(frame)：一种描述所论对象属性的数据结构，一个框架由若干个“槽”的结构组成，每个槽又可根据实际情况分成若干个“侧面”。</p><p>槽(slot)：用于描述所论对象某一方面的属性</p><p>侧面(faced)：描述相应属性的某一方面（细分下的细分）</p><p>结构：</p><p><img src="/images/%E6%A1%86%E6%9E%B6%E7%BB%93%E6%9E%84.jpg" alt="alt"></p><p>特点：结构性、继承性、自然性、便于表达结构性的知识</p><h1 id="第四讲-基于谓词逻辑的推理方法"><a href="#第四讲-基于谓词逻辑的推理方法" class="headerlink" title="第四讲 基于谓词逻辑的推理方法"></a>第四讲 基于谓词逻辑的推理方法</h1><h2 id="归结演绎推理"><a href="#归结演绎推理" class="headerlink" title="归结演绎推理"></a>归结演绎推理</h2><p>反证法：$P \Rightarrow Q$，当且仅当$P \wedge \neg Q \Leftrightarrow F$，即$Q$为$P$的逻辑结论，当且仅当$P \wedge \neg Q$为假。</p><p><strong>谓词公式转变为子句集</strong></p><p>原子(atom)谓词公式：一个不能再分解的命题</p><p>文字：原子谓词公式及其否定</p><p>$P$：正文字；$\neg P$：负文字</p><p>子句：任何文字的析取式。任何文字本身也都是子句</p><p>空子句：不包含任何文字的子句，空子句是永假的</p><p>$A \rightarrow B$可化为$A \wedge \neg B$</p><p>$A \leftrightarrow B$可化为$( A \wedge B ) \vee ( \neg A \wedge \neg B )$</p><p>德摩根律（略）</p><p><strong>消去存在量词</strong></p><p>存在量词不出现在全称量词的辖域内；存在量词出现在一个或者多个全称量词的辖域内。</p><p><code>Skolem化</code>：用Skolem函数代替存在变量</p><p>$( \forall x_1)(( \forall x_2)…( \forall x_n)( \exists y)P(x_1,x_2,…,x_n,y)))$，存在量词$y$的Skolem函数为$y=f(x_1,x_2,…,x_n)$</p><p>化为前束形：前束形=(前缀){母式}，把量词约束提前</p><p>Skolem标准型（分配律）</p><p>$P \vee (Q \wedge R) \Leftrightarrow (P \vee Q) \wedge (P \vee R)$</p><p>$P \wedge (Q \vee R) \Leftrightarrow (P \wedge Q) \vee (P \wedge R)$</p><p>略去全称量词</p><p>消去合取词</p><p>子句变量标准化（每个子句变量不同）</p><p>谓词公式和子句集是否等价？</p><p>答：谓词公式和子句集不总是等价的，在谓词公式不可满足的条件下等价。在基于谓词逻辑的推理中，特别是归结推理中，把谓词公式转化为子句集是必要的。</p><h2 id="鲁宾逊归结原理"><a href="#鲁宾逊归结原理" class="headerlink" title="鲁宾逊归结原理"></a>鲁宾逊归结原理</h2><p>子句集中子句之间都必须是合取关系</p><p>基本思想：首先检查$S$是否含空语句，若含则$S$不满足，否则去找子句进行归结，一旦出现空子句，那么$S$不满足</p><p>归结：$C_1 ( \neg Q \vee P ), C_2 ( Q \vee R ) $可以化成$C_{12} ( P \vee R ) $</p><p>如果$C_1,C_2$为真，则$C_{12}$为真</p><p>若将$C_{12}$替换$C_1,C_2$得到$S_1$，与原来的$S_0$比较，$S_1$的不可满足性$\Rightarrow$ $S_0$的不可满足性</p><p>若将$C_{12}$加入$S_0$得到$S_2$，则$S_2$的不可满足性$\Leftrightarrow$ $S_0$的不可满足性</p><p>$C_1 = P(x) \vee Q(a),C_2 = \neg P(b) \vee R(x)$</p><p>令$C_2 =\neg P(b) \vee R(y)$，不同子句变量标准化</p><p>$L_1 = P(x),L_2=\neg P(b)$，则$\sigma = $ { $ b/x $ }</p><p>$C_{12} = Q(a) \vee R(y)$</p><p><strong>值得注意的是</strong>，当归结的$P(x)$是两个变量，如$P(x) \vee R(x)$和$\neg P(y) \vee Q(y)$或者$P(x) \vee R(x)$和$\neg P(x) \vee Q(x)$都不能进行归结。</p><h2 id="归结反演"><a href="#归结反演" class="headerlink" title="归结反演"></a>归结反演</h2><p>用$F$证明$Q$，我们构造集合$S =  $ { $ F , \neg Q $ }，利用归结原理，将每次得到的归结式并入$S$中，若出现空语句则可停止，此时就证明了$Q$为真。</p><h2 id="应用归结原理求解问题"><a href="#应用归结原理求解问题" class="headerlink" title="应用归结原理求解问题"></a>应用归结原理求解问题</h2><p>用$F$求解$Q$，将$Q$用谓词公式表示，否定$Q$与answer构成析取式，加入$S$，此时$S = $ { $ F, \neg Q \vee ANSWER $ }，再通过归结，得到$ANSWER$，那么就能得出答案。</p><h1 id="第五讲-可信度方法和证据理论"><a href="#第五讲-可信度方法和证据理论" class="headerlink" title="第五讲 可信度方法和证据理论"></a>第五讲 可信度方法和证据理论</h1><h2 id="5-2-可信度方法"><a href="#5-2-可信度方法" class="headerlink" title="5.2 可信度方法"></a>5.2 可信度方法</h2><p><strong>知识不确定性的表示</strong></p><p>$IF \ \ \ \ E  \ \ \ \  THEN \ \ \ \ H  \ \ \ \ (CF(H,E))$；$CF(H,E)$：可信度因子，反映前提条件与结论的联系强度；取值范围：$[ -1 , 1 ]$</p><p>若$CF(H,E) &gt; 0$，真的越确定；$&lt; 0$，假的越确定；$= 0$，证据的出现与$H$无关</p><p>多个单一证据的合取：</p><p>$E = E_1 \ AND \ E_2 \ AND … AND \ E_n$，则$CF(E) = min(CF(E_1),CF(E_2),…,CF(E_n))$</p><p>多个单一证据的析取：</p><p>$E = E_1 \ OR \ E_2 \ OR … OR \ E_n$，则$CF(E) = max(CF(E_1),CF(E_2),…,CF(E_n))$</p><p><strong>不确定的传递</strong></p><p>$CF(H) = CF(H,E) \times max(0,CF(E))$</p><p><strong>不确定的合成</strong></p><p>$CF(H,E_1) , CF(H,E_2)$</p><p>$CF_1(H) = CF(H,E_1) \times max(0,CF(E_1))$</p><p>$CF_2(H) = CF(H,E_2) \times max(0,CF(E_2))$<br>$$<br>CF_{1,2}(H) =<br>\begin{cases}<br>CF_1(H)+CF_2(H)-CF_1(H)_2CF(H) &amp; \text 若CF_1(H)  \geq 0 , CF_2(H) \geq 0  \newline<br>CF_1(H) + CF_2(H) + CF_1(H)_2CF(H) &amp; \text 若CF_1(H)  &lt; 0 , CF_2(H) &lt; 0  \newline<br>\frac{CF_1(H)+CF_2(H)}{1-min ( | CF_1(H) | , | CF_2(H) | ) }  &amp; \text CF_1(H),CF_2(H) 异号<br>\end{cases}<br>$$</p><h2 id="5-3-证据理论"><a href="#5-3-证据理论" class="headerlink" title="5.3 证据理论"></a>5.3 证据理论</h2><p><strong>概率分配函数</strong></p><p>在证据理论中，$D$的任何一个子集$A$都对应一个关于$x$的命题，称该命题为“$x$的值是在$A$中”</p><p>特别的$M( \varnothing  ) = 0 , \sum_{B \subseteq A} = 1$</p><p>概率分配函数是人工智能理论中非经典推理部分,证据理论中用到的一个函数，而概率是随机事件出现的可能性度量。</p><p><strong>信任函数</strong></p><p>$Bel \ : \ 2^D \rightarrow [0,1] (对于任何一个属于D的子集A,命它对应一个数M \in [0,1])且 Bel(A) = \sum_{B \subseteq A}^{} M(B) \ \ \ \  \forall A \subseteq D$</p><p>$Bel(A)$：对命题$A$为真的总的信任程度</p><p>$Bel(\varnothing) = M(\varnothing) = 0$</p><p>$Bel(D) = \sum_{B \subseteq D} M(B) = 1$</p><p><strong>似然函数</strong></p><p>又称不可驳斥函数或上限函数</p><p>$Pl(A) = 1 - Bel(\neg A)$</p><p><strong>概率分配函数的正交和</strong></p><p>设$M_1$和$M_2$是两个概率分配函数；则其正交和$M=M_1 \oplus M_2 : M(\varnothing) = 0$</p><p>$M(A) = K^{-1} \sum_{x \cap y = \varnothing} M_1(x) M_2(y)$</p><p>$K = 1 - \sum_{x \cap y = \varnothing }M_1(x) M_2(y) = \sum_{x \cap y \neq \varnothing } M_1(x) M_2(y)$</p><p>如果$K \neq 0$，则正交和$M$也是一个概率分配函数</p><p>如果$K = 0$，则不存在正交和$M$，即没有可能存在的概率函数，称$M_1$与$M_2$矛盾</p><h1 id="第六讲-模糊推理方法"><a href="#第六讲-模糊推理方法" class="headerlink" title="第六讲 模糊推理方法"></a>第六讲 模糊推理方法</h1><h2 id="6-1-模糊逻辑提出"><a href="#6-1-模糊逻辑提出" class="headerlink" title="6.1 模糊逻辑提出"></a>6.1 模糊逻辑提出</h2><p>以经典集合为根基</p><h2 id="6-2-模糊集合和隶属函数"><a href="#6-2-模糊集合和隶属函数" class="headerlink" title="6.2 模糊集合和隶属函数"></a>6.2 模糊集合和隶属函数</h2><p>论域：所讨论的全体对象，用$U$表示</p><p>元素：论域中每个对象，用$a,b,c,x,y,z$表示</p><p>集合：相同属性聚在一起的元素集</p><p>经典集合：集合中元素的关系只有两种，要么属于这个集合，要么不属于这个集合</p><p><strong>模糊集合</strong></p><p>给集合中每一个元素赋予一个介于0和1之间的实数， 描述其属于一个集合的强度，该实数称为元素属于一个集合的<strong>隶属度</strong>。集合中所有元素的隶属度全体构成集合的<strong>隶属函数</strong></p><p>表示方法：$A =${$(x,\mu_A(x)) , x \in X$}   $\mu_A (x)$：元素$x$属于模糊集$A$的隶属度，$X$是元素$x$的论域</p><p>Zadeh表示法</p><p>1）数目有限</p><p>$A = \mu_A(x_1) / x_1 + \mu_A(x_2) / x_2 +…+\mu_A(x_n) / x_n  = \sum_{i=1}^{n}{\mu_A(x_i) / x_i}$</p><p>$A=${$\mu_A(x_1) / x_1 ,\mu_A(x_2) / x_2 ,..,\mu_A(x_n) / x_n $}</p><p>2) 论域连续或元素无限</p><p>$A = \int_{x \in U} \mu_A(x)/x$</p><p>序偶表示法</p><p>$A =${$( \mu_A(x_1) , x_1) , ( \mu_A(x_2),x_2),…,( \mu_A(x_n) , x_n)$}</p><p>向量表示法</p><p>$A=${$\mu_A(x_1),\mu_A(x_2),…,(\mu_A(x_n),x_n),$}</p><p><strong>隶属度</strong></p><p>常见的隶属函数有正态分布、三角分布、梯形分布等</p><p>确定方法：模糊统计法、专家经验法、二元对比排序法、基本概念扩充法</p><h2 id="6-3-模糊关系及其合成"><a href="#6-3-模糊关系及其合成" class="headerlink" title="6.3 模糊关系及其合成"></a>6.3 模糊关系及其合成</h2><p>模糊集合的模糊关系用叉积表示<br>$$<br>R:A \times B \rightarrow [0,1]<br>$$<br>叉积常用最小算子运算</p><p>$\mu_{A \times B} (A,B) = min${$\mu_A(a) , \mu_B(b)$}</p><p>离散模糊集，用向量乘</p><p>$\mu_{A \times B} (a,b) = \mu_A^T \circ  \mu_B $</p><p>上面的向量运算，把乘换成取小运算，加换成取大运算即可</p><h2 id="6-4-模糊推理与模糊决策"><a href="#6-4-模糊推理与模糊决策" class="headerlink" title="6.4 模糊推理与模糊决策"></a>6.4 模糊推理与模糊决策</h2><p>模糊推理得到的就是模糊数</p><p>模糊决策：由模糊推理得到的结论或者操作是一个模糊向量，转化成为确定的过程</p><p>最大隶属度法：取最大的隶属度所对应的元素</p><p>加权平均判决法：$U = \frac{ \sum_{i=1}^{n} u (v_i) v_i}{\sum_{i=1}^n u (v_i)}$</p><p>中位数法：隶属度的中位数所对应的元素</p><h2 id="6-5-模糊推理的应用"><a href="#6-5-模糊推理的应用" class="headerlink" title="6.5 模糊推理的应用"></a>6.5 模糊推理的应用</h2><p>首先对于事实进行模糊合成$R$，然后在用条件$A’$与$R$合成$B’$，然后再进行模糊决策</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人工智能学习笔记&lt;/p&gt;
    
    </summary>
    
      <category term="课堂笔记" scheme="http://yoursite.com/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="http://yoursite.com/2020/02/26/%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/02/26/算法/</id>
    <published>2020-02-26T06:36:24.554Z</published>
    <updated>2020-03-11T03:26:25.684Z</updated>
    
    <content type="html"><![CDATA[<p>算法笔记</p><a id="more"></a><h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="算法和过程"><a href="#算法和过程" class="headerlink" title="算法和过程"></a>算法和过程</h2><p>过程(Procedure)与算法(Algorithm)是解决问题的一种方法的逐步描述：</p><p>相同点：由若干条指令组成的有穷序列；每条指令的意义都是确定的；具有零个或多个输入；产生若干个输出。</p><p>不同点：算法要求其执行时间是有限的(终止性)，过程的执行时间可能是限的</p><p>算法的复杂性取决于：求解问题的规模；具体的输入数据；算法本身的设计。</p><p>时间复杂性$T(N,I)=\sum_{i=1}^{k}{t_i * e_i(N,I)}$</p><p>其中$t_i$为执行抽象计算机的第$i$种指令一次所需时间，这里假定抽象计算机共有$k$种指令。</p><p>$e_i(N,I)$为经过统计后得到的执行抽象计算机的第$i$种指令的次数。</p><h2 id="常见符号及概念"><a href="#常见符号及概念" class="headerlink" title="常见符号及概念"></a>常见符号及概念</h2><p>上界记号$O$：如果存在整的常数$C$和自然数$N_0$，使得当$N \ge N_0$时有$f(N) \le C*g(N)$，则$f(N)$有上界函数$g(N)$，记为$f(N)=O(g(N))$。</p><p>下界记号$\Omega$：如果存在整的常数$C$和自然数$N_0$，使得当$N \ge N_0$时有$f(N) \ge C*g(N)$，则$f(N)$有下界函数$g(N)$，记为$f(N)=\Omega(g(N))$。</p><p>同阶记号$\Theta$：$f(N)=\Theta(g(N))$表示$f(N)$和$g(N)$同阶。</p><p>低阶记号$o$：$f(N) = o(g(N))$表示$f(N)$比$g(N)$阶低。</p><p>五种确定性算法，都使用递归的思想：</p><p>分支法，动态规划法(dp)，贪心法，回溯法，分支界限法。</p><p>算法所具有的五大特性：有穷性，确定性、输入、输出、可行性</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;算法笔记&lt;/p&gt;
    
    </summary>
    
      <category term="课堂笔记" scheme="http://yoursite.com/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机系统结构</title>
    <link href="http://yoursite.com/2019/09/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2019/09/08/计算机系统结构/</id>
    <published>2019-09-08T03:06:09.017Z</published>
    <updated>2019-09-25T14:06:38.537Z</updated>
    
    <content type="html"><![CDATA[<p>yqw还是依旧开口脆</p><a id="more"></a><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h3><p>共分为7个层次，第0级和第1级由硬件实现，第2级至第6级由软件实现，称为虚拟计算机。<br>从科学领域来划分：<br>第0级和第1级属于“计算机组成与系统结构”；<br>第2级至第5级是系统软件；<br>第6级是应用软件。<br>它们之间有交叉，如第3级必须依赖第4级和第5级来实现。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>第6级：应用程序</td><td>应用软件</td></tr><tr><td>第5级：高级语言</td><td>系统软件</td></tr><tr><td>第4级：汇编语言</td><td>系统软件</td></tr><tr><td>第3级：操作系统</td><td>系统软件</td></tr><tr><td>第2级：机器语言</td><td>软硬件分界</td></tr><tr><td>第1级：微程序</td><td>硬件</td></tr><tr><td>第0级：硬联逻辑</td><td>硬件</td></tr></tbody></table><h3 id="透明性"><a href="#透明性" class="headerlink" title="透明性"></a>透明性</h3><p>本来存在的事物或属性，从某种角度看似乎不存在。</p><h3 id="计算机系统的分类"><a href="#计算机系统的分类" class="headerlink" title="计算机系统的分类"></a>计算机系统的分类</h3><h4 id="按处理机性能分类"><a href="#按处理机性能分类" class="headerlink" title="按处理机性能分类:"></a>按处理机性能分类:</h4><p>按大小、用途、数据类型、处理机个数和种数、所用的器件。</p><h4 id="佛林分类法"><a href="#佛林分类法" class="headerlink" title="佛林分类法"></a>佛林分类法</h4><p>按照指令流和数据流的多倍特征进行分类，<br>用指令流：机器执行的指令序列；<br>数据流：由指令流调用的数据序列；<br>多倍性（multiplicity):在系统性能瓶颈部件上同时处于同一执行阶段的指令或数据的最大可能个数。<br>分成 4 类：<br>单指令流单数据流SISD (Single Instruction Single Datastream)<br>单指令流多数据流SIMD Single Instruction Multiple Datastream)<br>多指令流单数据流MISD(Multiple Instruction Single Datastream)<br>多指令流多数据流MIMD(Multiple Instruction Multiple Datastream)</p><h4 id="冯泽云分类法"><a href="#冯泽云分类法" class="headerlink" title="冯泽云分类法"></a>冯泽云分类法</h4><p>用最大并行度计算机系统进行分类<br>单位时间内能处理的最大二进制位数</p><p>同时处理的字宽为$n$，位宽$m$，则<br>最大并行度定义为：$P_m=m * n$</p><p>平均并行度：假使每个时钟周期$t_i$内能同时处理的二进位$B_i$，则n个时钟周期平均并行度为：<br>$$<br>P_n = \frac {\sum_{i=1}^{n} B_i * t_i}{n}​<br>$$<br>表示方法：处理机名$(m,n)$</p><h4 id="汉德勒分类法"><a href="#汉德勒分类法" class="headerlink" title="汉德勒分类法"></a>汉德勒分类法</h4><p>程序级$k$：程序控制部件(PCU)的个数。<br>操作级$d$：算术逻辑部件（ALU）或处理部件（PU）的个数。<br>逻辑级$w$：每个算术逻辑部件包含的逻辑线路（ELC）的套数。</p><p>表示方法：<br>$t ( 系统型号 ) = ( k,d,w )$</p><p>对于流水线来说，$t(系统型号) = (k * {k}’ , d * {d}’ , w * {w}’ )$</p><p>Cray1有1个CPU，12个相当于ALU或PE的处理部件，最多8级流水线，字长为64位，可以实现$1-14$位流水线，可以表示为：<code>t(Cray1)=(1 , 12×8 , 64(1-14))</code>。</p><h3 id="Amdahl定律"><a href="#Amdahl定律" class="headerlink" title="Amdahl定律"></a>Amdahl定律</h3><p>$$<br>可改进部分的比例: Fe=\frac{可改进部分的执行时间}{改进前整个任务的执行时间}<br>$$</p><p>$$<br>改进部分的加速比: Se=\frac{改进前改进部分的执行时间}{改进后改进部分的执行时间}<br>$$</p><p>改进后整个任务的执行速度：$T_n =T_0 * (1-Fe+\frac{Fe}{Se}) $</p><p>改进后整个任务的加速比：$S_n = \frac{T_0}{T_n} = \frac{1}{(1-Fe)+\frac{Fe}{Se}}$</p><h3 id="改进性能的主要途径"><a href="#改进性能的主要途径" class="headerlink" title="改进性能的主要途径"></a>改进性能的主要途径</h3><h4 id="面向目标代码改进"><a href="#面向目标代码改进" class="headerlink" title="面向目标代码改进"></a>面向目标代码改进</h4><p>根据计算结果改进（硬件乘除）、据统计数据改进指令功能（有目的改进）、增加运算型指令的功能（函数运算指令）。</p><h4 id="面向高级语言和编译程序改进"><a href="#面向高级语言和编译程序改进" class="headerlink" title="面向高级语言和编译程序改进"></a>面向高级语言和编译程序改进</h4><p>增强对高级语言和便宜程序支持的指令功能<del>花更少的成本有效率办事</del>。</p><h4 id="面向操作系统改进"><a href="#面向操作系统改进" class="headerlink" title="面向操作系统改进"></a>面向操作系统改进</h4><p> 系统结构设计要规整，消除例外情况。比如有$A-B$，就要有$B-A$，寄存器量的设置……</p><h3 id="计算机系统设计方法"><a href="#计算机系统设计方法" class="headerlink" title="计算机系统设计方法"></a>计算机系统设计方法</h3><p>由上向下：适合专用计算机的设计，价格要求高</p><p>由下向上：早期计算机设计，容易使软硬件的脱节</p><p>中间开始：软硬件同时设计</p><h3 id="计算机系统的评价标准"><a href="#计算机系统的评价标准" class="headerlink" title="计算机系统的评价标准"></a>计算机系统的评价标准</h3><h4 id="时钟频率"><a href="#时钟频率" class="headerlink" title="时钟频率"></a>时钟频率</h4><p>运行速度与Cache、内存大小、IO、程序等均有关。</p><h4 id="指令执行速度（算数平均）"><a href="#指令执行速度（算数平均）" class="headerlink" title="指令执行速度（算数平均）"></a>指令执行速度（算数平均）</h4><p>MIPS（百万次每秒）, GIPS, TIPS</p><p>最后求出来要带单位！写成$x \ MIPS$或者写$x*10^6$<br>$$<br>MIPS = \frac{Fz}{CPI} = IPC * Fz<br>$$<br>$Fz$为处理机工作主频<br>$CPI$为每条指令所需的平均时钟周期数<br>$IPC$为每个时钟周期平均执行的指令条数(流水线)</p><h4 id="等效指令速度（加权平均）：吉普森（Gibson-法"><a href="#等效指令速度（加权平均）：吉普森（Gibson-法" class="headerlink" title="等效指令速度（加权平均）：吉普森（Gibson)法"></a>等效指令速度（加权平均）：吉普森（Gibson)法</h4><p>等效指令执行时间$T = \sum_{i=1}^{n} {Time}_i * {Weight}_i$</p><p>等效指令速度$MIPS = \frac{1}{\sum_{i=1}^{n} {Time}_i * {Weight}_i}$</p><p>等效CPI $CPI = \sum_{i=1}^{n} {CPI}_i * {Weight}_i$</p><p>Gibson法：（一般）加减法50%，乘法15%，除法5%，程序控制15%，其它15%。</p><h3 id="冯·诺依曼结构"><a href="#冯·诺依曼结构" class="headerlink" title="冯·诺依曼结构"></a>冯·诺依曼结构</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>存储程序、运算器为中心、集成控制</p><p>将指令放到<strong>存储器</strong>中，然后执行</p><h4 id="变与不变"><a href="#变与不变" class="headerlink" title="变与不变"></a>变与不变</h4><p>不变的：存储程序。改变的：存储器为中心，总线结构，分散控制</p><h3 id="软件的可移植性"><a href="#软件的可移植性" class="headerlink" title="软件的可移植性"></a>软件的可移植性</h3><h4 id="采用系列机"><a href="#采用系列机" class="headerlink" title="采用系列机"></a>采用系列机</h4><p>指有相同系统结构的机器，这就涉及到兼容性问题：向后兼容；向前兼容； 向上兼容； 向下兼容。</p><p>对于设计：向后必须兼容，向上兼容尽量满足，剩下不做要求。</p><h4 id="采用模拟与仿真"><a href="#采用模拟与仿真" class="headerlink" title="采用模拟与仿真"></a>采用模拟与仿真</h4><p>模拟：在一台现有的计算机上实现另一台计算机的指令系统</p><p>仿真：用微程序直接解释执行另一种机器指令系统</p><h4 id="采用统一高级语言方法"><a href="#采用统一高级语言方法" class="headerlink" title="采用统一高级语言方法"></a>采用统一高级语言方法</h4><h3 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h3><h4 id="1-8"><a href="#1-8" class="headerlink" title="1.8"></a>1.8</h4><p>从机器（汇编）语言程序员看，以下哪些是透明的？<br>指令地址寄存器；指令缓冲器；时标发生器；条件寄存器；乘法器；主存地址寄存器；磁盘外设；先行进位链；移位器；通用寄存器；中断字寄存器。</p><p>指令缓冲器，时标发生器，乘法器，主存地址寄存器，先行进位链，移位器</p><h4 id="1-9"><a href="#1-9" class="headerlink" title="1.9"></a>1.9</h4><p>哪些对系统程序员是透明的？哪些对应用程序员是透明的？</p><p>系列机各档不同的数据通路宽度；虚拟存储器；Cache存储器；程序状态字；“启动I/O”指令；“执行”指令；指令缓冲寄存器。</p><p>对系统程序员透明的有：虚拟存储器；Cache存储器；程序状态字；<br>对应用程序员透明的有：系列机各档不同的数据通路宽度；“启动I/O”指令；“执行”指令；指令缓冲寄存器。</p><p>系列机各档不同数据通路宽度、Cache存储器、指令缓冲寄存器属计算机组成，对系统程序员和应用程序员都是透明的。虚拟存储器、程序状态字、“启动I/O”指令，对系统程序员是不透明的，而对应用程序员却是透明的。</p><p>“执行”指令则对系统程序员和应用程序员都是不透明的。</p><h4 id="1-11"><a href="#1-11" class="headerlink" title="1.11"></a>1.11</h4><p>想在系列机中发展一种新型号机器，你认为下列哪些设想是可以考虑的，哪些则不行的？为什么？<br>（1）新增加字符数据类型和若干条字符处理指令，以支持事务处理程序的编译。<br>（2）为增强中断处理功能，将中断分级由原来的4级增加到5级，并重新调整中断响应的优先次序。<br>（3）在CPU和主存之间增设Cache存储器，以克服因主存访问速率过低而造成的系统性能瓶颈。<br>（4）为解决计算误差较大，将机器中浮点数的下溢处理方法由原来的恒置“1”法，改为用ROM存取下溢处理结果的查表舍入法。<br>（5）为增加寻址灵活性和减少平均指令字长，将原等长操作码指令改为有3类不同码长的扩展操作码；将源操作数寻址方式由操作码指明改成如VAX-11那种设寻址方式位字段指明。<br>（6）将CPU与主存间的数据通路宽度由16位扩展成32位，以加快主机内部信息的传送。<br>（7）为减少公用总路线的使用冲突，将单总线改为双总线。<br>（8）把原0号通用寄存器改作堆栈指示器。</p><p>答: (2)、(5)、(8)不可以，其它都可以。</p><p>对于（2）对系列机可以增加新功能,但是不能改变原来的功能。</p><p>对于（5）改变了指令的格式和功能</p><p>对于（8）导致0号寄存器无法使用</p><h4 id="1-17"><a href="#1-17" class="headerlink" title="1.17"></a>1.17</h4><p>假设高速缓存Cache 工作速度为主存的5倍，且Cache被访问命中的概率为90%，则采用Cache后，能使整个存储系统获得多高的加速比？</p><p>$Fe = 0.9\ , \ Se=5$ 所以： $S_n = \frac{1}{1-Fe+\frac{Fe}{Se}} = \frac{1}{1-0.9+\frac{0.9}{5}} = \frac{25}{7}$</p><h4 id="1-19"><a href="#1-19" class="headerlink" title="1.19"></a>1.19</h4><p>用一台40MHz处理机执行标准测试程序，它含的混合指令数和相应所需的时钟周期数如下：</p><p>指令类型        指令数       时钟周期数</p><p>整数运算        45000            1</p><p>数据传送        32000            2</p><p>浮点            15000            2 </p><p>控制传送         8000            2</p><p>求有效CPI、MIPS速率和程序的执行时间。</p><p>$IC = \sum_{i=1}^{4}I_i = 45000+32000+15000+8000=10^5$</p><p>$有效CPI = \frac{\sum_{i=1}^{4}CPI_i \times I_i}{IC} = 1.55$</p><p>$MIPS = \frac{40}{1.55} = 35.81MIPS$</p><p>$T_{有效} = \frac{IC}{MIPS \times 10^6} = 0.003875\ s$</p><h4 id="1-21"><a href="#1-21" class="headerlink" title="1.21"></a>1.21</h4><p>假设在一台$40MHz$的处理及上运行$200000$条指令的目标代码，程序主要由四种指令组成。根据程序跟踪实验结果，一直指令混合比和每种指令所需的指令数如下：</p><table><thead><tr><th>指令类型</th><th>$ CPI $</th><th>指令混合比</th></tr></thead><tbody><tr><td>算数和逻辑</td><td>1</td><td>60%​</td></tr><tr><td>高速缓存命中的加载/存储</td><td>2</td><td>18%</td></tr><tr><td>转移</td><td>4</td><td>12%</td></tr><tr><td>告诉缓存确实的存储器访问</td><td>8</td><td>10%</td></tr></tbody></table><p>平均$CPI = \sum_{i=1}^{4} CPI_i \times 指令混合比 = 2.24$</p><p>$MIPS = \frac{40}{2.24} = 17.86 \ MIPS$ </p><h4 id="1-23"><a href="#1-23" class="headerlink" title="1.23"></a>1.23</h4><p>根据下面计算算数平均、几何平均、调和平均</p><table><thead><tr><th>程序名</th><th>速率($MFLOPS$)</th></tr></thead><tbody><tr><td>$GCC$</td><td>$10.7$</td></tr><tr><td>$Espress0$</td><td>$8.9$</td></tr><tr><td>$Spice2g6$</td><td>$8.3$</td></tr><tr><td>$DODUC$</td><td>$5.0 $</td></tr><tr><td>$NASA7$</td><td>$8.7 $</td></tr><tr><td>$Li$</td><td>$9.0$</td></tr><tr><td>$Eqntott$</td><td>$9.7$</td></tr><tr><td>$Matrix300$</td><td>$11.1$</td></tr><tr><td>$FPPPP$</td><td>$7.8$</td></tr><tr><td>$TOMCATV$</td><td>$5.6$</td></tr></tbody></table><p>算数平均：$A_m = \frac{1}{n} * \sum_{i=1}^{n} R_i = 8.48 \ MFLOPS$</p><p>几何平均：$G_m = \sqrt[n]{\prod_{i=1}^{n} R_i} = 8.247 \ MFLOPS$</p><p>调和平均：$H_m = \frac{n}{\sum_{i=1}^{n} \frac{1}{R_i}} = 7.985 \ MFLOPS$</p><hr><h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><h3 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h3><p>数据表示是指计算机硬件能够直接认识，可以被指令系统直接调用的那些数据类型。</p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>文件、图、表、树、链表、栈、向量、队列、阵列、串、实数、整数、布尔数、字符等。</p><p>用<strong>变址寻址</strong>方式来支持向量数据表示，用<strong>字节编址</strong>支持字符串数据表示</p><p>普通需要支持向量运算，则在设计寻址方式时，一定要设置<strong>变址和自动变址</strong>寻址方式。</p><h4 id="浮点数据"><a href="#浮点数据" class="headerlink" title="浮点数据"></a>浮点数据</h4><p>$$<br>N = m \times r_m^e<br>$$</p><h5 id="两个数值"><a href="#两个数值" class="headerlink" title="两个数值"></a>两个数值</h5><p>尾数$m$：数制(小数或整数)和码制(原码或补码)。<br>阶码$e$:     整码，移码(偏码、增码、余码)或补码。（移码就是补码的符号位取反）</p><h5 id="两个基值"><a href="#两个基值" class="headerlink" title="两个基值"></a>两个基值</h5><p>$r_m$：尾数的基值，二进制，八进制…</p><p>$r_e$：阶码的基值，一般为$2$。</p><h5 id="两个字长"><a href="#两个字长" class="headerlink" title="两个字长"></a>两个字长</h5><p>长度和物理位置，均不包含符号位</p><p>尾数的长度$p$：尾数部分按照基值计算的长度，比如说$10_{(10)} = 1010_{(2)}$，$p$分别为$2$和$4$</p><p>阶码长度$q$ :  阶码部分的二进制位数</p><h5 id="阶码"><a href="#阶码" class="headerlink" title="阶码"></a>阶码</h5><p>阶码就是补码的符号位取反</p><h5 id="表数范围"><a href="#表数范围" class="headerlink" title="表数范围"></a>表数范围</h5><p>尾数用原码、纯小数时规格化浮点数的表数范围</p><table><thead><tr><th>表数范围</th><th>规格化尾数</th><th>阶码</th><th>规格化浮点数</th></tr></thead><tbody><tr><td>$N_{max}$最大正数</td><td>$1 - r_m^{-p}$</td><td>$r_e^q-1$</td><td>$(1-r_m^{-p})\times r_m^{r_e^{q}-1}$</td></tr><tr><td>$N_{min}$最小正数</td><td>$r_m^{-1}$</td><td>\</td><td>$r_m^{-1}\times r_m^{-r_e^q}$</td></tr><tr><td>$-N_{max}$最大负数</td><td>$-r_m^{-1}$</td><td>\</td><td>$-r_m^{-1}\times r_m^{-r_e^q}$</td></tr><tr><td>$-N_{min}$最小负数</td><td>$-(1-r_m^{-p})$</td><td>$-r_e^q$</td><td>$-(1-r_m^{-p}) \times r_m^{r_e^q-1}$</td></tr></tbody></table><p>尾数用补码、纯小数时规格化浮点数的表数范围</p><table><thead><tr><th>表数范围</th><th>规格化尾数</th><th>阶码</th><th>规格化浮点数</th></tr></thead><tbody><tr><td>$N_{max}$最大正数</td><td>$1 - r_m^{-p}$</td><td>$r_e^q-1$</td><td>$(1-r_m^{-p})\times r_m^{r_e^{q}-1}$</td></tr><tr><td>$N_{min}$最小正数</td><td>$r_m^{-1}$</td><td>\</td><td>$r_m^{-1}\times r_m^{-r_e^q}$</td></tr><tr><td>$-N_{max}$最大负数</td><td>$-(r_m^{-1}+r_m^{-p})$</td><td>\</td><td>$-(r_m^{-1}+r_m^{-p})\times r_m^{-r_e^q}$</td></tr><tr><td>$-N_{min}$最小负数</td><td>$-1$</td><td>$-r_e^q$</td><td>$-r_m^{r_e^q-1}$</td></tr></tbody></table><h5 id="IEEE754浮点数标准"><a href="#IEEE754浮点数标准" class="headerlink" title="IEEE754浮点数标准"></a>IEEE754浮点数标准</h5><p>32位如下：</p><table><thead><tr><th>符号$S$</th><th>阶码$e$</th><th>尾数数值$m$</th></tr></thead><tbody><tr><td>$1$位</td><td>$8$位</td><td>$23$位</td></tr></tbody></table><p>阶码用移码-127表示，即阶码的0-255分别表示阶码的真值为-127~128。尾数用原码、小数，1位符号位、23位小数和<strong>1位隐藏位</strong>的整数共25位表示。尾数和阶码的基值都是2。64位双精度浮点数，阶码用11位移移码表示</p><h5 id="浮点数的误差"><a href="#浮点数的误差" class="headerlink" title="浮点数的误差"></a>浮点数的误差</h5><p>产生误差的根本原因是浮点数的不连续性。</p><p>误差产生的直接原因有两个：<br>（1）两个浮点数都在浮点集内，而运算结果却可能不在这个浮点集内。<br>（2）数据从十进制转化为2、4、8、16进制，产生误差。</p><p>浮点数的精度：$\delta _{(r_m,p)} = \frac{1}{2} \times r_m ^{-(p-1)} $</p><h5 id="浮点数的表数效率"><a href="#浮点数的表数效率" class="headerlink" title="浮点数的表数效率"></a>浮点数的表数效率</h5><p>$\eta (r_m) = \frac{r_m-1}{r_m}$，$r_m$为尾数基值。</p><p>$\eta = \frac{可表示的规格化浮点数个数}{全部浮点数个数}$</p><h5 id="浮点数格式设计"><a href="#浮点数格式设计" class="headerlink" title="浮点数格式设计"></a>浮点数格式设计</h5><p>在字长确定的情况下，如何选择尾数基值$r_m$，使表数范围最大、表数精度和表数效率最高。</p><p>结论1：在字长和表数范围一定时，尾数基值$r_m$取2或4，浮点数具有最高的表精度。</p><p>结论2：在字长和表数精度一定时，尾数基值$r_m$取2或4，浮点数具有最大的表示数范围。</p><p>推论：在字长确定后，尾数基值$r_m$取2或4，浮点数具有最大的表数范围和最高表数精度。</p><p>当$r_m=2$时，规格化浮点数可以采用隐藏位方法表示，如果尾数用原码表示，最高位<strong>一定为1</strong>；如果尾数补码表示，最高位<strong>一定与符号位相反</strong>，这时，表数效率为100%。</p><p>尾数：多数机器用原码、小数表示</p><p>采用原码表示：加减法比补码表示复杂，乘除法比补码简单，而且非常直观。采用小数表示能简化运算，特别是乘法和除法运算。</p><p>阶码：一般机器用整数、移码表示</p><p>采用移码表示主要原因是：浮点0与机器0一致。阶码进行加减运算时，移码的加减法运算要比补码复杂。</p><p>基值：尾数的基值：$r_m=2$      阶码的基值:   $r_e=2$</p><p>采用隐藏位表示方式能够使规格化浮点数的表数的效率达到100%（当$r_m=2$时）</p><h5 id="舍入方法"><a href="#舍入方法" class="headerlink" title="舍入方法"></a>舍入方法</h5><p>方法1：恒舍法    又称截断法、必舍法等</p><p>方法2：恒置法    又称恒置r/2法、冯诺依曼法。规则：把有效字长的最低一位置成r/2</p><p>方法3：下舍上入法    又称四舍五入法、0舍1入法。</p><p>方法4：$R^*$舍入法    只有少数巨型机采用。</p><p>方法5：查表法    $ROM$舍入法，$PLA$舍入法等。</p><h5 id="警戒位"><a href="#警戒位" class="headerlink" title="警戒位"></a>警戒位</h5><p>在对阶时多设置一位来避免误差，一般设置一位警戒位就好。</p><h3 id="寻址技术"><a href="#寻址技术" class="headerlink" title="寻址技术"></a>寻址技术</h3><h4 id="编址方式"><a href="#编址方式" class="headerlink" title="编址方式"></a>编址方式</h4><p>常用的编址单位：字编址、字节编址、位编址、块编址等。</p><p>大端和小端问题：从左边开始编址就是大端(0 1 2 3…)，从右边开始编址就是小端(…3 2 1 0)。</p><p>三个零地址空间：通用寄存器、主存储器、输入输出设备独立编址。</p><p>两个零地址空间：通用寄存器，主存储与输入输出设备统一遍址。</p><p>一个零地址空间：最低端是通用寄存器，最高端是输入输出设备，中间为主存储器。</p><p>隐含编址方式：堆栈、Cache等。</p><h4 id="并行存储器的编址技术"><a href="#并行存储器的编址技术" class="headerlink" title="并行存储器的编址技术"></a>并行存储器的编址技术</h4><p>高位交叉编址：主要用来扩大存储器容量。</p><p>低位交叉编址：主要是提高存储器速度。</p><h4 id="输入输出设备编址"><a href="#输入输出设备编址" class="headerlink" title="输入输出设备编址"></a>输入输出设备编址</h4><p>一台设备一个地址：通过指令来区分地址，地址内部区分地址。</p><p>一台设备两个地址：数据寄存器、状态或控制寄存器。</p><p>多个编址寄存器共用同一个地址的方法：依靠地址内部区分，使用于被编址的寄存器的长度比较短。</p><p>“下跟法”隐含编址方式：必须按顺序读写寄存器。</p><p>一台设备多个地址：增加编程的困难。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;yqw还是依旧开口脆&lt;/p&gt;
    
    </summary>
    
      <category term="课堂笔记" scheme="http://yoursite.com/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Oracle</title>
    <link href="http://yoursite.com/2019/09/06/Oracle/"/>
    <id>http://yoursite.com/2019/09/06/Oracle/</id>
    <published>2019-09-06T15:24:57.258Z</published>
    <updated>2019-09-06T15:31:39.621Z</updated>
    
    <content type="html"><![CDATA[<p><del>上谢大的课有感？</del></p><a id="more"></a><h3 id="oracle函数"><a href="#oracle函数" class="headerlink" title="oracle函数"></a>oracle函数</h3><hr><h4 id="数值型常用函数"><a href="#数值型常用函数" class="headerlink" title="数值型常用函数"></a>数值型常用函数</h4><table><thead><tr><th>函数</th><th>返回值</th><th>样例</th><th>显示</th></tr></thead><tbody><tr><td>ceil(n)</td><td>大于或等于数值n的最小整数</td><td>select ceil(10.6) from dual;</td><td>11</td></tr><tr><td>floor(n)</td><td>小于等于数值n的最大整数</td><td>select ceil(10.6) from dual;</td><td>10</td></tr><tr><td>mod(m,n)</td><td>m除以n的余数,若n=0,则返回m</td><td>select mod(7,5) from dual;</td><td>2</td></tr><tr><td>power(m,n)</td><td>$m^n$</td><td>select power(3,2) from dual;</td><td>9</td></tr><tr><td>round(n,m)</td><td>将n四舍五入,保留小数点后m位</td><td>select round(1234.5678,2) from dual;</td><td>1234.57</td></tr><tr><td>sign(n)</td><td>若n=0,则返回0,否则,n&gt;0,则返回1,n&lt;0,则返回-1</td><td>select sign(12) from dual;</td><td>1</td></tr><tr><td>sqrt(n)</td><td>$\sqrt{n}$</td><td>select sqrt(25) from dual ;</td><td>5</td></tr></tbody></table><hr><h4 id="日期型函数"><a href="#日期型函数" class="headerlink" title="日期型函数"></a>日期型函数</h4><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>sysdate</td><td>当前日期和时间</td><td>select sysdate from dual;</td></tr><tr><td>last_day</td><td>本月最后一天</td><td>select last_day(sysdate) from dual;</td></tr><tr><td>add_months(d,n)</td><td>当前日期d后推n个月</td><td>select add_months(sysdate,2) from dual;</td></tr><tr><td>next_day(d,day)</td><td>d后第一周指定day的日期</td><td>select next_day(sysdate,’Monday’) from dual;</td></tr><tr><td>months_between(d,n)</td><td>日期d和n相差月数</td><td>select months_between(sysdate, to_date(‘20020812’,’YYYYMMDD’)) from dual;</td></tr></tbody></table><p>day 格式：’Monday’ ‘  ‘Tuesday’ ‘wednesday’ ‘Thursday’ ‘Friday’ ‘Saturday’ ‘Sunday’ </p><hr><h4 id="特殊格式的日期型函数"><a href="#特殊格式的日期型函数" class="headerlink" title="特殊格式的日期型函数"></a>特殊格式的日期型函数</h4><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Y或YY或YYY 年的最后一位，两位，三位</td><td>select to_char(sysdate,’YYY’) from dual;</td></tr><tr><td>Q 季度,1-3月为第一季度</td><td>select to_char(sysdate,’Q’) from dual;</td></tr><tr><td>MM 　月份数</td><td>select to_char(sysdate,’MM’) from dual;</td></tr><tr><td>RM 月份的罗马表示</td><td>select to_char(sysdate,’RM’) from dual; IV</td></tr><tr><td>month 用9个字符表示的月份名</td><td>select to_char(sysdate,’month’) from dual;</td></tr><tr><td>ww 当年第几周</td><td>select to_char(sysdate,’ww’) from dual;</td></tr><tr><td>w 本月第几周</td><td>select to_char(sysdate,’w’) from dual;</td></tr><tr><td>DDD 当年第几天,一月一日为001 ,二月一日032</td><td>select to_char(sysdate,’DDD’) from dual;</td></tr><tr><td>DD 当月第几天</td><td>select to_char(sysdate,’DD’) from dual;</td></tr><tr><td>D 周内第几天</td><td>select to_char(sysdate,’D’) from dual; 如　sunday</td></tr><tr><td>DY 周内第几天缩写</td><td>select to_char(sysdate,’DY’) from dual; 如　sun</td></tr><tr><td>hh12 12小时制小时数</td><td>select to_char(sysdate,’hh12’) from dual;</td></tr><tr><td>hh24 24小时制小时数</td><td>select to_char(sysdate,’hh24’) from dual;</td></tr><tr><td>Mi 分钟数</td><td>select to_char(sysdate,’Mi’) from dual;</td></tr><tr><td>ss 秒数</td><td>select to_char(sysdate,’ss’) from dual;</td></tr><tr><td>to_number() 将合法的数字字符串转换成数字</td><td>select to_number(‘88877’) from dual; 88877</td></tr><tr><td>to_char() 将数字转换为字符串</td><td>select to_char(88877) from dual; ‘88877’</td></tr></tbody></table><hr><h4 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h4><p>字符函数主要用于修改字符列。这些函数接受字符输入，返回字符或数字值。Oracle 提供的一些字符函数如下。</p><ol><li>CONCAT (char1, char2)</li></ol><p>返回连接“char2”的“char1”。</p><p>示例  SELECT CONCAT( CONCAT(ename, ‘ is a ‘), job) FROM emp;</p><ol start="2"><li>INITCAP(string)</li></ol><p>将“string”的字符转成大写。</p><p>示例 Select INITCAP(ename) from emp;</p><ol start="3"><li>LOWER (string)</li></ol><p>将“string”转成小写。</p><p>示例 Select LOWER(ENAME) from emp;</p><ol start="4"><li>LPAD(char1,n [,char2])</li></ol><p>返回“char1”，左起由“char2”中的字符补充到“n”个字符长。如果“char1”比“n”长，则函数返回“char1”的前“n”个字符。</p><p>示例 SELECT LPAD(ename,15,’*’) FROM emp;</p><ol start="5"><li>LTRIM(string,trim_set)</li></ol><p>从左边删除字符，此处“string”是数据库的列，或者是字面字符串，而“trim_set” 是我们要去掉的字符的集合。</p><p>示例 SELECT LTRIM(‘abcdab’,’a’) FROM DUAL;</p><ol start="6"><li>REPLACE(string, if, then)</li></ol><p>用 0 或其他字符代替字符串中的字符。“if”是字符或字符串，对于每个出现在“string”中的“if”，都用“then”的内容代替。</p><p>示例 SELECT REPLACE(‘JACK and JUE’,’J’,’BL’) FROM DUAL;</p><ol start="7"><li>RPAD(char1, n [,char2])</li></ol><p>返回“char1”，右侧用“char2”中的字符补充到“n”个字符长。如果 “char1”比“n” 长，则函数返回“char1”的前“n”个字符。</p><p>示例 SELECT RPAD(ename,15,’*’) FROM emp;</p><ol start="8"><li>RTRIM(string,trim_set)</li></ol><p>从右侧删除字符，此处“string”是数据库的列，或者是字面字符串，而“trim_set” 是我们要去掉的字符的集合。</p><p>示例 SELECT RTRIM(‘abcdef’, ‘f’) FROM DUAL;</p><ol start="9"><li>SOUNDEX(char)</li></ol><p>返回包含“char”的表意字符的字符串。它允许比较英语中拼写不同而发音类似的字。</p><p>示例 SELECT ename FROM emp</p><p>WHERE SOUNDEX(ename) = SoUNDEX(‘SMYTHE’);</p><ol start="10"><li>SUBSTR(string, start [,count])</li></ol><p>返回“string”中截取的一部分。该命令截取“string”的一个子集，从“start”位置开始，持续“count”个字符。如果我们不指定“count”，则从“start”开始截取到“string”的尾部。</p><p>示例 SELECT SUBSTR(‘ABCDEFGIJKLM’,3,4) FROM DUAL;</p><ol start="11"><li>TRANSLATE(string, if, then)</li></ol><p>“if”中字符的位置，并检查“then”的相同位置，然后用该位置的字符替换 “string”中的字符。</p><p>示例 SELECT TRANSLATE(ename,’AEIOU’, ‘XXXXX’) FROM emp;</p><ol start="12"><li>UPPER(string)</li></ol><p>返回大写的“string”。</p><p>示例 SELECT UPPER(‘aptech computer education’) FROM dual;</p><ol start="13"><li>ASCII(string)</li></ol><p>该命令是“American Standard Code for Information Interchange”的缩写。它是使用数字表示可打印字符的基本规则。该函数返回 “string”中第一个（最左边）字符的 ASCII 值。</p><p>示例 SELECT ASCII(‘APTECH’) from dual;</p><ol start="14"><li>INSTR (string, set[, start[, occurrence] ] )</li></ol><p>该命令“string”中从“start”位置开始查找字符集合的位置，再查找“set”出现的第一次、第二次等等的“occurrence”（次数）。“start”的值也可以是负数，代表从字符串结尾开始向反方向搜索。该函数也用于数字和日期数据类型。</p><p>示例 SELECT INSTR(‘aptech is aptech’,’ap’,1,2) FROM DUAL;</p><ol start="15"><li>LENGTH(string)</li></ol><p>返回“string”的长度值。</p><p>示例 SELECT ename, LENGTH(ename) FROM emp </p><p>WHERE empno = 7698;</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;del&gt;上谢大的课有感？&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="课堂笔记" scheme="http://yoursite.com/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>模板整理</title>
    <link href="http://yoursite.com/2019/08/22/%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2019/08/22/模板整理/</id>
    <published>2019-08-22T15:01:37.380Z</published>
    <updated>2019-12-15T02:44:14.850Z</updated>
    
    <content type="html"><![CDATA[<p>Collected By Hope_Y…</p><a id="more"></a><h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><p>部分来自<a href="https://quincy.ink/" target="_blank" rel="noopener">QuincyTan</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ext/pb_ds/assoc_container.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ext/pb_ds/tree_policy.hpp&gt;//用tree</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ext/pb_ds/hash_policy.hpp&gt;//用hash</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ext/pb_ds/trie_policy.hpp&gt;//用trie</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ext/pb_ds/priority_queue.hpp&gt;//用priority_queue</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_pbds;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//hash表 用法类似map,时间复杂度O(n)</span></span><br><span class="line">cc_hash_table&lt;<span class="keyword">int</span>,<span class="keyword">bool</span>&gt; h; <span class="comment">//拉链法</span></span><br><span class="line">gp_hash_table&lt;<span class="keyword">int</span>,<span class="keyword">bool</span>&gt; h; <span class="comment">//探测法</span></span><br><span class="line">h.clear() <span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 平衡树 以下操作时间复杂度均为O(logn)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">team</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> t,p,id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> team&amp;hs)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t!=hs.t?t&gt;hs.t:p!=hs.p?p&lt;hs.p:id&lt;hs.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> tree&lt;team,null_type,less&lt;team&gt;,rb_tree_tag,tree_order_statistics_node_update&gt; rebtree;</span><br><span class="line">null_type <span class="comment">//无映射(低版本g++为null_mapped_type)</span></span><br><span class="line">less&lt;T&gt; <span class="comment">//从小到大排序</span></span><br><span class="line">rb_tree_tag <span class="comment">//红黑树</span></span><br><span class="line">tree_order_statistics_node_update <span class="comment">//更新方式</span></span><br><span class="line">tr.insert(x); <span class="comment">//插入;</span></span><br><span class="line">tr.erase(x); <span class="comment">//删除;</span></span><br><span class="line">tr.order_of_key(x); <span class="comment">//求比x小的个数 rank=res+1</span></span><br><span class="line">tr.find_by_order(k<span class="number">-1</span>); <span class="comment">//找k小值,返回迭代器 k值非法，则会返回end()</span></span><br><span class="line">tr.join(b); <span class="comment">//将b并入tr,前提是两棵树类型一样且没有重复元素</span></span><br><span class="line">tr.split(v,b); <span class="comment">//分裂,key小于等于v的元素属于tr,其余的属于b</span></span><br><span class="line">tr.lower_bound(x); <span class="comment">//返回第一个&gt;=x的元素的迭代器 x的前驱 *--tr.lower_bound(x)</span></span><br><span class="line">tr.upper_bound(x); <span class="comment">//返回第一个&gt;x的元素的迭代器  x的后继 *tr.lower_bound(x)</span></span><br><span class="line"><span class="comment">//迭代器支持++,--操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//堆</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,greater&lt;<span class="keyword">int</span>&gt;,TAG&gt; Q; <span class="comment">//注意命名空间别和std中的那个重了</span></span><br><span class="line"><span class="comment">/*其中的TAG为类型，有以下几种：</span></span><br><span class="line"><span class="comment">pairing_heap_tag //最快</span></span><br><span class="line"><span class="comment">thin_heap_tag</span></span><br><span class="line"><span class="comment">binomial_heap_tag</span></span><br><span class="line"><span class="comment">rc_binomial_heap_tag</span></span><br><span class="line"><span class="comment">binary_heap_tag</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    node()&#123;&#125;</span><br><span class="line">    node(<span class="keyword">int</span> x):x(x)&#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (node i,node j)&#123;</span><br><span class="line">        <span class="keyword">return</span> i.x&gt;j.x; <span class="comment">// 队首元素是小的，即小的的优先级大，这个在sort的bool函数有点差别</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; q;<span class="comment">/////采取最小优先策略，即按从小到大的顺序排列</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt; q;  <span class="comment">////采取最大优先策略，即按从大到小的顺序排列</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__gnu_pbds::priority_queue&lt;<span class="keyword">int</span>&gt;::point_iterator it;  <span class="comment">//支持迭代器</span></span><br><span class="line">Q.push(x); <span class="comment">//push()会返回迭代器,用一个迭代器数组保存所有进队列的元素的迭代器，就可以持久化操作</span></span><br><span class="line">Q.pop();</span><br><span class="line">Q.top();</span><br><span class="line">Q.join(b);</span><br><span class="line">Q.empty();</span><br><span class="line">Q.size();</span><br><span class="line">Q.modify(it,<span class="number">6</span>);</span><br><span class="line">Q.erase(it);</span><br><span class="line"></span><br><span class="line">sort <span class="comment">//排序中的bool函数的使用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&lt;y;  <span class="comment">//就是比较x元素和y元素，如果表达式为真，就不交换</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//但是呢，当你要自定义某个元素的优先级，比如说2排最前面</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x==<span class="number">2</span>; <span class="comment">// 否则y==2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//rope 时间复杂度O(logN)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext/rope&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_cxx;</span><br><span class="line">rope&lt;<span class="keyword">int</span>&gt; r;</span><br><span class="line">push_back(x)    <span class="comment">//在末尾添加x</span></span><br><span class="line">insert(pos,x)   <span class="comment">//在pos插入x</span></span><br><span class="line">erase(pos,x)    <span class="comment">//从pos开始删除x个</span></span><br><span class="line">copy(pos,len,x) <span class="comment">//从pos开始到pos+len为止用x代替</span></span><br><span class="line">replace(pos,x)  <span class="comment">//从pos开始换成x</span></span><br><span class="line">substr(pos,x)   <span class="comment">//提取pos开始x个</span></span><br><span class="line">at(x)/[x]   <span class="comment">//访问第x个元素</span></span><br><span class="line"><span class="comment">//可持久化 O(1)复制根节点</span></span><br><span class="line">rope&lt;<span class="keyword">char</span>&gt; *his[maxn];</span><br><span class="line">his[<span class="number">0</span>] = <span class="keyword">new</span> rope&lt;<span class="keyword">char</span>&gt;();</span><br><span class="line">his[i] = <span class="keyword">new</span> rope&lt;<span class="keyword">char</span>&gt;(*his[i<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//list 合并操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">list</span> &lt;T&gt; &amp; x)</span></span></span><br><span class="line"><span class="function"><span class="comment">//将链表x合并进来并清空x,要求链表自身和x都是有序的</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splice</span> <span class="params">( iterator position, <span class="built_in">list</span>&lt;T,Allocator&gt;&amp; x )</span></span>;</span><br><span class="line"><span class="comment">//在position后把list&amp;x所有的元素到剪接到要操作的list对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splice</span> <span class="params">( iterator position, <span class="built_in">list</span>&lt;T,Allocator&gt;&amp; x, iterator it )</span></span>;</span><br><span class="line"><span class="comment">//只会把it的值剪接到要操作的list对象中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splice</span> <span class="params">( iterator position, <span class="built_in">list</span>&lt;T,Allocator&gt;&amp; x, iterator first, iterator last )</span></span>;</span><br><span class="line"><span class="comment">//把first到last剪接到要操作的list对象中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//O(n)查询第k大</span></span><br><span class="line">nth_element(a+<span class="number">1</span>,a+k,a+<span class="number">1</span>+n);</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span><span class="comment">//双向队列</span></span><br><span class="line">pop_back() <span class="comment">//删除尾部的元素 </span></span><br><span class="line">pop_front() <span class="comment">//删除头部的元素 </span></span><br><span class="line">push_back() <span class="comment">//在尾部加入一个元素 </span></span><br><span class="line">push_front() <span class="comment">//在头部加入一个元素 </span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>; <span class="keyword">bool</span> f=<span class="number">0</span>; <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span> (ch&lt;<span class="string">'0'</span> || <span class="string">'9'</span>&lt;ch) f|=ch==<span class="string">'-'</span>, ch=getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="string">'0'</span>&lt;=ch &amp;&amp; ch&lt;=<span class="string">'9'</span>) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>, ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>) print(x / <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">multi</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x,<span class="keyword">long</span> <span class="keyword">long</span> y,<span class="keyword">long</span> <span class="keyword">long</span> mod)</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> tmp=(x*y-(<span class="keyword">long</span> <span class="keyword">long</span>)((<span class="keyword">long</span> <span class="keyword">double</span>)x/mod*y+<span class="number">1.0e-8</span>)*mod);</span><br><span class="line"><span class="keyword">return</span> tmp&lt;<span class="number">0</span> ? tmp+mod : tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>LIS问题：最长上升子序列</p><p>$ dp_i $表示以$ i $结尾的最长上升子序列，$ dp_i=max_{0 \leq j &lt;i,a_j&lt;a_i}(dp_j+1) $。</p><p>$O(nlogn)$的解法(<a href="https://www.cnblogs.com/KYSpring/p/9021909.html" target="_blank" rel="noopener"> </a>)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> lis[maxn];</span><br><span class="line"><span class="keyword">int</span> len=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>,r=len,m;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        m=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(lis[m]&gt;=a[x])&#123;<span class="comment">//这里若去掉等号即为 非严格递增序列 </span></span><br><span class="line">            r=m;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            l=m+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    lis[<span class="number">1</span>]=a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;lis[len])&#123;</span><br><span class="line">            lis[++len]=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> pos=Find(i);</span><br><span class="line">            lis[pos]=a[i];<span class="comment">//同时记录了路径</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LCS问题：最长公共子序列</p><p>$dp_{i,j}$表示前缀子串中$a_{1-i}$与$b_{1-j}$的最长公共子序列，$dp_{i,j} = max({dp_{i-1,j},dp_{i,j-1},if(a_i = b_j) dp_{i-1,j-1}+1})$</p><p>$O(nlogn)$的解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,len=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> lis[maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> b[maxn];</span><br><span class="line"><span class="keyword">int</span> loc[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>,r=len,m;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        m=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(lis[m]&gt;=x)&#123;</span><br><span class="line">            r=m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  l=m+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b[i]);</span><br><span class="line">        loc[b[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        b[i]=loc[a[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n!=<span class="number">0</span>)lis[++len]=b[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i]&gt;lis[len])&#123;</span><br><span class="line">            lis[++len]=b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> pos=Find(b[i]);</span><br><span class="line">            lis[pos]=b[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="背包dp"><a href="#背包dp" class="headerlink" title="背包dp"></a>背包dp</h4><h5 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h5><p>$n$个物品放入容积为$M$的背包，第$i$个物品的容量为$v_i$，价值为$w_i$，问最大价值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="built_in">memset</span>(dp,-inf,<span class="keyword">sizeof</span> dp);</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=M; j&gt;=v[i]; j--)&#123;</span><br><span class="line">        dp[j]=max(dp[j],dp[j-v[i]]+w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=M; i++) ans=max(ans,dp[i]);</span><br></pre></td></tr></table></figure><h5 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h5><p>在01背包的基础上，每个物品是无限多的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="built_in">memset</span>(dp,-inf,<span class="keyword">sizeof</span> dp);</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=v[i]; j&lt;=M; j++)&#123;</span><br><span class="line">        dp[j]=max(dp[j],dp[j-v[i]]+w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=M; i++) ans=max(ans,dp[i]);</span><br></pre></td></tr></table></figure><h5 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h5><p>在01背包的基础上，每种物品的数量是$c_i$个。</p><p>我们将所有物品全部摊开，相当于$\sum_{i=1}^{n} {c_i}$个物品，效率不高。</p><p>我们可以使用单调队列优化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> W; <span class="comment">//总容量</span></span><br><span class="line"><span class="keyword">int</span> w[MAX_N]; <span class="comment">//每种物品的容量</span></span><br><span class="line"><span class="keyword">int</span> v[MAX_N]; <span class="comment">//每种物品的价值</span></span><br><span class="line"><span class="keyword">int</span> m[MAX_N]; <span class="comment">//每种物品的数量</span></span><br><span class="line"><span class="keyword">int</span> dp[MAX_N+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> deq[MAX_N+<span class="number">1</span>];<span class="comment">//双端队列，保存下标</span></span><br><span class="line"><span class="keyword">int</span> deqv[MAX_N+<span class="number">1</span>];<span class="comment">//双端队列，保存值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>;a&lt;w[i];a++)&#123;<span class="comment">//把每个分组都打一遍</span></span><br><span class="line">            <span class="keyword">int</span> s=<span class="number">0</span>;<span class="comment">//初始化双端队列头尾</span></span><br><span class="line">            <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j*w[i]+a&lt;=W;j++)&#123;<span class="comment">//每组第j个元素</span></span><br><span class="line">                <span class="keyword">int</span> val=dp[j*w[i]+a]-j*v[i];</span><br><span class="line">                <span class="keyword">while</span>(s&lt;t &amp;&amp; deqv[t<span class="number">-1</span>]&lt;=val)<span class="comment">//直到不改变单调性</span></span><br><span class="line">                    t--;</span><br><span class="line">                deq[t]=j;</span><br><span class="line">                deqv[t]=val;</span><br><span class="line">                t++;</span><br><span class="line">                <span class="comment">//利用队头求出dp</span></span><br><span class="line">                dp[j*w[i]+a]=deqv[s]+j*v[i];</span><br><span class="line">                <span class="keyword">if</span>(deq[s]==j-m[i])s++;<span class="comment">//检查过期</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h5><p>给定$n$组物品，第$i$组有$c_i$个物品，第$i$组的第$j$个物品的体积为$v_{i,j}$，价值为$w_{i,j}$，容积$M$的背包，求装得下的最大价值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="built_in">memset</span>(dp,-inf,<span class="keyword">sizeof</span> dp);</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=M; j&gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=c[i]; k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=v[i][k]) dp[j]=max(dp[j],dp[j-v[i][k]]+w[i][k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=M; i++) ans=max(ans,dp[i]);</span><br></pre></td></tr></table></figure><h4 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">20</span>];</span><br><span class="line">ll dp[<span class="number">20</span>][state];<span class="comment">//不同题目状态不同</span></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos,<span class="comment">/*state变量*/</span>,<span class="keyword">bool</span> lead<span class="comment">/*前导零*/</span>,<span class="keyword">bool</span> limit<span class="comment">/*数位上界变量*/</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//不是每个题都要判断前导零</span></span><br><span class="line">    <span class="comment">//递归边界，既然是按位枚举，最低位是0，那么pos==-1说明这个数我枚举完了</span></span><br><span class="line">    <span class="keyword">if</span>(pos==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">/*这里一般返回1，表示你枚举的这个数是合法的，</span></span><br><span class="line"><span class="comment">        那么这里就需要你在枚举时必须每一位都要满足题目条件，</span></span><br><span class="line"><span class="comment">        也就是说当前枚举到pos位，一定要保证前面已经枚举的数位是合法的。</span></span><br><span class="line"><span class="comment">        不过具体题目不同或者写法不同的话不一定要返回1 */</span></span><br><span class="line">    <span class="comment">//第二个就是记忆化(在此前可能不同题目还能有一些剪枝)</span></span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; !lead &amp;&amp; dp[pos][state]!=<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[pos][state];</span><br><span class="line">    <span class="keyword">int</span> up=limit?a[pos]:<span class="number">9</span>;<span class="comment">//根据limit判断枚举的上界up;这个的例子前面用213讲过了</span></span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//开始计数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=up; i++)&#123; <span class="comment">//枚举，然后把不同情况的个数加到ans就可以了</span></span><br><span class="line">        <span class="keyword">if</span>()</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>()</span><br><span class="line">                ...</span><br><span class="line">                ans+=dfs(pos<span class="number">-1</span>,<span class="comment">/*状态转移*/</span>,lead &amp;&amp; i==<span class="number">0</span>,limit &amp;&amp; i==a[pos]) <span class="comment">//最后两个变量传参都是这样写的</span></span><br><span class="line">                     <span class="comment">/*这里还算比较灵活，不过做几个题就觉得这里也是套路了</span></span><br><span class="line"><span class="comment">                     大概就是说，我当前数位枚举的数是i，然后根据题目的约束条件分类讨论</span></span><br><span class="line"><span class="comment">                     去计算不同情况下的个数，还有要根据state变量来保证i的合法性，比如题目</span></span><br><span class="line"><span class="comment">                     要求数位上不能有62连续出现,那么就是state就是要保存前一位pre,然后分类，</span></span><br><span class="line"><span class="comment">                     前一位如果是6那么这意味就不能是2，这里一定要保存枚举的这个数是合法*/</span></span><br><span class="line">            &#125;</span><br><span class="line">    <span class="comment">//计算完，记录状态</span></span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; !lead)</span><br><span class="line">        dp[pos][state]=ans;</span><br><span class="line">    <span class="comment">/*这里对应上面的记忆化，在一定条件下时记录，保证一致性，当然如果约束条件不需要考虑lead，这里就是lead就完全不用考虑了*/</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;<span class="comment">//把数位都分解出来</span></span><br><span class="line">        a[pos++]=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(pos<span class="number">-1</span><span class="comment">/*从最高位开始枚举*/</span>,<span class="comment">/*一系列状态 */</span>,<span class="literal">true</span>,<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//刚开始最高位都是有限制并且有前导零的，显然比最高位还要高的一位视为0嘛</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll le,ri;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;le,&amp;ri))&#123;</span><br><span class="line">        <span class="comment">//初始化dp数组为-1,这里还有更加优美的优化,后面讲</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,solve(ri)-solve(le<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dp[i][i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>; len&lt;=n; len++)&#123;<span class="comment">//长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j=i+len<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;n) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=i; k&lt;j; k++)&#123;<span class="comment">//枚举断点</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="树形dp"><a href="#树形dp" class="headerlink" title="树形dp"></a>树形dp</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求树的直径和第二长的路径</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,next,v;</span><br><span class="line">&#125;edges[MAXN*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> dp[MAXN][<span class="number">3</span>],ecnt,head[MAXN],N,x,y;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    edges[++ecnt].to=to;</span><br><span class="line">    edges[ecnt].next=head[from];</span><br><span class="line">    edges[ecnt].v=x;</span><br><span class="line">    head[from]=ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    ecnt=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> par)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[root]; i!=<span class="number">0</span>; i=edges[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> son=edges[i].to;</span><br><span class="line">        <span class="keyword">if</span>(son!=par)&#123;</span><br><span class="line">            dfs(son,root);</span><br><span class="line">            <span class="keyword">if</span>(dp[son][<span class="number">0</span>]+edges[i].v &gt;= dp[root][<span class="number">0</span>])&#123;</span><br><span class="line">                dp[root][<span class="number">1</span>]=dp[root][<span class="number">0</span>];</span><br><span class="line">                dp[root][<span class="number">0</span>]=dp[son][<span class="number">0</span>]+edges[i].v;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> dp[root][<span class="number">1</span>]=max(dp[root][<span class="number">1</span>],dp[son][<span class="number">0</span>]+edges[i].v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="斜率优化dp"><a href="#斜率优化dp" class="headerlink" title="斜率优化dp"></a>斜率优化dp</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HDU3507</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">500005</span>];</span><br><span class="line"><span class="keyword">int</span> q[<span class="number">500005</span>];</span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">500005</span>];</span><br><span class="line"><span class="keyword">int</span> head,tail,n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDP</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dp[j]+m+(sum[i]-sum[j])*(sum[i]-sum[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getUP</span><span class="params">(<span class="keyword">int</span> j,<span class="keyword">int</span> k)</span></span>&#123;   <span class="comment">//yj-yk的部分</span></span><br><span class="line">    <span class="keyword">return</span> dp[j]+sum[j]*sum[j]-(dp[k]+sum[k]*sum[k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDOWN</span><span class="params">(<span class="keyword">int</span> j,<span class="keyword">int</span> k)</span></span>&#123;  <span class="comment">//xj-xk的部分</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*(sum[j]-sum[k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;sum[i]);</span><br><span class="line">        sum[<span class="number">0</span>]=dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">            sum[i]+=sum[i<span class="number">-1</span>];</span><br><span class="line">        head=tail=<span class="number">0</span>;</span><br><span class="line">        q[tail++]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(head+<span class="number">1</span>&lt;tail &amp;&amp;</span><br><span class="line">            getUP(q[head+<span class="number">1</span>],q[head])&lt;=</span><br><span class="line">            sum[i]*getDOWN(q[head+<span class="number">1</span>],q[head]))</span><br><span class="line">                head++;</span><br><span class="line">            dp[i]=getDP(i,q[head]);</span><br><span class="line">            <span class="keyword">while</span>(head+<span class="number">1</span>&lt;tail &amp;&amp;</span><br><span class="line">            getUP(i,q[tail<span class="number">-1</span>])*getDOWN(q[tail<span class="number">-1</span>],q[tail<span class="number">-2</span>])&lt;=</span><br><span class="line">            getUP(q[tail<span class="number">-1</span>],q[tail<span class="number">-2</span>])*getDOWN(i,q[tail<span class="number">-1</span>]))</span><br><span class="line">                tail--;</span><br><span class="line">            q[tail++]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h3><h4 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h4><h5 id="Dijkstra（堆优化）"><a href="#Dijkstra（堆优化）" class="headerlink" title="Dijkstra（堆优化）"></a>Dijkstra（堆优化）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val,id;</span><br><span class="line">    node(<span class="keyword">int</span> id,<span class="keyword">int</span> val):id(id),val(val) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node &amp;hs)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val&gt;hs.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to,w;</span><br><span class="line">&#125;e[maxm*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn],cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++cnt]=edge&#123;head[u],v,w&#125;;</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[maxn],vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> from)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dis[i]=INF;</span><br><span class="line">        vis[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    priority_queue&lt;node&gt;q;</span><br><span class="line">    q.push(node(from,<span class="number">0</span>));</span><br><span class="line">    dis[from]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> cur=q.top().id;</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis[cur])<span class="keyword">continue</span>;</span><br><span class="line">        vis[cur]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[cur]; i ; i=e[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dis[cur]+e[i].w &lt; dis[v])&#123;</span><br><span class="line">                dis[v]=dis[cur]+e[i].w;</span><br><span class="line">                q.push(node(v,dis[v]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="网络流Dinic算法"><a href="#网络流Dinic算法" class="headerlink" title="网络流Dinic算法"></a>网络流Dinic算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">50100</span>;<span class="comment">//点的数量</span></span><br><span class="line"><span class="keyword">const</span> ll maxm = <span class="number">60010</span>*<span class="number">2</span>;<span class="comment">//边的数量，一般为maxn*maxn</span></span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    ll to, next;</span><br><span class="line">    ll w;</span><br><span class="line">    edge()&#123;&#125;</span><br><span class="line">    edge(ll to, ll next, ll w) : to(to), next(next), w(w)&#123;&#125;</span><br><span class="line">&#125;e[maxm];</span><br><span class="line">ll head[maxn], d[maxn], num, n, m;</span><br><span class="line">ll st, ed, cur[maxn];</span><br><span class="line">ll N,M;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll u, ll v, ll w)</span></span>&#123;</span><br><span class="line">    e[num] = edge(v, head[u], w);head[u] = num++;</span><br><span class="line">    e[num] = edge(u, head[v], <span class="number">0</span>);head[v] = num++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    d[st] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    q.push(st);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        ll u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(ll i=head[u]; i!=<span class="number">-1</span>; i=e[i].next)&#123;</span><br><span class="line">            ll v = e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(e[i].w == <span class="number">0</span> || d[v] &gt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            d[v] = d[u] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(v == ed) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll u, ll <span class="built_in">exp</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == ed || !<span class="built_in">exp</span>) <span class="keyword">return</span> <span class="built_in">exp</span>;</span><br><span class="line">    ll flow=<span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span>(ll &amp; i =cur[u];i!=<span class="number">-1</span>;i=e[i].next)&#123;</span><br><span class="line">        ll v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(d[v] == d[u] + <span class="number">1</span> &amp;&amp; (f=dfs(v, min(<span class="built_in">exp</span>, e[i].w))))&#123;</span><br><span class="line">            e[i].w -= f;</span><br><span class="line">            e[i^<span class="number">1</span>].w += f;</span><br><span class="line">            flow += f;</span><br><span class="line">            <span class="built_in">exp</span> -= f;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">exp</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(bfs())&#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(cur, head, <span class="keyword">sizeof</span> head);</span><br><span class="line">        <span class="keyword">while</span>(ll d=dfs(st, inf))</span><br><span class="line">            ans += d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h4><h5 id="区间操作"><a href="#区间操作" class="headerlink" title="区间操作"></a>区间操作</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l,mid,rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid+1,r,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> intmid  int mid = (l+r)&gt;&gt;1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line">ll sum[maxn&lt;&lt;<span class="number">2</span>],cur[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    sum[rt] = sum[rt&lt;&lt;<span class="number">1</span>] + sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur[rt])&#123;</span><br><span class="line">        intmid;</span><br><span class="line">        cur[rt&lt;&lt;<span class="number">1</span>]  += cur[rt];</span><br><span class="line">        cur[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+= cur[rt];</span><br><span class="line">        sum[rt&lt;&lt;<span class="number">1</span>]  += (mid-l+<span class="number">1</span>)*cur[rt];</span><br><span class="line">        sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+= (r-mid)*cur[rt];</span><br><span class="line">        cur[rt]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    intmid;cur[rt]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;sum[rt]);<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    build(lson);</span><br><span class="line">    build(rson);</span><br><span class="line">    push_up(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> ll,<span class="keyword">int</span> rr,<span class="keyword">int</span> val,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    intmid;</span><br><span class="line">    <span class="keyword">if</span>( ll&lt;=l &amp;&amp; rr&gt;=r )&#123;</span><br><span class="line">        cur[rt]+=val;</span><br><span class="line">        sum[rt]+=(r-l+<span class="number">1</span>)*val;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(l,r,rt);</span><br><span class="line">    <span class="keyword">if</span>(ll&lt;=mid)update(ll,rr,val,lson);</span><br><span class="line">    <span class="keyword">if</span>(rr&gt;mid)update(ll,rr,val,rson);</span><br><span class="line">    push_up(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> ll,<span class="keyword">int</span> rr,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ll&lt;=l &amp;&amp; rr&gt;=r) <span class="keyword">return</span> sum[rt];</span><br><span class="line">    push_down(l,r,rt);</span><br><span class="line">    intmid;</span><br><span class="line">    <span class="keyword">if</span>(ll&lt;=mid) ret += query(ll,rr,lson);</span><br><span class="line">    <span class="keyword">if</span>(rr&gt;mid) ret += query(ll,rr,rson);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>,s,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'C'</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;c);</span><br><span class="line">            update(a,b,c,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,query(a,b,<span class="number">1</span>,n,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="二维线段树-HDU1823"><a href="#二维线段树-HDU1823" class="headerlink" title="二维线段树(HDU1823)"></a>二维线段树(<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1823" target="_blank" rel="noopener">HDU1823</a>)</h5><p>求二维区间的最大值（最小值）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, m, rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">int</span> n, s[<span class="number">1005</span>][<span class="number">4005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subBuild</span><span class="params">(<span class="keyword">int</span> xrt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    s[xrt][rt] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l != r) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        subBuild(xrt, lson);</span><br><span class="line">        subBuild(xrt, rson);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    subBuild(rt, <span class="number">0</span>, n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(l != r) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        build(lson);</span><br><span class="line">        build(rson);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subUpdate</span><span class="params">(<span class="keyword">int</span> xrt, <span class="keyword">int</span> y, <span class="keyword">int</span> c, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r &amp;&amp; l == y) s[xrt][rt] = max(s[xrt][rt], c);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(y &lt;= m) subUpdate(xrt, y, c, lson);</span><br><span class="line">        <span class="keyword">else</span> subUpdate(xrt, y, c, rson);</span><br><span class="line">        s[xrt][rt] = max(s[xrt][rt &lt;&lt; <span class="number">1</span>], s[xrt][rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    subUpdate(rt, y, c, <span class="number">0</span>, n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(l != r) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= m) update(x, y, c, lson);</span><br><span class="line">        <span class="keyword">else</span> update(x, y, c, rson);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subQuery</span><span class="params">(<span class="keyword">int</span> xrt, <span class="keyword">int</span> yl, <span class="keyword">int</span> yr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(yl &lt;= l &amp;&amp; r &lt;= yr) <span class="keyword">return</span> s[xrt][rt];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(yl &lt;= m) res = subQuery(xrt, yl, yr, lson);</span><br><span class="line">        <span class="keyword">if</span>(yr &gt; m) res = max(res, subQuery(xrt, yl, yr, rson));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> xl, <span class="keyword">int</span> xr, <span class="keyword">int</span> yl, <span class="keyword">int</span> yr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xl &lt;= l &amp;&amp; r &lt;= xr) <span class="keyword">return</span> subQuery(rt, yl, yr, <span class="number">0</span>, n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(xl &lt;= m) res = query(xl, xr, yl, yr, lson);</span><br><span class="line">        <span class="keyword">if</span>(xr &gt; m) res = max(res, query(xl, xr, yl, yr, rson));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t) &amp;&amp; t) &#123;</span><br><span class="line">        n = <span class="number">1000</span>;</span><br><span class="line">        build(<span class="number">100</span>, <span class="number">200</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">int</span> a, b;</span><br><span class="line">            <span class="keyword">double</span> c, d;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, ch);</span><br><span class="line">            <span class="keyword">if</span>(ch[<span class="number">0</span>] == <span class="string">'I'</span>) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%lf%lf"</span>, &amp;a, &amp;c, &amp;d);</span><br><span class="line">                update(a, c * <span class="number">10</span>, d * <span class="number">10</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d%lf%lf"</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line">                <span class="keyword">int</span> cc = c * <span class="number">10</span>, dd = d * <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">if</span>(a &gt; b) swap(a, b);</span><br><span class="line">                <span class="keyword">if</span>(cc &gt; dd) swap(cc, dd);</span><br><span class="line">                <span class="keyword">int</span> ans = query(a, b, cc, dd, <span class="number">100</span>, <span class="number">200</span>, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(ans == <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%.1f\n"</span>, ans / <span class="number">10.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="势能线段树"><a href="#势能线段树" class="headerlink" title="势能线段树"></a>势能线段树</h5><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4695" target="_blank" rel="noopener">BZOJ4695</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.给一个区间[L,R] 加上一个数x </span></span><br><span class="line"><span class="comment">//2.把一个区间[L,R] 里小于x 的数变成x </span></span><br><span class="line"><span class="comment">//3.把一个区间[L,R] 里大于x 的数变成x </span></span><br><span class="line"><span class="comment">//4.求区间[L,R] 的和</span></span><br><span class="line"><span class="comment">//5.求区间[L,R] 的最大值</span></span><br><span class="line"><span class="comment">//6.求区间[L,R] 的最小值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 600005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (o&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson (o&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 1&lt;&lt;30</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f=<span class="number">1</span>,x=<span class="number">0</span>;<span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">do</span>&#123;ch=getchar();<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=<span class="number">-1</span>;&#125;<span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>);</span><br><span class="line">    <span class="keyword">do</span>&#123;x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>;ch=getchar();&#125;<span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>);</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Segment-Tree-Beats!</span></span><br><span class="line"><span class="keyword">int</span> maxv[N&lt;&lt;<span class="number">2</span>],seca[N&lt;&lt;<span class="number">2</span>],cnta[N&lt;&lt;<span class="number">2</span>],minv[N&lt;&lt;<span class="number">2</span>],seci[N&lt;&lt;<span class="number">2</span>],cnti[N&lt;&lt;<span class="number">2</span>],tagv[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">ll sumv[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> o)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> l=o&lt;&lt;<span class="number">1</span>,r=o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;sumv[o]=sumv[l]+sumv[r];</span><br><span class="line">  <span class="keyword">if</span>(maxv[l]==maxv[r])maxv[o]=maxv[l],cnta[o]=cnta[l]+cnta[r],seca[o]=max(seca[l],seca[r]);</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(maxv[l]&gt;maxv[r]) swap(l,r);maxv[o]=maxv[r]; cnta[o]=cnta[r];seca[o]=max(seca[r],maxv[l]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(minv[l]==minv[r])</span><br><span class="line">    minv[o]=minv[l],cnti[o]=cnti[l]+cnti[r],seci[o]=min(seci[l],seci[r]);</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(minv[l]&lt;minv[r]) swap(l,r);minv[o]=minv[r]; cnti[o]=cnti[r];seci[o]=min(seci[r],minv[l]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">puttag</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    tagv[o]+=v;sumv[o]+=(ll)(r-l+<span class="number">1</span>)*v;</span><br><span class="line">    minv[o]+=v;maxv[o]+=v;seca[o]+=v;seci[o]+=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">tmax</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    sumv[o]+=(ll)(cnti[o])*(v-minv[o]);</span><br><span class="line">    minv[o]=v;maxv[o]=max(v,maxv[o]);</span><br><span class="line">    <span class="keyword">if</span>(minv[o]==maxv[o])&#123;</span><br><span class="line">        sumv[o]=<span class="number">1L</span>L*(r-l+<span class="number">1</span>)*v;cnta[o]=cnti[o]=r-l+<span class="number">1</span>;seca[o]=-inf;seci[o]=inf;</span><br><span class="line">    &#125;<span class="keyword">else</span> seca[o]=max(v,seca[o]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">tmin</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    sumv[o]-=(ll)(cnta[o])*(maxv[o]-v);</span><br><span class="line">    maxv[o]=v;minv[o]=min(v,minv[o]);</span><br><span class="line">    <span class="keyword">if</span>(maxv[o]==minv[o])&#123;</span><br><span class="line">        sumv[o]=(ll)(r-l+<span class="number">1</span>)*v;cnta[o]=cnti[o]=r-l+<span class="number">1</span>;seca[o]=-inf;seci[o]=inf;</span><br><span class="line">    &#125;<span class="keyword">else</span> seci[o]=min(v,seci[o]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tagv[o])&#123;</span><br><span class="line">        puttag(lson,l,mid,tagv[o]);puttag(rson,mid+<span class="number">1</span>,r,tagv[o]);</span><br><span class="line">        tagv[o]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(maxv[lson]&gt;maxv[o]&amp;&amp;seca[lson]&lt;maxv[o])tmin(lson,l,mid,maxv[o]);</span><br><span class="line">    <span class="keyword">if</span>(maxv[rson]&gt;maxv[o]&amp;&amp;seca[rson]&lt;maxv[o])tmin(rson,mid+<span class="number">1</span>,r,maxv[o]);</span><br><span class="line">    <span class="keyword">if</span>(minv[lson]&lt;minv[o]&amp;&amp;seci[lson]&gt;minv[o])tmax(lson,l,mid,minv[o]);</span><br><span class="line">    <span class="keyword">if</span>(minv[rson]&lt;minv[o]&amp;&amp;seci[rson]&gt;minv[o])tmax(rson,mid+<span class="number">1</span>,r,minv[o]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    tagv[o]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=read();</span><br><span class="line">        sumv[o]=maxv[o]=minv[o]=x;cnta[o]=cnti[o]=<span class="number">1</span>;seca[o]=-inf;seci[o]=inf;tagv[o]=<span class="number">0</span>;<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(lson,l,mid);build(rson,mid+<span class="number">1</span>,r);</span><br><span class="line">    pushup(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changemax</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ql,<span class="keyword">int</span> qr,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(minv[o]&gt;=v)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr&amp;&amp;v&lt;seci[o])&#123;tmax(o,l,r,v);<span class="keyword">return</span>;&#125;</span><br><span class="line">    pushdown(o,l,r);<span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=mid)changemax(lson,l,mid,ql,qr,v);</span><br><span class="line">    <span class="keyword">if</span>(qr&gt;mid)changemax(rson,mid+<span class="number">1</span>,r,ql,qr,v);</span><br><span class="line">    pushup(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changemin</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ql,<span class="keyword">int</span> qr,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(maxv[o]&lt;=v)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr&amp;&amp;v&gt;seca[o])&#123;tmin(o,l,r,v);<span class="keyword">return</span>;&#125;</span><br><span class="line">    pushdown(o,l,r);<span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=mid)changemin(lson,l,mid,ql,qr,v);</span><br><span class="line">    <span class="keyword">if</span>(qr&gt;mid)changemin(rson,mid+<span class="number">1</span>,r,ql,qr,v);</span><br><span class="line">    pushup(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ql,<span class="keyword">int</span> qr,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)&#123;puttag(o,l,r,v);<span class="keyword">return</span>;&#125;</span><br><span class="line">    pushdown(o,l,r);<span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=mid)add(lson,l,mid,ql,qr,v);</span><br><span class="line">    <span class="keyword">if</span>(qr&gt;mid)add(rson,mid+<span class="number">1</span>,r,ql,qr,v);</span><br><span class="line">    pushup(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">querymax</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ql,<span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)<span class="keyword">return</span> maxv[o];</span><br><span class="line">    pushdown(o,l,r);<span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,ans=-inf;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=mid)ans=max(ans,querymax(lson,l,mid,ql,qr));</span><br><span class="line">    <span class="keyword">if</span>(qr&gt;mid)ans=max(ans,querymax(rson,mid+<span class="number">1</span>,r,ql,qr));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">querymin</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ql,<span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)<span class="keyword">return</span> minv[o];</span><br><span class="line">    pushdown(o,l,r);<span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,ans=inf;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=mid)ans=min(ans,querymin(lson,l,mid,ql,qr));</span><br><span class="line">    <span class="keyword">if</span>(qr&gt;mid)ans=min(ans,querymin(rson,mid+<span class="number">1</span>,r,ql,qr));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">querysum</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ql,<span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)<span class="keyword">return</span> sumv[o];</span><br><span class="line">    pushdown(o,l,r);<span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=mid)ans+=querysum(lson,l,mid,ql,qr);</span><br><span class="line">    <span class="keyword">if</span>(qr&gt;mid)ans+=querysum(rson,mid+<span class="number">1</span>,r,ql,qr);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//End of Segment Tree</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read();build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">int</span> T=read();</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">int</span> opt=read(),l=read(),r=read(),v;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">1</span>)v=read(),add(<span class="number">1</span>,<span class="number">1</span>,n,l,r,v);</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">2</span>)v=read(),changemax(<span class="number">1</span>,<span class="number">1</span>,n,l,r,v);</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">3</span>)v=read(),changemin(<span class="number">1</span>,<span class="number">1</span>,n,l,r,v);</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">4</span>)<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,querysum(<span class="number">1</span>,<span class="number">1</span>,n,l,r));</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">5</span>)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,querymax(<span class="number">1</span>,<span class="number">1</span>,n,l,r));</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">6</span>)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,querymin(<span class="number">1</span>,<span class="number">1</span>,n,l,r));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=5312" target="_blank" rel="noopener">BZOJ5312</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1，给出l,r,x，将序列l,r之间的所有数都 and x</span></span><br><span class="line"><span class="comment">//2，给出l,r,x，将序列l,r之间的所有数都 or x</span></span><br><span class="line"><span class="comment">//3，给出l,r，询问l,r之间的最大值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=(<span class="number">1</span>&lt;&lt;<span class="number">21</span>)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X=<span class="number">0</span>,w=<span class="number">0</span>;<span class="keyword">char</span> ch=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;w|=ch==<span class="string">'-'</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))X=(X&lt;&lt;<span class="number">3</span>)+(X&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> w?-X:X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,b[N],mx[N*<span class="number">4</span>],ran[N*<span class="number">4</span>],ror[N*<span class="number">4</span>],lza[N*<span class="number">4</span>],lzo[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">upt</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    mx[a]=max(mx[a&lt;&lt;<span class="number">1</span>],mx[a&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">    ran[a]=ran[a&lt;&lt;<span class="number">1</span>]&amp;ran[a&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">    ror[a]=ror[a&lt;&lt;<span class="number">1</span>]|ror[a&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    lza[a]=INF,lzo[a]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">    mx[a]=b[l];ran[a]=b[l];ror[a]=b[l];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(a&lt;&lt;<span class="number">1</span>,l,mid);build(a&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    upt(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ls=a&lt;&lt;<span class="number">1</span>,rs=a&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(lzo[a]!=<span class="number">0</span>)&#123;</span><br><span class="line">    mx[ls]|=lzo[a];mx[rs]|=lzo[a];</span><br><span class="line">    ran[ls]|=lzo[a];ran[rs]|=lzo[a];</span><br><span class="line">    ror[ls]|=lzo[a];ror[rs]|=lzo[a];</span><br><span class="line">    lza[ls]|=lzo[a];lza[rs]|=lzo[a];</span><br><span class="line">    lzo[ls]|=lzo[a];lzo[rs]|=lzo[a];</span><br><span class="line">    lzo[a]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(lza[a]!=INF)&#123;</span><br><span class="line">    mx[ls]&amp;=lza[a];mx[rs]&amp;=lza[a];</span><br><span class="line">    ran[ls]&amp;=lza[a];ran[rs]&amp;=lza[a];</span><br><span class="line">    ror[ls]&amp;=lza[a];ror[rs]&amp;=lza[a];</span><br><span class="line">    lza[ls]&amp;=lza[a];lza[rs]&amp;=lza[a];</span><br><span class="line">    lza[a]=INF;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mdy</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> l1,<span class="keyword">int</span> r1,<span class="keyword">int</span> x,<span class="keyword">bool</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;l1||r1&lt;l)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(l1&lt;=l&amp;&amp;r&lt;=r1&amp;&amp;(!((ran[a]^ror[a])&amp;x)))&#123;</span><br><span class="line">    <span class="keyword">if</span>(!k)&#123;mx[a]&amp;=x;ran[a]&amp;=x;ror[a]&amp;=x;lza[a]&amp;=x;&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;mx[a]|=x;ran[a]|=x;ror[a]|=x;lza[a]|=x;lzo[a]|=x;&#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    push(a);</span><br><span class="line">    mdy(a&lt;&lt;<span class="number">1</span>,l,mid,l1,r1,x,k);mdy(a&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,l1,r1,x,k);</span><br><span class="line">    upt(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> l1,<span class="keyword">int</span> r1)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;l1||r1&lt;l)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l1&lt;=l&amp;&amp;r&lt;=r1)<span class="keyword">return</span> mx[a];</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    push(a);</span><br><span class="line">    <span class="keyword">return</span> max(qry(a&lt;&lt;<span class="number">1</span>,l,mid,l1,r1),qry(a&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,l1,r1));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read(),m=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)b[i]=read();</span><br><span class="line">    build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    <span class="keyword">int</span> op=read(),x=read(),y=read();</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>)mdy(<span class="number">1</span>,<span class="number">1</span>,n,x,y,read(),<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">2</span>)mdy(<span class="number">1</span>,<span class="number">1</span>,n,x,y,read(),<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">3</span>)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,qry(<span class="number">1</span>,<span class="number">1</span>,n,x,y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//点权</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l,mid,rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid+1,r,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>; <span class="keyword">bool</span> f=<span class="number">0</span>; <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span> (ch&lt;<span class="string">'0'</span> || <span class="string">'9'</span>&lt;ch) f|=ch==<span class="string">'-'</span>, ch=getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="string">'0'</span>&lt;=ch &amp;&amp; ch&lt;=<span class="string">'9'</span>) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>, ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to;</span><br><span class="line">&#125;e[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn],cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    e[++cnt]=edge&#123;head[u],v&#125;;</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,root,P;</span><br><span class="line"><span class="keyword">int</span> w[maxn];</span><br><span class="line"><span class="keyword">int</span> fa[maxn],deep[maxn],siz[maxn],son[maxn],rk[maxn],top[maxn],id[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> pre,<span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">    fa[u]=pre;deep[u]=dep;siz[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v==pre)<span class="keyword">continue</span>;</span><br><span class="line">        dfs1(v,u,dep+<span class="number">1</span>);</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        <span class="keyword">if</span>(siz[v]&gt;siz[son[u]])son[u]=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    top[u]=t;id[u]=++cnt;rk[cnt]=u;</span><br><span class="line">    <span class="keyword">if</span>(!son[u])<span class="keyword">return</span>;</span><br><span class="line">    dfs2(son[u],t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v!=son[u]&amp;&amp;v!=fa[u])dfs2(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum[maxn&lt;&lt;<span class="number">2</span>],lazy[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    sum[rt]=sum[rt&lt;&lt;<span class="number">1</span>]+sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> ls,<span class="keyword">int</span> rs,<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lazy[rt])&#123;</span><br><span class="line">        <span class="keyword">int</span> val=lazy[rt];</span><br><span class="line">        sum[rt&lt;&lt;<span class="number">1</span>]=(sum[rt&lt;&lt;<span class="number">1</span>]+val*ls)%P;</span><br><span class="line">        sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+val*rs)%P;</span><br><span class="line">        lazy[rt&lt;&lt;<span class="number">1</span>]=(lazy[rt&lt;&lt;<span class="number">1</span>]+lazy[rt])%P;</span><br><span class="line">        lazy[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(lazy[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+lazy[rt])%P;</span><br><span class="line">        lazy[rt]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        sum[rt]=w[rk[l]]; <span class="comment">//重新编号后的</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(lson);</span><br><span class="line">    build(rson);</span><br><span class="line">    push_up(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> v,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">        sum[rt]=(sum[rt]+v*(r-l+<span class="number">1</span>))%P;</span><br><span class="line">        lazy[rt]=(lazy[rt]+v)%P;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    push_down(mid-l+<span class="number">1</span>,r-mid,rt);</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=mid) update(L,R,v,lson);</span><br><span class="line">    <span class="keyword">if</span>(R&gt;mid)  update(L,R,v,rson);</span><br><span class="line">    push_up(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">querysum</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">        <span class="keyword">return</span> sum[rt];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,ret=<span class="number">0</span>;</span><br><span class="line">    push_down(mid-l+<span class="number">1</span>,r-mid,rt);</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=mid) ret=(ret+querysum(L,R,lson))%P;</span><br><span class="line">    <span class="keyword">if</span>(R&gt;mid)  ret=(ret+querysum(L,R,rson))%P;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PathUpdate</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(deep[top[x]]&lt;deep[top[y]]) swap(x,y);</span><br><span class="line">        update(id[top[x]],id[x],v,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(id[x]&gt;id[y]) swap(x,y);</span><br><span class="line">    update(id[x],id[y],v,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PathQuery</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(deep[top[x]]&lt;deep[top[y]]) swap(x,y);</span><br><span class="line">        ret=(ret+querysum(id[top[x]],id[x],<span class="number">1</span>,n,<span class="number">1</span>))%P;</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(id[x]&gt;id[y])swap(x,y);</span><br><span class="line">    ret=(ret+querysum(id[x],id[y],<span class="number">1</span>,n,<span class="number">1</span>))%P;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化只需要将head和son置零</span></span><br><span class="line">    n=read(),m=read(),root=read(),P=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        w[i]=read();</span><br><span class="line">    &#125;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) head[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=read(),v=read();</span><br><span class="line">        add(u,v);</span><br><span class="line">        add(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    dfs1(root,<span class="number">0</span>,<span class="number">1</span>);  <span class="comment">//注意根节点不一定是1(一般为1就好)</span></span><br><span class="line">    dfs2(root,root);</span><br><span class="line">    build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> op=read(),x,y,z;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123; <span class="comment">//更新x-y最短路径上所有点</span></span><br><span class="line">            x=read(),y=read(),z=read();</span><br><span class="line">            PathUpdate(x,y,z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123; <span class="comment">//查询x-y最短路径上所有点</span></span><br><span class="line">            x=read(),y=read();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,PathQuery(x,y));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">3</span>)&#123; <span class="comment">//更新以x为根节点的子树</span></span><br><span class="line">            x=read(),z=read();</span><br><span class="line">            update(id[x],id[x]+siz[x]<span class="number">-1</span>,z,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">//查询以x为根节点的子树</span></span><br><span class="line">            x=read();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,querysum(id[x],id[x]+siz[x]<span class="number">-1</span>,<span class="number">1</span>,n,<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//边权版</span></span><br><span class="line"><span class="keyword">int</span> fa[maxn],deep[maxn],siz[maxn],son[maxn],rk[maxn],top[maxn],id[maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn],w[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> pre,<span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">    fa[u]=pre;deep[u]=dep;siz[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v==pre)<span class="keyword">continue</span>;</span><br><span class="line">        dis[v]=dis[u]+e[i].v;</span><br><span class="line">        dfs1(v,u,dep+<span class="number">1</span>);</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        <span class="keyword">if</span>(siz[v]&gt;siz[son[u]])son[u]=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    top[u]=t;id[u]=++cnt;rk[cnt]=u;</span><br><span class="line">    <span class="keyword">if</span>(!son[u])<span class="keyword">return</span>;</span><br><span class="line">    dfs2(son[u],t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v!=son[u]&amp;&amp;v!=fa[u])dfs2(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PathQuery</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(deep[top[x]]&lt;deep[top[y]]) swap(x,y);</span><br><span class="line">        ans=max(ans,query(id[top[x]],id[x],<span class="number">1</span>,n,<span class="number">1</span>));</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">if</span>(deep[x]&gt;deep[y]) swap(x,y);</span><br><span class="line">    ans=max(ans,query(id[son[x]],id[y],<span class="number">1</span>,n,<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PathUpdate</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(deep[top[x]]&lt;deep[top[y]]) swap(x,y);</span><br><span class="line">        update(id[top[x]],id[x],v,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(deep[x]&gt;deep[y]) swap(x,y);</span><br><span class="line">    update(id[son[x]],id[y],v,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(deep[E[i].u]&lt;deep[E[i].v]) swap(E[i].u,E[i].v);</span><br><span class="line">    w[E[i].u]=E[i].w;   <span class="comment">//边权放在下面结点上变为点权</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LCA"><a href="#LCA" class="headerlink" title="LCA"></a>LCA</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> deep[maxn],f[maxn],dis[maxn],p[maxn][<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> pre,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    deep[x]=d;</span><br><span class="line">    f[x]=pre;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> to=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(to!=pre)&#123;</span><br><span class="line">            dis[to]=dis[x]+e[i].w;</span><br><span class="line">            dfs(to,x,d+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//p[i][j]表示i结点的第2^j祖先</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;(<span class="number">1</span>&lt;&lt;j)&lt;=n;j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            p[i][j]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)p[i][<span class="number">0</span>]=f[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j)&lt;=n;j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">if</span>(p[i][j<span class="number">-1</span>]!=<span class="number">-1</span>)</span><br><span class="line">            p[i][j]=p[p[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];<span class="comment">//i的第2^j祖先就是i的第2^(j-1)祖先的第2^(j-1)祖先</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">if</span>(deep[a]&lt;deep[b])swap(a,b);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=deep[a];i++);</span><br><span class="line">    i--;</span><br><span class="line">    <span class="comment">//使a,b两点的深度相同</span></span><br><span class="line">    <span class="keyword">for</span>(j=i;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">        <span class="keyword">if</span>(deep[a]-(<span class="number">1</span>&lt;&lt;j)&gt;=deep[b])</span><br><span class="line">        a=p[a][j];</span><br><span class="line">    <span class="keyword">if</span>(a==b)<span class="keyword">return</span> a;</span><br><span class="line">    <span class="comment">//倍增法，每次向上进深度2^j，找到最近公共祖先的子结点</span></span><br><span class="line">    <span class="keyword">for</span>(j=i;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[a][j]!=<span class="number">-1</span>&amp;&amp;p[a][j]!=p[b][j])&#123;</span><br><span class="line">            a=p[a][j];</span><br><span class="line">            b=p[b][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[a];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树链剖分</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query_lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(deep[top[x]]&lt;deep[top[y]])swap(x,y);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;<span class="keyword">return</span> deep[x]&lt;deep[y]?x:y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="树分治"><a href="#树分治" class="headerlink" title="树分治"></a>树分治</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有多少对点之间的距离小于等于k</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">4e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn],siz[maxn],dep[maxn],vis[maxn],f[maxn],o[maxn];</span><br><span class="line"><span class="keyword">int</span> rt,ans,ecnt,cnt,sum,n,k;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,next,w;</span><br><span class="line">&#125;e[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    ecnt=<span class="number">0</span>;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    ans=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++ecnt].to=y;</span><br><span class="line">    e[ecnt].w=w;</span><br><span class="line">    e[ecnt].next=head[x];</span><br><span class="line">    head[x]=ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    siz[u]=<span class="number">1</span>;f[u]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u]; i; i=e[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v==fa || vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        getroot(v,u);</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        f[u]=max(f[u],siz[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    f[u]=max(f[u],sum-siz[u]);</span><br><span class="line">    <span class="keyword">if</span>(f[u] &lt; f[rt]) rt=u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getdeep</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    o[++cnt]=dep[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u]; i; i=e[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v==fa || vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        dep[v]=dep[u]+e[i].w;</span><br><span class="line">        getdeep(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    dep[u]=d;</span><br><span class="line">    getdeep(u,<span class="number">0</span>);</span><br><span class="line">    sort(o+<span class="number">1</span>,o+<span class="number">1</span>+cnt);</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>,r=cnt,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(o[l]+o[r] &lt;= k) res+=(r-l),l++;</span><br><span class="line">        <span class="keyword">else</span> r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    ans+=cal(u,<span class="number">0</span>);</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u]; i; i=e[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        ans-=cal(v,e[i].w);</span><br><span class="line">        sum=siz[v];</span><br><span class="line">        rt=<span class="number">0</span>;</span><br><span class="line">        getroot(v,<span class="number">0</span>);</span><br><span class="line">        slove(rt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x,y,w;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;x,&amp;y,&amp;w);</span><br><span class="line">            add(x,y,w);</span><br><span class="line">            add(y,x,w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">        rt=<span class="number">0</span>;</span><br><span class="line">        sum=f[<span class="number">0</span>]=n;</span><br><span class="line">        getroot(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        slove(rt);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//n个数，滑动窗口为k，求每次的最大值和最小值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> qmax[maxn],idmin[maxn];</span><br><span class="line"><span class="keyword">int</span> qmin[maxn],idmax[maxn];</span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line"><span class="keyword">int</span> hmax,tmax,hmin,tmin;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;k);</span><br><span class="line">    hmax=<span class="number">1</span>,hmin=<span class="number">1</span>;</span><br><span class="line">    tmax=<span class="number">0</span>,tmin=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line">        <span class="keyword">while</span>(hmax&lt;=tmax &amp;&amp; qmax[tmax]&lt;=a)&#123;</span><br><span class="line">            tmax--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(hmin&lt;=tmin &amp;&amp; qmin[tmin]&gt;=a)&#123;</span><br><span class="line">            tmin--;</span><br><span class="line">        &#125;</span><br><span class="line">        qmax[++tmax]=a;</span><br><span class="line">        qmin[++tmin]=a;</span><br><span class="line">        idmax[tmax]=idmin[tmin]=i;</span><br><span class="line">        <span class="keyword">while</span>(idmax[hmax]&lt;=i-k) hmax++;</span><br><span class="line">        <span class="keyword">while</span>(idmin[hmin]&lt;=i-k) hmin++;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=k) <span class="built_in">printf</span>(<span class="string">"%d%c"</span>,qmin[hmin],i&lt;n?<span class="string">' '</span>:<span class="string">'\n'</span>);</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=k) ans[cnt++]=qmax[hmax];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;cnt; i++) <span class="built_in">printf</span>(<span class="string">" %d"</span>,ans[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h4><p>最大全1矩阵问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2009</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> M[N][N];</span><br><span class="line"><span class="keyword">int</span> h[N][N];</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">int</span> s[N],L[N],R[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fin</span><span class="params">(<span class="keyword">int</span> row)</span></span>&#123;<span class="comment">//相同不出栈</span></span><br><span class="line">    s[<span class="number">0</span>]=<span class="number">0</span>;<span class="keyword">int</span> top=<span class="number">0</span>;</span><br><span class="line">    h[row][m+<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//用于得到最后没出栈元素的R</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> ar=s[top];</span><br><span class="line">        <span class="keyword">while</span>(h[row][i]&lt;h[row][ar])&#123;</span><br><span class="line">            R[ar]=i;top--;</span><br><span class="line">            ar=s[top];</span><br><span class="line">        &#125;</span><br><span class="line">        L[i]=ar;s[++top]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">if</span>(h[row][i])</span><br><span class="line">        ans=max(ans,h[row][i]*(R[i]-L[i]<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fin_</span><span class="params">(<span class="keyword">int</span> row)</span></span>&#123;<span class="comment">//相同出栈</span></span><br><span class="line">    s[<span class="number">0</span>]=<span class="number">0</span>;<span class="keyword">int</span> top=<span class="number">0</span>;</span><br><span class="line">    h[row][m+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> ar=s[top];</span><br><span class="line">        <span class="keyword">while</span>(h[row][i]&lt;=h[row][ar])&#123;</span><br><span class="line">            R[ar]=i;top--;</span><br><span class="line">            <span class="keyword">if</span>(top&lt;<span class="number">0</span>)<span class="keyword">break</span>;<span class="comment">//最后m+1的时候把s[0]也出栈了</span></span><br><span class="line">            ar=s[top];</span><br><span class="line">        &#125;</span><br><span class="line">        L[i]=ar;s[++top]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">if</span>(h[row][i])</span><br><span class="line">        ans=max(ans,h[row][i]*(R[i]-L[i]<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">关于相同元素出栈</span></span><br><span class="line"><span class="comment">假设不出栈，h[s[2]]==h[4]==2，</span></span><br><span class="line"><span class="comment">本来这个点是可以延伸到的，但是我们不出栈，</span></span><br><span class="line"><span class="comment">所以第二个数的L不准确了，但是第一个数的R准确了，</span></span><br><span class="line"><span class="comment">那么第一个数因为遇到不相同的出栈了，得到的就是准确的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果出栈的话，前面那个点的R就不准确了</span></span><br><span class="line"><span class="comment">但是接下来的相同的数的L是准确的，</span></span><br><span class="line"><span class="comment">只要遇到一个不相同的使任意一个出栈，</span></span><br><span class="line"><span class="comment">那么最后一个相同的数的R就是准确的了，</span></span><br><span class="line"><span class="comment">因此得到的还是一段准确的区间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)!=EOF)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;M[i][j]);</span><br><span class="line">                <span class="keyword">if</span>(M[i][j])h[i][j]=h[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fin(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 4</span></span><br><span class="line"><span class="comment">0 1 1 1</span></span><br><span class="line"><span class="comment">1 0 1 1</span></span><br><span class="line"><span class="comment">1 1 1 1</span></span><br><span class="line"><span class="comment">1 1 1 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求区间元素个数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn],n,m,cnt[maxn],ans=<span class="number">0</span>,anss[maxn],block;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> L,R,i;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.L/block != y.L/block) <span class="keyword">return</span> x.L/block &lt; y.L/block;</span><br><span class="line">    <span class="keyword">return</span> x.R &lt; y.R;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    cnt[a[p]]++;</span><br><span class="line">    <span class="keyword">if</span>(cnt[a[p]] == <span class="number">1</span>) ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    cnt[a[p]]--;</span><br><span class="line">    <span class="keyword">if</span>(cnt[a[p]] == <span class="number">0</span>) ans--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    block=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;q[i].L,&amp;q[i].R);</span><br><span class="line">        q[i].i=i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q+<span class="number">1</span>,q+m+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">int</span> cL=<span class="number">1</span>,cR=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> L=q[i].L,R=q[i].R;</span><br><span class="line">        <span class="keyword">while</span>(cL &lt; L) del(cL++);</span><br><span class="line">        <span class="keyword">while</span>(cL &gt; L) add(--cL);</span><br><span class="line">        <span class="keyword">while</span>(cR &lt; R) add(++cR);</span><br><span class="line">        <span class="keyword">while</span>(cR &gt; R) del(cR--);</span><br><span class="line">        anss[q[i].i]=ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,anss[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4><h5 id="字符串hash"><a href="#字符串hash" class="headerlink" title="字符串hash"></a>字符串hash</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="comment">//ull 会溢出取模</span></span><br><span class="line"><span class="keyword">const</span> ull base=<span class="number">233</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line">ull hs[maxn],p[maxn];</span><br><span class="line"><span class="function">ull <span class="title">geths</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ull)hs[r]-p[r-l+<span class="number">1</span>]*hs[l<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;maxn; i++) p[i]=p[i<span class="number">-1</span>]*base;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=len; i++)&#123;</span><br><span class="line">        hs[i]=hs[i<span class="number">-1</span>]*base+s[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="手写hash"><a href="#手写hash" class="headerlink" title="手写hash"></a>手写hash</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hash</span>&#123;</span></span><br><span class="line">    ll mod = <span class="number">2908361</span>;</span><br><span class="line">    ll cnt = <span class="number">0</span>, Head[<span class="number">2908361</span>], nxt[<span class="number">1000006</span>];</span><br><span class="line">    ll val[<span class="number">1000006</span>], pos[<span class="number">1000006</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(Head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(Head)); cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(ll x, ll v)</span></span>&#123;</span><br><span class="line">        ll key = x % mod;</span><br><span class="line">        pos[cnt] = x, val[cnt] = v, nxt[cnt] = Head[key];</span><br><span class="line">        Head[key] = cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">Find</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">        ll key = x % mod;</span><br><span class="line">        <span class="keyword">for</span>(ll i = Head[key]; ~i; i = nxt[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(pos[i] == x) <span class="keyword">return</span> val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1l</span>l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;hs;</span><br></pre></td></tr></table></figure><h4 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h4><h5 id="KMP-1"><a href="#KMP-1" class="headerlink" title="KMP"></a>KMP</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">char</span> t[maxn];</span><br><span class="line"><span class="keyword">int</span> nex[maxn],len;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    nex[<span class="number">0</span>]=j=<span class="number">-1</span>;</span><br><span class="line">    i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;m)&#123; <span class="comment">//m是t的长度</span></span><br><span class="line">        <span class="keyword">while</span>(j!=<span class="number">-1</span> &amp;&amp; t[j]!=t[i]) j=nex[j];</span><br><span class="line">        nex[++i] = ++j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)&#123; <span class="comment">//n是s的长度</span></span><br><span class="line">        <span class="keyword">while</span>(j!=<span class="number">-1</span> &amp;&amp; s[i]!=t[j]) j=nex[j];</span><br><span class="line">        i++;</span><br><span class="line">        j++;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=m) <span class="keyword">return</span> i;<span class="comment">//返回最后匹配的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定字符串，对于整个串，求最短循环节的次数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> nex[maxn],len;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    nex[<span class="number">0</span>]=j=<span class="number">-1</span>;</span><br><span class="line">    i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;len)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j!=<span class="number">-1</span> &amp;&amp; s[j]!=s[i]) j=nex[j];</span><br><span class="line">        nex[++i]=++j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s))&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">'.'</span>) <span class="keyword">break</span>;</span><br><span class="line">        len=<span class="built_in">strlen</span>(s);</span><br><span class="line">        cal();</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(len%(len-nex[len])==<span class="number">0</span>) ans=len/(len-nex[len]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="扩展KMP"><a href="#扩展KMP" class="headerlink" title="扩展KMP"></a>扩展KMP</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//next[i]表示t[i...m-1]与t[0...m-1]的最长公共前缀</span></span><br><span class="line"><span class="comment">//extend[i]表示s[i...n-1]与t[0...m-1]的最长公共前缀</span></span><br><span class="line"><span class="keyword">int</span> Next[maxn],extend[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">char</span> t[],<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    Next[<span class="number">0</span>]=m;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j+<span class="number">1</span>&lt;m&amp;&amp;t[j]==t[j+<span class="number">1</span>]) j++;</span><br><span class="line">    Next[<span class="number">1</span>]=j;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> p=Next[k]+k<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> L=Next[i-k];</span><br><span class="line">        <span class="keyword">if</span>(i+L&lt;p+<span class="number">1</span>) Next[i]=L;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            j=max(<span class="number">0</span>,p-i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(i+j&lt;m&amp;&amp;t[i+j]==t[j]) j++;</span><br><span class="line">            Next[i]=j;</span><br><span class="line">            k=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extendkmp</span><span class="params">(<span class="keyword">char</span> t[],<span class="keyword">int</span> m,<span class="keyword">char</span> s[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    getNext(t,m);</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;n&amp;&amp;j&lt;m&amp;&amp;t[j]==s[j]) j++;</span><br><span class="line">    extend[<span class="number">0</span>]=j;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> p=extend[k]+k<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> L=Next[i-k];</span><br><span class="line">        <span class="keyword">if</span>(i+L&lt;p+<span class="number">1</span>) extend[i]=L;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            j=max(<span class="number">0</span>,p-i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(i+j&lt;n&amp;&amp;j&lt;m&amp;&amp;s[i+j]==t[j]) j++;</span><br><span class="line">            extend[i]=j;</span><br><span class="line">            k=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SAM"><a href="#SAM" class="headerlink" title="SAM"></a>SAM</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxc 30</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">250000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> str[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SAM</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> len[maxn * <span class="number">2</span>], <span class="comment">//最长子串的长度(该节点字串数量=len[x]-len[link[x]])</span></span><br><span class="line">    link[maxn * <span class="number">2</span>],   <span class="comment">//后缀链接(最短串前部减少一个字符所到达的状态)</span></span><br><span class="line">    cnt[maxn * <span class="number">2</span>],    <span class="comment">//被后缀连接的数</span></span><br><span class="line">    nex[maxn * <span class="number">2</span>][maxc],  <span class="comment">//状态转移(尾部加一个字符的下一个状态)(图)</span></span><br><span class="line">    idx, <span class="comment">//节点编号</span></span><br><span class="line">    last;    <span class="comment">//最后节点</span></span><br><span class="line">    <span class="keyword">int</span> epos[maxn * <span class="number">2</span>]; <span class="comment">// enpos数（该状态子串出现数量）</span></span><br><span class="line">    <span class="keyword">int</span> a[maxn];<span class="comment">//长度为i的子串出现最大次数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;<span class="comment">//初始化</span></span><br><span class="line">        last = idx = <span class="number">1</span>; <span class="comment">//1表示root起始点 空集</span></span><br><span class="line">        link[<span class="number">1</span>] = len[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//SAM建图</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;     <span class="comment">//插入字符，为字符ascll码值</span></span><br><span class="line">        c-=<span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">int</span> x = ++idx; <span class="comment">//创建一个新节点x;</span></span><br><span class="line">        len[x] = len[last] + <span class="number">1</span>; <span class="comment">//  长度等于最后一个节点+1</span></span><br><span class="line">        epos[x] = <span class="number">1</span>;  <span class="comment">//接受节点子串除后缀连接还需加一</span></span><br><span class="line">        <span class="keyword">int</span> p;  <span class="comment">//第一个有C转移的节点;</span></span><br><span class="line">        <span class="keyword">for</span>(p = last; p &amp;&amp; !nex[p][c]; p = link[p]) </span><br><span class="line">            nex[p][c] = x;<span class="comment">//沿着后缀连接 将所有没有字符c转移的节点直接指向新节点</span></span><br><span class="line">        <span class="keyword">if</span>(!p) link[x] = <span class="number">1</span>, cnt[<span class="number">1</span>]++;  <span class="comment">//全部都没有c的转移 直接将新节点后缀连接到起点</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> q = nex[p][c];    <span class="comment">//p通过c转移到的节点</span></span><br><span class="line">            <span class="keyword">if</span> (len[p] + <span class="number">1</span> == len[q])    <span class="comment">//pq是连续的</span></span><br><span class="line">                link[x] = q, cnt[q]++; <span class="comment">//将新节点后缀连接指向q即可,q节点的被后缀连接数+1</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> nq = ++idx;   <span class="comment">//不连续 需要复制一份q节点</span></span><br><span class="line">                len[nq] = len[p] + <span class="number">1</span>;   <span class="comment">//令nq与p连续</span></span><br><span class="line">                link[nq] = link[q];   <span class="comment">//因后面link[q]改变此处不加cnt</span></span><br><span class="line">                <span class="built_in">memcpy</span>(nex[nq], nex[q], <span class="keyword">sizeof</span>(nex[q]));  <span class="comment">//复制q的信息给nq</span></span><br><span class="line">                <span class="keyword">for</span> (; p&amp;&amp;nex[p][c] == q; p = link[p])</span><br><span class="line">                    nex[p][c] = nq;    <span class="comment">//沿着后缀连接 将所有通过c转移为q的改为nq</span></span><br><span class="line">                link[q] = link[x] = nq; <span class="comment">//将x和q后缀连接改为nq</span></span><br><span class="line">                cnt[nq] += <span class="number">2</span>; <span class="comment">//  nq增加两个后缀连接</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        last=x;  <span class="comment">//更新最后处理的节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GetNpos</span><span class="params">()</span></span>&#123;<span class="comment">//求npos数，即该节点字串出现次数</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= idx; i++)</span><br><span class="line">            <span class="keyword">if</span> (!cnt[i])q.push(i);   <span class="comment">//将所有没被后缀连接指向的节点入队</span></span><br><span class="line">        <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> x = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            epos[link[x]] += epos[x]; <span class="comment">//子串数量等于所有后缀连接指向该节点的子串数量和+是否为接受节点</span></span><br><span class="line">            <span class="keyword">if</span> (--cnt[link[x]] == <span class="number">0</span>)q.push(link[x]);   <span class="comment">//当所有后缀连接指向该节点的处理完毕后再入队</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetSubNum</span><span class="params">()</span></span>&#123;<span class="comment">//求不相同字串数量</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= idx; i++) ans+=(len[i]-len[link[i]]);<span class="comment">//一状态子串数量等于len[i]-len[link[i]]</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GetSubMax</span><span class="params">()</span></span>&#123;<span class="comment">//求出所有长度为k的子串中出现次数最多的子串出现次数</span></span><br><span class="line">        GetNpos();</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">strlen</span>(str+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//printf("%d\n",n);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= idx; i++) </span><br><span class="line">            a[len[i]] = max(a[len[i]], epos[i]);<span class="comment">//长度≤k的子串中出现次数最多的子串出现次数的最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) a[i] = max(a[i], a[i + <span class="number">1</span>]);<span class="comment">//求一遍后缀最大值就是答案</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sam;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str+<span class="number">1</span>))&#123;</span><br><span class="line">        sam.init();</span><br><span class="line">        <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=len; i++) sam.add(str[i]);</span><br><span class="line">        sam.GetSubMax();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SA"><a href="#SA" class="headerlink" title="SA"></a>SA</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清巨那偷来的板子QAQ</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SuffixArray</span>&#123;</span></span><br><span class="line">    <span class="comment">// S下标从1开始,S[n+1]为0，S[1...n]非零</span></span><br><span class="line">    <span class="comment">//sa:字典序中排第i位的起始位置在str中第sa[i]</span></span><br><span class="line">    <span class="comment">//rank:就是str第i个位置的后缀是在字典序排第几</span></span><br><span class="line">    <span class="comment">//height：字典序排i和i-1的后缀的最长公共前缀</span></span><br><span class="line">    <span class="keyword">int</span> s[N&lt;&lt;<span class="number">1</span>],t[N&lt;&lt;<span class="number">1</span>],ht[N],sa[N],rk[N],p[N],c[N],w[N];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">trans</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">const</span> <span class="keyword">char</span>* S)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=*max_element(S+<span class="number">1</span>,S+<span class="number">1</span>+n);</span><br><span class="line">        <span class="built_in">memset</span>(rk,<span class="number">0</span>,(m+<span class="number">1</span>)&lt;&lt;<span class="number">2</span>); <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) rk[S[i]]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) rk[i]+=rk[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) s[i]=rk[S[i]];</span><br><span class="line">        <span class="keyword">return</span> rk[m];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ps(x) sa[w[s[x]]--]=x</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> pl(x) sa[w[s[x]]++]=x</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">radix</span><span class="params">(<span class="keyword">int</span>* v,<span class="keyword">int</span>* s,<span class="keyword">int</span>* t,<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span> n1)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(sa,<span class="number">0</span>,(n+<span class="number">1</span>)&lt;&lt;<span class="number">2</span>); <span class="built_in">memset</span>(c,<span class="number">0</span>,(m+<span class="number">1</span>)&lt;&lt;<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) ++c[s[i]];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) w[i]=c[i]+=c[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n1;i;--i) ps(v[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) w[i]=c[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(sa[i]&gt;<span class="number">1</span> &amp;&amp; t[sa[i]<span class="number">-1</span>]) pl(sa[i]<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) w[i]=c[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i;--i) <span class="keyword">if</span>(sa[i]&gt;<span class="number">1</span> &amp;&amp; !t[sa[i]<span class="number">-1</span>]) ps(sa[i]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SAIS</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span>* s,<span class="keyword">int</span>* t,<span class="keyword">int</span>* p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1=<span class="number">0</span>,ch=rk[<span class="number">1</span>]=<span class="number">0</span>,*s1=s+n; t[n]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i;--i) t[i]=s[i]==s[i+<span class="number">1</span>]?t[i+<span class="number">1</span>]:s[i]&gt;s[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) rk[i]=t[i<span class="number">-1</span>]&amp;&amp;!t[i]?(p[++n1]=i,n1):<span class="number">0</span>;</span><br><span class="line">        radix(p,s,t,n,m,n1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=n;++i) <span class="keyword">if</span>(x=rk[sa[i]])&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch&lt;=<span class="number">1</span> || p[x+<span class="number">1</span>]-p[x]!=p[y+<span class="number">1</span>]-p[y]) ++ch;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">for</span>(<span class="keyword">int</span> j=p[x],k=p[y];j&lt;=p[x+<span class="number">1</span>];++j,++k)</span><br><span class="line">                <span class="keyword">if</span>((s[j]&lt;&lt;<span class="number">1</span>|t[j])^(s[k]&lt;&lt;<span class="number">1</span>|t[k]))&#123; ++ch; <span class="keyword">break</span>; &#125;</span><br><span class="line">            s1[y=x]=ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ch&lt;n1) SAIS(n1,ch,s1,t+n,p+n1);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n1;++i) sa[s1[i]]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n1;++i) s1[i]=p[sa[i]];</span><br><span class="line">        radix(s1,s,t,n,m,n1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">const</span> <span class="keyword">char</span>* S)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=trans(++n,S);SAIS(n,m,s,t,p);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i) rk[sa[i]=sa[i+<span class="number">1</span>]]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j,k=<span class="number">0</span>;i&lt;n;++i) <span class="keyword">if</span>(rk[i]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=sa[rk[i]<span class="number">-1</span>];S[i+k]==S[j+k];++k);</span><br><span class="line">            <span class="keyword">if</span>(ht[rk[i]]=k) --k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;SA;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> S[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//注意输入和传参</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,S+<span class="number">1</span>)&amp;&amp;<span class="built_in">strcmp</span>(S+<span class="number">1</span>,<span class="string">"."</span>)!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="built_in">strlen</span>(S+<span class="number">1</span>);</span><br><span class="line">        SA.init(n,S);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SA应用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_lcs</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> mid)</span></span>&#123; <span class="comment">//mid为两串分隔位置，n为拼接后总长</span></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ht[i]&gt;ans)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sa[i]&gt;=<span class="number">1</span>&amp;&amp;sa[i]&lt;=mid&amp;&amp;sa[i<span class="number">-1</span>]&gt;=mid+<span class="number">1</span>) ans=max(ans,ht[i]);</span><br><span class="line">            <span class="keyword">if</span>(sa[i<span class="number">-1</span>]&gt;=<span class="number">1</span>&amp;&amp;sa[i<span class="number">-1</span>]&lt;=mid&amp;&amp;sa[i]&gt;=mid+<span class="number">1</span>) ans=max(ans,ht[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">get_subcnt</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">//不同子串个数</span></span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans += n-sa[i]+<span class="number">1</span>-ht[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_looplen</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">//循环节长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i) <span class="keyword">continue</span>; <span class="comment">//不能整除的话，一定不能构成循环节</span></span><br><span class="line">        <span class="keyword">if</span>(rk[<span class="number">1</span>] != rk[i+<span class="number">1</span>]+<span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">//rank数组必须要相邻才能构成循环节</span></span><br><span class="line">        <span class="keyword">if</span>(ht[rk[<span class="number">1</span>]] != n-i) <span class="keyword">continue</span>; <span class="comment">//若第一个和第二个的最长公共前缀不符合条件</span></span><br><span class="line">        <span class="keyword">return</span> n/i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pd1</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mx=SA.sa[<span class="number">1</span>],mm=SA.sa[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(SA.ht[i]&gt;=k)&#123;</span><br><span class="line">            mm=min(mm,min(SA.sa[i],SA.sa[i<span class="number">-1</span>]));</span><br><span class="line">            mx=max(mx,max(SA.sa[i],SA.sa[i<span class="number">-1</span>]));</span><br><span class="line">            <span class="keyword">if</span>(mx-mm&gt;=k) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            mx=SA.sa[i],mm=SA.sa[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get1</span><span class="params">()</span></span>&#123; <span class="comment">//不可重叠最长子串长度</span></span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>,r=n/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pd1(mid)) l=mid;</span><br><span class="line">        <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pd2</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(SA.ht[i]&gt;=x)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span>(cnt==k) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> cnt=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get2</span><span class="params">()</span></span>&#123; <span class="comment">//可重叠 出现k次最长子串长度</span></span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=n;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pd(mid)) l=mid;</span><br><span class="line">        <span class="keyword">else</span>        r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可重叠最长子串长度 = max(ht[i])</span></span><br></pre></td></tr></table></figure><h4 id="PAM"><a href="#PAM" class="headerlink" title="PAM"></a>PAM</h4><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6599" target="_blank" rel="noopener">HDU6599</a></p><p>求回文串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> ull base=<span class="number">233</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">30</span>;</span><br><span class="line">ull ans[maxn];</span><br><span class="line">ull hs[maxn],ba[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="function">ull <span class="title">gethash</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hs[r]-hs[l<span class="number">-1</span>]*ba[r-l+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lenn=r-l+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(lenn&amp;<span class="number">1</span>) <span class="keyword">return</span> gethash(l,mid)==gethash(mid,r);</span><br><span class="line">    <span class="keyword">return</span> gethash(l,mid)==gethash(mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pam</span>&#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    int nex[maxn][N],fail[maxn];//在当前状态首尾添加字符的状态,失配跳到的状态</span></span><br><span class="line"><span class="comment">    int len[maxn],S[maxn],pos[maxn];//状态i表示的回文长度,缓存池,状态对应首次出现的位置</span></span><br><span class="line"><span class="comment">    int cnt[maxn],num[maxn];//状态出现次数,以状态末尾结尾但不包含本条路径的数目</span></span><br><span class="line"><span class="comment">    int last,n,p;//上个状态,总长度,当前状态编号</span></span><br><span class="line"><span class="comment">    p-2就是本质不同的回文串的个数</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">int</span> nex[maxn][N],fail[maxn];</span><br><span class="line">    <span class="keyword">int</span> len[maxn],S[maxn],pos[maxn];</span><br><span class="line">    <span class="keyword">int</span> cnt[maxn],num[maxn];</span><br><span class="line">    <span class="keyword">int</span> last,n,p;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(nex[p],<span class="number">0</span>,<span class="keyword">sizeof</span>(nex[p]));</span><br><span class="line">        cnt[p]=num[p]=<span class="number">0</span>;</span><br><span class="line">        len[p]=i;</span><br><span class="line">        <span class="keyword">return</span> p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        p=<span class="number">0</span>;</span><br><span class="line">        newnode(<span class="number">0</span>);</span><br><span class="line">        newnode(<span class="number">-1</span>);</span><br><span class="line">        last=n=<span class="number">0</span>;</span><br><span class="line">        fail[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        S[n]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_fail</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(S[n-len[i]<span class="number">-1</span>]!=S[n]) i=fail[i];</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> po)</span></span>&#123;</span><br><span class="line">        i-=<span class="string">'a'</span>;</span><br><span class="line">        S[++n]=i;</span><br><span class="line">        <span class="keyword">int</span> cur=get_fail(last);</span><br><span class="line">        <span class="keyword">if</span>(!nex[cur][i])&#123;</span><br><span class="line">            <span class="keyword">int</span> now=newnode(len[cur]+<span class="number">2</span>);</span><br><span class="line">            pos[now]=po;</span><br><span class="line">            fail[now]=nex[get_fail(fail[cur])][i];</span><br><span class="line">            nex[cur][i]=now;</span><br><span class="line">            num[now]=num[fail[now]]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        last=nex[cur][i];</span><br><span class="line">        cnt[last]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=p<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) cnt[fail[i]]+=cnt[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;p;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("in.txt","r",stdin);</span></span><br><span class="line"><span class="comment">//    freopen("out.txt","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    ba[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;maxn; i++) ba[i]=ba[i<span class="number">-1</span>]*base;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>))&#123;</span><br><span class="line">        len=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">        p.init();</span><br><span class="line">        hs[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=len; i++)&#123;</span><br><span class="line">            p.add(s[i],i);</span><br><span class="line">            ans[i]=<span class="number">0</span>;</span><br><span class="line">            hs[i]=hs[i<span class="number">-1</span>]*base+s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        p.Count();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;p.p; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> l=(p.pos[i]-p.len[i]+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> r=p.pos[i];</span><br><span class="line">            <span class="keyword">if</span>(check(l,r)) ans[p.len[i]]+=p.cnt[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%llu"</span>,ans[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=len; i++) <span class="built_in">printf</span>(<span class="string">" %llu"</span>,ans[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Manacher"><a href="#Manacher" class="headerlink" title="Manacher"></a>Manacher</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Min(a,b) a&gt;b?b:a  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Max(a,b) a&gt;b?a:b  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="keyword">int</span> Len[<span class="number">3000005</span>];  </span><br><span class="line"><span class="keyword">char</span> str[<span class="number">3000005</span>],s[<span class="number">3000005</span>];  </span><br><span class="line"><span class="keyword">int</span> n,mx,id,len;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;  </span><br><span class="line">    str[k++] = <span class="string">'$'</span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;  </span><br><span class="line">        str[k++]=<span class="string">'#'</span>;  </span><br><span class="line">        str[k++]=s[i];  </span><br><span class="line">    &#125;  </span><br><span class="line">    str[k++]=<span class="string">'#'</span>;  </span><br><span class="line">    len=k;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Manacher</span><span class="params">()</span></span>&#123;  </span><br><span class="line">  Len[<span class="number">0</span>] = <span class="number">0</span>;  </span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;  </span><br><span class="line">  mx = <span class="number">0</span>;  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;  </span><br><span class="line">    <span class="keyword">if</span>(i &lt; mx) Len[i] = Min(mx - i, Len[<span class="number">2</span> * id - i]);  </span><br><span class="line">    <span class="keyword">else</span> Len[i] = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">while</span>(str[i - Len[i]]== str[i + Len[i]]) Len[i]++;  </span><br><span class="line">    <span class="keyword">if</span>(Len[i] + i &gt; mx)&#123;  </span><br><span class="line">      mx = Len[i] + i;  </span><br><span class="line">      id = i;  </span><br><span class="line">      sum = Max(sum, Len[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> (sum - <span class="number">1</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);  </span><br><span class="line">  <span class="keyword">while</span>(n--)&#123;  </span><br><span class="line">    <span class="built_in">memset</span>(str,<span class="number">0</span>,<span class="keyword">sizeof</span>(str));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);  </span><br><span class="line">    len = <span class="built_in">strlen</span>(s);  </span><br><span class="line">    init();  </span><br><span class="line">    <span class="keyword">int</span> temp = Manacher();  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,temp);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><h4 id="BSGS"><a href="#BSGS" class="headerlink" title="BSGS"></a>BSGS</h4><p>当$gcd(y,p)=1$，在这种情况下，有可能给定$p$为质数。设$x=a * m - b$ ，$m= \lceil \sqrt p \rceil$，$ a \in [0,m+1)$，$b \in [0,m)$，那么原式变成$y^{a * m}=z * y^{b}$，先枚举$b$，计算$z * y^{b}(mod\ p)$，存到$map$中，再枚举$a$就好了。</p><h5 id="SDOI2011"><a href="#SDOI2011" class="headerlink" title="SDOI2011"></a><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2242" target="_blank" rel="noopener">SDOI2011</a></h5><p>题意：给定$y,z,p$，计算1. $y^z (mod \ p)$；2. 满足$x * y \equiv z(mod \ p)$的最小非负整数的$x$；3.满足$y^x  \equiv  z\ (mod\ p)$的最小非负整数的$x$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll y,z,p;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll n,ll mod)</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) res=res*x%mod;</span><br><span class="line">        x=x*x%mod;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll x,ll mod)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> qpow(x,mod<span class="number">-2</span>,mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nnot</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Orz, I cannot find x!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BSGS</span><span class="params">(ll x,ll y)</span></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;ll,ll&gt;pw;</span><br><span class="line">    <span class="keyword">if</span>(y == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">-1</span>, m = <span class="built_in">sqrt</span>(p) + <span class="number">1</span>, xx, s = y;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        pw[s] = i;</span><br><span class="line">        s = s * x % p;</span><br><span class="line">    &#125;</span><br><span class="line">    xx = qpow(x, m, p), s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; ++i)&#123;</span><br><span class="line">        s = s * xx % p;</span><br><span class="line">        <span class="keyword">if</span>(pw.count(s))&#123;</span><br><span class="line">            ans = i * m - pw[s];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans &lt; <span class="number">0</span>) nnot();</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll t,op;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;t,&amp;op);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>,&amp;y,&amp;z,&amp;p);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,qpow(y,z,p));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>)&#123;</span><br><span class="line">            ll tm=y%p;</span><br><span class="line">            <span class="keyword">if</span>(tm==<span class="number">0</span> &amp;&amp; z%p!=<span class="number">0</span>)&#123;</span><br><span class="line">                nnot();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,z*inv(y,p)%p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(y%p) BSGS(y,z);</span><br><span class="line">            <span class="keyword">else</span> nnot();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当$gcd(y,p) \neq 1$时，就要用到$exgcd$理论。</p><p>将原式写成$y * y^{x-1}+k * p=z,k \in Z$，根据$exgcd$，当$d=gcd(y,p)$不是$z$的约数就不会有解，有：$$\frac{y}{d} * y^{x-1}+k * \frac{p}{d}=\frac{z}{d}$$</p><p>一直递归直到$d=1$，设之间的所有的$d$的乘积为$g$，递归$c$次，令$x’=x-c\ ,\ p’=\frac{p}{g}\ ,\ z=\frac{z}{g}$，$y^{x’} * \frac{y^c}{g} \equiv z’(mod \ p’)$</p><p>然后再用BSGS求解。</p><h5 id="SPOJMOD-Power-Modulo-Inverted"><a href="#SPOJMOD-Power-Modulo-Inverted" class="headerlink" title="SPOJMOD Power Modulo Inverted"></a><a href="http://www.spoj.com/problems/MOD/" target="_blank" rel="noopener">SPOJMOD Power Modulo Inverted</a></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll y,z,p;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll n,ll mod)</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) res=res*x%mod;</span><br><span class="line">        x=x*x%mod;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll x,ll y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (y==<span class="number">0</span>)?x:gcd(y,x%y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">exBSGS</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(z==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;ll,ll&gt;pw;</span><br><span class="line">    ll cnt=<span class="number">0</span>,mul=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll d=gcd(y,p); d!=<span class="number">1</span>; d=gcd(y,p))&#123;</span><br><span class="line">        <span class="keyword">if</span>(z%d) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        ++cnt,z/=d,p/=d,mul=(mul*y/d%p);</span><br><span class="line">        <span class="keyword">if</span>(z == mul) <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    ll s=z,m=<span class="built_in">sqrt</span>(p)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">        pw[s]=i;</span><br><span class="line">        s=s*y%p;</span><br><span class="line">    &#125;</span><br><span class="line">    ll x=qpow(y,m,p);</span><br><span class="line">    s=mul;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>; i&lt;=m; i++)&#123;</span><br><span class="line">        s=s*x%p;</span><br><span class="line">        <span class="keyword">if</span>(pw.count(s)) <span class="keyword">return</span> i*m-pw[s]+cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>,&amp;y,&amp;p,&amp;z)&amp;&amp;(y||z||p))&#123;</span><br><span class="line">        y%=p;</span><br><span class="line">        z%=p;</span><br><span class="line">        ll ans=exBSGS();</span><br><span class="line">        <span class="keyword">if</span>(ans &lt; <span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">"No Solution"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="欧拉降幂"><a href="#欧拉降幂" class="headerlink" title="欧拉降幂"></a>欧拉降幂</h4><p>求解$A^B \ mod\ C$，$B \leq 10^{1000000}$</p><p>若$a$和$n$为正整数并且互质</p><p>$a^{\varphi (n)} \equiv 1(mod \ n)$<br>$$<br>a^b \equiv<br>\begin{cases}<br>a^{b \ mod \  \varphi(p) } &amp; \text{ gcd(a,p)=1}  \newline<br>a^b &amp; \text gcd(a,p) \neq 1 , b&lt;\varphi(p)   \newline<br>a^{ (b \ mod \  \varphi(p)) + \varphi(p)}  &amp; \text gcd(a,p) \neq 1 , b \geq \varphi(p)<br>\end{cases}  \ \ \ \ \ \ \ \ \ \ (mod\ p)<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll __int64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 10000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">1000006</span>];</span><br><span class="line">ll x,z;</span><br><span class="line"><span class="function">ll <span class="title">quickpow</span><span class="params">(ll x,ll y,ll z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)</span><br><span class="line">            ans=ans*x%z;</span><br><span class="line">        x=x*x%z;</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">phi</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll i,rea=n;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i*i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            rea=rea-rea/i;</span><br><span class="line">            <span class="keyword">while</span>(n%i==<span class="number">0</span>)</span><br><span class="line">                n/=i;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>)</span><br><span class="line">        rea=rea-rea/n;</span><br><span class="line">    <span class="keyword">return</span> rea;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%lld %s %lld"</span>,&amp;x,a,&amp;z)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        ll len=<span class="built_in">strlen</span>(a);</span><br><span class="line">        ll p=phi(z);</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            ans=(ans*<span class="number">10</span>+a[i]-<span class="string">'0'</span>)%p;</span><br><span class="line">        ans+=p;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,quickpow(x,ans,z));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h4><p>求解<br>$$<br>\begin{cases}<br>x \equiv a_1 (mod\ b_1) \newline<br>x \equiv a_2 (mod\ b_2)  \newline<br>…  \newline<br>x \equiv a_n (mod\ b_n)<br>\end{cases}<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lt;</span><br><span class="line"></span><br><span class="line"><span class="function">lt <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lt f=<span class="number">1</span>,x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ss=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ss&lt;<span class="string">'0'</span>||ss&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(ss==<span class="string">'-'</span>)f=<span class="number">-1</span>;ss=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ss&gt;=<span class="string">'0'</span>&amp;&amp;ss&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+ss-<span class="string">'0'</span>;ss=getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">lt ai[maxn],bi[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">lt <span class="title">mul</span><span class="params">(lt a,lt b,lt mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lt res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=(res+a)%mod;</span><br><span class="line">        a=(a+a)%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">lt <span class="title">exgcd</span><span class="params">(lt a,lt b,lt &amp;x,lt &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;x=<span class="number">1</span>;y=<span class="number">0</span>;<span class="keyword">return</span> a;&#125;</span><br><span class="line">    lt gcd=exgcd(b,a%b,x,y);</span><br><span class="line">    lt tp=x;</span><br><span class="line">    x=y; y=tp-a/b*y;</span><br><span class="line">    <span class="keyword">return</span> gcd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">lt <span class="title">excrt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lt x,y,k;</span><br><span class="line">    lt M=bi[<span class="number">1</span>],ans=ai[<span class="number">1</span>];<span class="comment">//第一个方程的解特判</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        lt a=M,b=bi[i],c=(ai[i]-ans%b+b)%b;<span class="comment">//ax≡c(mod b)</span></span><br><span class="line">        lt gcd=exgcd(a,b,x,y),bg=b/gcd;</span><br><span class="line">        <span class="keyword">if</span>(c%gcd!=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//判断是否无解，然而这题其实不用</span></span><br><span class="line"></span><br><span class="line">        x=mul(x,c/gcd,bg);</span><br><span class="line">        ans+=x*M;<span class="comment">//更新前k个方程组的答案</span></span><br><span class="line">        M*=bg;<span class="comment">//M为前k个m的lcm</span></span><br><span class="line">        ans=(ans%M+M)%M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ans%M+M)%M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    bi[i]=read(),ai[i]=read();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,excrt());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> BigInteger ai[]=<span class="keyword">new</span> BigInteger[<span class="number">11000</span>];</span><br><span class="line">    <span class="keyword">static</span> BigInteger bi[]=<span class="keyword">new</span> BigInteger[<span class="number">11000</span>];</span><br><span class="line">    <span class="keyword">static</span> BigInteger lp[]=<span class="keyword">new</span> BigInteger[<span class="number">150</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">static</span> BigInteger m;</span><br><span class="line">    <span class="keyword">static</span> String tem;</span><br><span class="line">    <span class="keyword">static</span> BigInteger rt;</span><br><span class="line">    <span class="keyword">static</span> BigInteger cr;</span><br><span class="line">    <span class="keyword">static</span> BigInteger zero=<span class="keyword">new</span> BigInteger(<span class="string">"0"</span>);</span><br><span class="line">    <span class="keyword">static</span> BigInteger one=<span class="keyword">new</span> BigInteger(<span class="string">"1"</span>);</span><br><span class="line">    <span class="keyword">static</span> BigInteger two=<span class="keyword">new</span> BigInteger(<span class="string">"2"</span>);</span><br><span class="line">    <span class="keyword">static</span> BigInteger fuone=<span class="keyword">new</span> BigInteger(<span class="string">"-1"</span>);</span><br><span class="line">    <span class="keyword">static</span> BigInteger maxnt=<span class="keyword">new</span> BigInteger(<span class="string">"1000000000000000"</span>);</span><br><span class="line">    <span class="keyword">static</span> BigInteger x=zero;</span><br><span class="line">    <span class="keyword">static</span> BigInteger y=zero;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Scanner cin=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        n=cin.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tem=cin.next();</span><br><span class="line">            bi[i]=<span class="keyword">new</span> BigInteger(tem);</span><br><span class="line">            tem=cin.next();</span><br><span class="line">            ai[i]=<span class="keyword">new</span> BigInteger(tem);</span><br><span class="line">        &#125;</span><br><span class="line">        rt=excrt();</span><br><span class="line">        lp[<span class="number">0</span>]=zero;</span><br><span class="line">    lp[<span class="number">1</span>]=one;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">100</span>;i++) </span><br><span class="line">        lp[i]=lp[i-<span class="number">1</span>].add(lp[i-<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span>(rt.compareTo(one)&lt;=<span class="number">0</span>||rt.compareTo(maxnt)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">"Tankernb!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fg=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(lp[i].compareTo(rt)==<span class="number">0</span>) fg=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fg==<span class="number">1</span>)System.out.println(<span class="string">"Lbnb!"</span>);</span><br><span class="line">        <span class="keyword">else</span> System.out.println(<span class="string">"Zgxnb!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigInteger <span class="title">exgcd</span><span class="params">(BigInteger a,BigInteger b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b.compareTo(zero)==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            x=one;</span><br><span class="line">            y=zero;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        BigInteger gcd=exgcd(b,a.mod(b));</span><br><span class="line">        BigInteger tp=x;</span><br><span class="line">        x=y;</span><br><span class="line">        y=tp.subtract((a.divide(b)).multiply(y));</span><br><span class="line">        <span class="keyword">return</span> gcd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigInteger <span class="title">excrt</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        BigInteger xx=zero,yy=zero,k;</span><br><span class="line">        BigInteger mo=bi[<span class="number">1</span>],ans=ai[<span class="number">1</span>];<span class="comment">//第一个方程的解特判</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            BigInteger a=mo,b=bi[i];</span><br><span class="line">            BigInteger t=ans.mod(b);</span><br><span class="line">            t=ai[i].subtract(t);</span><br><span class="line">            t=t.add(b);</span><br><span class="line">            BigInteger c=t.mod(b);</span><br><span class="line">            y=yy;x=xx;</span><br><span class="line">            BigInteger gcd=exgcd(a,b),bg=b.divide(gcd);</span><br><span class="line">            xx=x;yy=y;</span><br><span class="line">            <span class="keyword">if</span>((c.mod(gcd)).compareTo(zero)!=<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> fuone; <span class="comment">//判断是否无解，然而这题其实不用</span></span><br><span class="line">            xx=xx.multiply(c.divide(gcd)).mod(bg);  </span><br><span class="line">            ans=ans.add(xx.multiply(mo));<span class="comment">//更新前k个方程组的答案</span></span><br><span class="line">            mo=mo.multiply(bg);<span class="comment">//M为前k个m的lcm</span></span><br><span class="line">            ans=((ans.mod(mo)).add(mo)).mod(mo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ((ans.mod(mo)).add(mo)).mod(mo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线性同余方程"><a href="#线性同余方程" class="headerlink" title="线性同余方程"></a>线性同余方程</h4><p>1、方程$ax+by=c$与方程$ax \equiv  c (mod \ b)$等价，有整数解的充要条件是$gcd(a,b) % c=0$。</p><p>2、若$gcd(a,b)=1$，且$x_0,y_0$为方程$ax+by=c$的一组解，该方程的任意解可表示为：$x=x_0+bt$，$y=y_0+at$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ex_gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span>&amp; x, <span class="keyword">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> d = ex_gcd(b, a % b, x, y);</span><br><span class="line">  <span class="keyword">int</span> temp = x;</span><br><span class="line">  x = y;</span><br><span class="line">  y = temp - a / b * y;</span><br><span class="line">  <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">liEu</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span>&amp; x, <span class="keyword">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> d = ex_gcd(a, b, x, y);</span><br><span class="line">  <span class="keyword">if</span> (c % d != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> k = c / d;</span><br><span class="line">  x *= k;</span><br><span class="line">  y *= k;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二次剩余"><a href="#二次剩余" class="headerlink" title="二次剩余"></a>二次剩余</h4><p>求解$x \equiv \sqrt{y} \mod p$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> random(a,b) (rand()%(b-a+1)+a)</span></span><br><span class="line"><span class="function">LL <span class="title">quick_mod</span><span class="params">(LL a, LL b, LL c)</span></span>&#123;</span><br><span class="line">    LL ans = <span class="number">1</span>; <span class="keyword">while</span> (b)&#123; </span><br><span class="line">    <span class="keyword">if</span> (b % <span class="number">2</span> == <span class="number">1</span>) ans = (ans*a) % c; b /= <span class="number">2</span>; a = (a*a) % c; </span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">LL p;</span><br><span class="line">LL w;<span class="comment">//二次域的D值</span></span><br><span class="line"><span class="keyword">bool</span> ok;<span class="comment">//是否有解</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QuadraticField</span>//二次域</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LL x, y;</span><br><span class="line">    QuadraticField <span class="keyword">operator</span>*(QuadraticField T)<span class="comment">//二次域乘法重载</span></span><br><span class="line">    &#123;</span><br><span class="line">        QuadraticField ans;</span><br><span class="line">        ans.x = (<span class="keyword">this</span>-&gt;x*T.x%p + <span class="keyword">this</span>-&gt;y*T.y%p*w%p) % p;</span><br><span class="line">        ans.y = (<span class="keyword">this</span>-&gt;x*T.y%p + <span class="keyword">this</span>-&gt;y*T.x%p) % p;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    QuadraticField <span class="keyword">operator</span>^(LL b)<span class="comment">//二次域快速幂</span></span><br><span class="line">    &#123;</span><br><span class="line">        QuadraticField ans;</span><br><span class="line">        QuadraticField a = *<span class="keyword">this</span>;</span><br><span class="line">        ans.x = <span class="number">1</span>;</span><br><span class="line">        ans.y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = ans*a;</span><br><span class="line">                b--;</span><br><span class="line">            &#125;</span><br><span class="line">            b /= <span class="number">2</span>;</span><br><span class="line">            a = a*a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">LL <span class="title">Legender</span><span class="params">(LL a)</span><span class="comment">//求勒让德符号</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL ans=quick_mod(a, (p - <span class="number">1</span>) / <span class="number">2</span>, p);</span><br><span class="line">    <span class="keyword">if</span> (ans + <span class="number">1</span> == p)<span class="comment">//如果ans的值为-1，%p之后会变成p-1。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">LL <span class="title">Getw</span><span class="params">(LL n, LL a)</span><span class="comment">//根据随机出来a的值确定对应w的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((a*a - n) % p + p) % p;<span class="comment">//防爆处理</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">LL <span class="title">Solve</span><span class="params">(LL n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL a;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">2</span>)<span class="comment">//当p为2的时候，n只会是0或1，然后0和1就是对应的解</span></span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">if</span> (Legender(n) == <span class="number">-1</span>)<span class="comment">//无解</span></span><br><span class="line">        ok = <span class="literal">false</span>;</span><br><span class="line">    srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)<span class="comment">//随机a的值直到有解</span></span><br><span class="line">    &#123;</span><br><span class="line">        a = random(<span class="number">0</span>, p - <span class="number">1</span>);</span><br><span class="line">        w = Getw(n, a);</span><br><span class="line">        <span class="keyword">if</span> (Legender(w) == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    QuadraticField ans,res;</span><br><span class="line">    res.x = a;</span><br><span class="line">    res.y = <span class="number">1</span>;<span class="comment">//res的值就是a+根号w</span></span><br><span class="line">    ans = res ^ ((p + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (ans.x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    ll b,c;</span><br><span class="line">    p=<span class="number">1000000007</span>;</span><br><span class="line">    ll t1,t2,t3;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;b,&amp;c);</span><br><span class="line">        <span class="keyword">if</span> (b*b<span class="number">-4l</span>l*c==<span class="number">0</span>)</span><br><span class="line">        t1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        t1=Solve(b*b<span class="number">-4l</span>l*c);</span><br><span class="line">        <span class="keyword">if</span> (t1==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"-1 -1"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        t2=((b+t1)*quick_mod(<span class="number">2</span>,p<span class="number">-2</span>,p))%p;</span><br><span class="line">        t3=((b-t1+p)%p*quick_mod(<span class="number">2</span>,p<span class="number">-2</span>,p))%p;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld %lld\n"</span>,min(t2,t3),max(t2,t3));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a>约瑟夫环</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">joseph</span><span class="params">(<span class="keyword">int</span> count, <span class="keyword">int</span> doom)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> alive = count;<span class="comment">// 幸存人数</span></span><br><span class="line"><span class="keyword">int</span> number = <span class="number">0</span>;<span class="comment">// 报数的数</span></span><br><span class="line"><span class="keyword">int</span> curIndex = <span class="number">0</span>;<span class="comment">// 当前人下标</span></span><br><span class="line"><span class="keyword">int</span> preIndex = count - <span class="number">1</span>;   <span class="comment">// 前一个人下标</span></span><br><span class="line"><span class="keyword">int</span> index;</span><br><span class="line"><span class="keyword">int</span> *circle = <span class="literal">NULL</span>;</span><br><span class="line">circle = (<span class="keyword">int</span> *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * count);</span><br><span class="line"><span class="comment">//对circle数组进行初始化</span></span><br><span class="line"><span class="keyword">for</span>(index = <span class="number">0</span>; index &lt; count; index++) &#123;</span><br><span class="line">circle[index] = (index + <span class="number">1</span>) % count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(alive &gt; <span class="number">0</span>) &#123;</span><br><span class="line">number++;</span><br><span class="line"><span class="keyword">if</span>(number == doom) &#123;</span><br><span class="line">alive == <span class="number">1</span> ? <span class="built_in">printf</span>(<span class="string">"%d"</span>, curIndex+<span class="number">1</span>) : <span class="built_in">printf</span>(<span class="string">"%d,"</span>, curIndex+<span class="number">1</span>);</span><br><span class="line">alive--;</span><br><span class="line">number = <span class="number">0</span>;</span><br><span class="line">circle[preIndex] = circle[curIndex];<span class="comment">//出圈操作</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">preIndex = curIndex;<span class="comment">//处理下一个人</span></span><br><span class="line">&#125;</span><br><span class="line">curIndex = circle[curIndex];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(circle);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">joseph(n,m);</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="杜教递推"><a href="#杜教递推" class="headerlink" title="杜教递推"></a>杜教递推</h4><p>杜教线性递推</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, n) for (int i = a; i &lt; n; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; VI;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function">ll <span class="title">fastpower</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    a %= mod;</span><br><span class="line">    assert(b &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = res * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> linear_seq &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>;</span><br><span class="line">ll res[N], base[N], _c[N], _md[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Md;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(ll *a, ll *b, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">0</span>, k + k) _c[i] = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">0</span>, k) <span class="keyword">if</span> (a[i]) rep(j, <span class="number">0</span>, k) _c[i + j] =</span><br><span class="line">        (_c[i + j] + a[i] * b[j]) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k + k - <span class="number">1</span>; i &gt;= k; i--)</span><br><span class="line">        <span class="keyword">if</span> (_c[i])</span><br><span class="line">            rep(j, <span class="number">0</span>, sz(Md)) _c[i - k + Md[j]] =</span><br><span class="line">                (_c[i - k + Md[j]] - _c[i] * _md[Md[j]]) % mod;</span><br><span class="line">    rep(i, <span class="number">0</span>, k) a[i] = _c[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(ll n, VI a, VI b)</span> </span>&#123;  <span class="comment">// a 系数 b 初值 b[n+1]=a[0]*b[n]+...</span></span><br><span class="line">                               <span class="comment">//        printf("%d\n",sz(b));</span></span><br><span class="line">    ll ans = <span class="number">0</span>, pnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> k = sz(a);</span><br><span class="line">    assert(sz(a) == sz(b));</span><br><span class="line">    rep(i, <span class="number">0</span>, k) _md[k - <span class="number">1</span> - i] = -a[i];</span><br><span class="line">    _md[k] = <span class="number">1</span>;</span><br><span class="line">    Md.clear();</span><br><span class="line">    rep(i, <span class="number">0</span>, k) <span class="keyword">if</span> (_md[i] != <span class="number">0</span>) Md.push_back(i);</span><br><span class="line">    rep(i, <span class="number">0</span>, k) res[i] = base[i] = <span class="number">0</span>;</span><br><span class="line">    res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="number">1l</span>l &lt;&lt; pnt) &lt;= n) pnt++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = pnt; p &gt;= <span class="number">0</span>; p--) &#123;</span><br><span class="line">        mul(res, res, k);</span><br><span class="line">        <span class="keyword">if</span> ((n &gt;&gt; p) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) res[i + <span class="number">1</span>] = res[i];</span><br><span class="line">            res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            rep(j, <span class="number">0</span>, sz(Md)) res[Md[j]] =</span><br><span class="line">                (res[Md[j]] - res[k] * _md[Md[j]]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">0</span>, k) ans = (ans + res[i] * b[i]) % mod;</span><br><span class="line">    <span class="keyword">if</span> (ans &lt; <span class="number">0</span>) ans += mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">VI <span class="title">BM</span><span class="params">(VI s)</span> </span>&#123;</span><br><span class="line">    VI C(1, 1), B(1, 1);</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>, m = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">    rep(n, <span class="number">0</span>, sz(s)) &#123;</span><br><span class="line">        ll d = <span class="number">0</span>;</span><br><span class="line">        rep(i, <span class="number">0</span>, L + <span class="number">1</span>) d = (d + (ll)C[i] * s[n - i]) % mod;</span><br><span class="line">        <span class="keyword">if</span> (d == <span class="number">0</span>)</span><br><span class="line">            ++m;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">2</span> * L &lt;= n) &#123;</span><br><span class="line">            VI T = C;</span><br><span class="line">            ll c = mod - d * fastpower(b, mod - <span class="number">2</span>) % mod;</span><br><span class="line">            <span class="keyword">while</span> (sz(C) &lt; sz(B) + m) C.pb(<span class="number">0</span>);</span><br><span class="line">            rep(i, <span class="number">0</span>, sz(B)) C[i + m] = (C[i + m] + c * B[i]) % mod;</span><br><span class="line">            L = n + <span class="number">1</span> - L;</span><br><span class="line">            B = T;</span><br><span class="line">            b = d;</span><br><span class="line">            m = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ll c = mod - d * fastpower(b, mod - <span class="number">2</span>) % mod;</span><br><span class="line">            <span class="keyword">while</span> (sz(C) &lt; sz(B) + m) C.pb(<span class="number">0</span>);</span><br><span class="line">            rep(i, <span class="number">0</span>, sz(B)) C[i + m] = (C[i + m] + c * B[i]) % mod;</span><br><span class="line">            ++m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gao</span><span class="params">(VI a, ll n)</span></span>&#123;</span><br><span class="line">    VI c = BM(a);</span><br><span class="line">    c.erase(c.begin());</span><br><span class="line">    rep(i, <span class="number">0</span>, sz(c)) c[i] = (mod - c[i]) % mod;</span><br><span class="line">    <span class="keyword">return</span> solve(n, c, VI(a.begin(), a.begin() + sz(c)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;;  <span class="comment">// namespace linear_seq</span></span><br><span class="line"><span class="comment">//使用linear_seq::gao(ve,n),ve是一个vector变量,n是递推的个数</span></span><br></pre></td></tr></table></figure><h4 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法"></a>辗转相除法</h4><p>求解满足$\frac{lb}{la} &lt; \frac{y}{x} &lt; \frac{rb}{ra}$，最小的$x$和$y$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="comment">// b/a  y/x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">(ll la, ll lb, ll ra, ll rb, ll &amp;x, ll &amp;y)</span></span>&#123;</span><br><span class="line">ll m = lb/la + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(m &lt;= rb/ra)&#123;</span><br><span class="line">y = m;</span><br><span class="line">x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">m --;</span><br><span class="line">lb -= m*la, rb -= m*ra;</span><br><span class="line">cal(rb, ra, lb, la, y, x);</span><br><span class="line">y += m*x;<span class="comment">//回溯</span></span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ll la,lb;</span><br><span class="line">        ll ra,rb;</span><br><span class="line">        ll x,p,k,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;p,&amp;x);</span><br><span class="line">        la=x;</span><br><span class="line">        lb=p;</span><br><span class="line">        ra=x<span class="number">-1</span>;</span><br><span class="line">        rb=p;</span><br><span class="line">        cal(la,lb,ra,rb,k,b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld/%lld\n"</span>,b*x-k*p,b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Miller-Pabin-素数判定"><a href="#Miller-Pabin-素数判定" class="headerlink" title="Miller_Pabin 素数判定"></a>Miller_Pabin 素数判定</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">qmul</span><span class="params">(ll a,ll b,ll mod)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans = (ans+a)%mod;</span><br><span class="line">        a = (a+a)%mod;   <span class="comment">//相当于a*1、a*2、a*4、a*8的增加</span></span><br><span class="line">        b = b&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll n,ll mod)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) ans=(ans*x)%mod;</span><br><span class="line">        x=x*x%mod;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">ll prime[<span class="number">6</span>] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">233</span>, <span class="number">331</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Miller_Rabin</span><span class="params">(ll p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="number">2</span> &amp;&amp; p % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll s = p - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(! (s &amp; <span class="number">1</span>)) s &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p == prime[i]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        ll t = s, m = qpow(prime[i], s, p);</span><br><span class="line">        <span class="keyword">while</span>(t != p - <span class="number">1</span> &amp;&amp; m != <span class="number">1</span> &amp;&amp; m != p - <span class="number">1</span>) &#123;</span><br><span class="line">            m = qmul(m, m, p);</span><br><span class="line">            t &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(m != p - <span class="number">1</span> &amp;&amp; !(t &amp; <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="大数分解质因数"><a href="#大数分解质因数" class="headerlink" title="大数分解质因数"></a>大数分解质因数</h4><p><a href="https://codeforces.com/gym/102299" target="_blank" rel="noopener">Forbechenko v Rodvsky</a></p><p>求使得$\frac{A}{B}$变成有限分数的$k$进制的最小的$k$。</p><p>结论：最小的$k$就是$\frac{\frac{A}{gcd(A,B)}}{\frac{B}{gcd(A,B)}}$中$\frac{B}{gcd(A,B)}$的所有质因数相乘的积$ans$，答案就是$\beta = min(2,ans)$。</p><p>$pollard _ rho$模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, <span class="keyword">int</span>&gt; pli;</span><br><span class="line"><span class="keyword">namespace</span> pollard_rho &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> C = <span class="number">2307</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> S = <span class="number">10</span>;</span><br><span class="line">    <span class="function">mt19937 <span class="title">rd</span><span class="params">(time(<span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt; ve;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123; <span class="keyword">return</span> b ? gcd(b, a % b) : a; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">qmul</span><span class="params">(ll a, ll b, ll mod)</span> </span>&#123;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        a %= mod;</span><br><span class="line">        <span class="keyword">while</span> (b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">                ans = (ans + a) % mod;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            a = (a &lt;&lt; <span class="number">1</span>) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">mul</span><span class="params">(ll a, ll b, ll mod)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">power</span><span class="params">(ll a, ll b, ll mod)</span> </span>&#123;</span><br><span class="line">        ll res = <span class="number">1</span>;</span><br><span class="line">        a %= mod;</span><br><span class="line">        <span class="keyword">while</span> (b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1</span>)res = qmul(res, a, mod);</span><br><span class="line">            a = qmul(a, a, mod);</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(ll a, ll n)</span> </span>&#123;</span><br><span class="line">        ll m = n - <span class="number">1</span>, x, y;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!(m &amp; <span class="number">1</span>))m &gt;&gt;= <span class="number">1</span>, j++;</span><br><span class="line">        x = power(a, m, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= j; x = y, i++) &#123;</span><br><span class="line">            y = qmul(x, x, n);</span><br><span class="line">            <span class="keyword">if</span> (y == <span class="number">1</span> &amp;&amp; x != <span class="number">1</span> &amp;&amp; x != n - <span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> y != <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">miller_rabin</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">        ll a;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(n &amp; <span class="number">1</span>))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S; i++)<span class="keyword">if</span> (check(rd() % (n - <span class="number">1</span>) + <span class="number">1</span>, n))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">pollard_rho</span><span class="params">(ll n, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        ll i = <span class="number">1</span>, k = <span class="number">2</span>, x = rd() % n, y = x, d;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            x = (qmul(x, x, n) + c) % n, d = gcd(y - x, n);</span><br><span class="line">            <span class="keyword">if</span> (d &gt; <span class="number">1</span> &amp;&amp; d &lt; n)<span class="keyword">return</span> d;</span><br><span class="line">            <span class="keyword">if</span> (y == x)<span class="keyword">return</span> n;</span><br><span class="line">            <span class="keyword">if</span> (i == k)y = x, k &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findfac</span><span class="params">(ll n, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (miller_rabin(n)) &#123;</span><br><span class="line">            ve.push_back(n);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll m = n;</span><br><span class="line">        <span class="keyword">while</span> (m == n)m = pollard_rho(n, c--);</span><br><span class="line">        findfac(m, c);</span><br><span class="line">        findfac(n / m, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;pli&gt; solve(ll n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pli&gt; res;</span><br><span class="line">        ve.clear();</span><br><span class="line">        findfac(n, C);</span><br><span class="line">        sort(ve.begin(), ve.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x:ve) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res.empty() || res.back().first != x)res.push_back(&#123;x, <span class="number">1</span>&#125;);</span><br><span class="line">            <span class="keyword">else</span> res.back().second++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    ll tmp=__gcd(a,b);</span><br><span class="line">    a/=tmp;</span><br><span class="line">    b/=tmp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pli&gt;ans;</span><br><span class="line">    ans=pollard_rho::solve(b);</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:ans)&#123;</span><br><span class="line">        res*=x.first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll a,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,max(<span class="number">2l</span>l,solve(a,b)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="阶乘素因子出现的次数"><a href="#阶乘素因子出现的次数" class="headerlink" title="阶乘素因子出现的次数"></a>阶乘素因子出现的次数</h4><p>$$<br>cnt(x)=\left \lfloor \frac{n}{x^1} \right \rfloor+\left \lfloor \frac{n}{x^2} \right \rfloor+…+\left \lfloor \frac{n}{x^i} \right \rfloor if(x^i&lt;=n)<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ll now=prime[i],sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(now&lt;=n)&#123;</span><br><span class="line">sum+=n/now;</span><br><span class="line">now=now*prime[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">ll cnt=<span class="number">0</span>;</span><br><span class="line">ll tmp=n;</span><br><span class="line"><span class="keyword">while</span>(tmp/pr[i])&#123;</span><br><span class="line">  cnt+=(tmp/pr[i]);</span><br><span class="line">tmp/=pr[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h4><p>如果 ${ r * 2 ^ k + 1 }$ 是个素数，那么在 $ {mod \ r * 2 ^ k+1} $ 意义下，可以处理 $ 2^k $以内规模的数据。</p><p>记录一下 $a ∗ 2^k+1$型素数的原根 $g$。</p><table><thead><tr><th align="left">$a * 2^k + 1$</th><th>$a$</th><th>$k$</th><th>$g$</th></tr></thead><tbody><tr><td align="left">3</td><td>1</td><td>1</td><td>2</td></tr><tr><td align="left">5</td><td>1</td><td>2</td><td>2</td></tr><tr><td align="left">17</td><td>1</td><td>4</td><td>3</td></tr><tr><td align="left">97</td><td>3</td><td>5</td><td>5</td></tr><tr><td align="left">193</td><td>3</td><td>6</td><td>5</td></tr><tr><td align="left">257</td><td>1</td><td>8</td><td>3</td></tr><tr><td align="left">7681</td><td>15</td><td>9</td><td>17</td></tr><tr><td align="left">12289</td><td>3</td><td>12</td><td>11</td></tr><tr><td align="left">40961</td><td>5</td><td>13</td><td>3</td></tr><tr><td align="left">65537</td><td>1</td><td>16</td><td>3</td></tr><tr><td align="left">786433</td><td>3</td><td>18</td><td>10</td></tr><tr><td align="left">5767169</td><td>11</td><td>19</td><td>3</td></tr><tr><td align="left">7340033</td><td>7</td><td>20</td><td>3</td></tr><tr><td align="left">23068673</td><td>11</td><td>21</td><td>3</td></tr><tr><td align="left">104857601</td><td>25</td><td>22</td><td>3</td></tr><tr><td align="left">167772161</td><td>5</td><td>25</td><td>3</td></tr><tr><td align="left">469762049</td><td>7</td><td>26</td><td>3</td></tr><tr><td align="left">998244353(常见)</td><td>119</td><td>23</td><td>3</td></tr><tr><td align="left">1004535809</td><td>479</td><td>21</td><td>3</td></tr><tr><td align="left">1998585857</td><td>953</td><td>21</td><td>3</td></tr><tr><td align="left">2013265921</td><td>15</td><td>27</td><td>31</td></tr><tr><td align="left">2281701377</td><td>17</td><td>27</td><td>3</td></tr><tr><td align="left">3221225473</td><td>3</td><td>30</td><td>5</td></tr><tr><td align="left">75161927681</td><td>35</td><td>31</td><td>3</td></tr><tr><td align="left">77309411329</td><td>9</td><td>33</td><td>7</td></tr><tr><td align="left">206158430209</td><td>3</td><td>36</td><td>22</td></tr><tr><td align="left">2061584302081</td><td>15</td><td>37</td><td>7</td></tr><tr><td align="left">2748779069441</td><td>5</td><td>39</td><td>3</td></tr><tr><td align="left">6597069766657</td><td>3</td><td>41</td><td>5</td></tr><tr><td align="left">39582418599937</td><td>9</td><td>42</td><td>5</td></tr><tr><td align="left">79164837199873</td><td>9</td><td>43</td><td>5</td></tr><tr><td align="left">263882790666241</td><td>15</td><td>44</td><td>7</td></tr><tr><td align="left">1231453023109121</td><td>35</td><td>45</td><td>3</td></tr><tr><td align="left">1337006139375617</td><td>19</td><td>46</td><td>3</td></tr><tr><td align="left">3799912185593857</td><td>27</td><td>47</td><td>5</td></tr><tr><td align="left">4222124650659841</td><td>15</td><td>48</td><td>19</td></tr><tr><td align="left">7881299347898369</td><td>7</td><td>50</td><td>6</td></tr><tr><td align="left">31525197391593473</td><td>7</td><td>52</td><td>3</td></tr><tr><td align="left">180143985094819841</td><td>5</td><td>55</td><td>6</td></tr><tr><td align="left">1945555039024054273</td><td>27</td><td>56</td><td>5</td></tr><tr><td align="left">4179340454199820289</td><td>29</td><td>57</td><td>3</td></tr></tbody></table><h4 id="勾股定理构造"><a href="#勾股定理构造" class="headerlink" title="勾股定理构造"></a>勾股定理构造</h4><p>$(\frac{n^2}{4}-1)^2+n^2=(\frac{n^2}{4}+1)^2$</p><p>$(\frac{n^2-1}{2})^2+n^2=(\frac{n^2+1}{2})^2$</p><h3 id="几何"><a href="#几何" class="headerlink" title="几何"></a>几何</h3><h4 id="二维几何"><a href="#二维几何" class="headerlink" title="二维几何"></a>二维几何</h4><h4 id="三维几何"><a href="#三维几何" class="headerlink" title="三维几何"></a>三维几何</h4><h5 id="求两个平面的最短距离"><a href="#求两个平面的最短距离" class="headerlink" title="求两个平面的最短距离"></a>求两个平面的最短距离</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">  <span class="keyword">double</span> x, y, z;</span><br><span class="line">  Point <span class="keyword">operator</span>-(<span class="keyword">const</span> Point&amp; p) <span class="keyword">const</span> &#123; <span class="keyword">return</span> &#123;x-p.x, y-p.y, z-p.z&#125;; &#125;</span><br><span class="line">  Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point&amp; p) <span class="keyword">const</span> &#123; <span class="keyword">return</span> &#123;x+p.x, y+p.y, z+p.z&#125;; &#125;</span><br><span class="line">  Point <span class="keyword">operator</span>*(<span class="keyword">double</span> c) <span class="keyword">const</span> &#123; <span class="keyword">return</span> &#123;x*c, y*c, z*c&#125;; &#125;</span><br><span class="line">  Point <span class="keyword">operator</span>/(<span class="keyword">double</span> c) <span class="keyword">const</span> &#123; <span class="keyword">return</span> &#123;x/c, y/c, z/c&#125;; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">lensqr</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x*x+y*y+z*z; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">len</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">sqrt</span>(x*x+y*y+z*z); &#125;</span><br><span class="line">  <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="keyword">const</span> Point&amp; p) &#123;</span><br><span class="line">    out &lt;&lt; <span class="string">'('</span> &lt;&lt; p.x &lt;&lt; <span class="string">','</span> &lt;&lt; p.y &lt;&lt; <span class="string">','</span> &lt;&lt; p.z &lt;&lt; <span class="string">')'</span>; <span class="keyword">return</span> out;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">Point <span class="title">crossP</span><span class="params">(<span class="keyword">const</span> Point&amp; a, <span class="keyword">const</span> Point&amp; b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;a.y*b.z-a.z*b.y, a.z*b.x-a.x*b.z, a.x*b.y-a.y*b.x&#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dotP</span><span class="params">(<span class="keyword">const</span> Point&amp; a, <span class="keyword">const</span> Point&amp; b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.x*b.x + a.y*b.y + a.z*b.z;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T, prob=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">cin</span> &gt;&gt; T; T--;) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Point&gt; t1(<span class="number">3</span>), t2(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) <span class="built_in">cin</span> &gt;&gt; t1[i].x &gt;&gt; t1[i].y &gt;&gt; t1[i].z;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) <span class="built_in">cin</span> &gt;&gt; t2[i].x &gt;&gt; t2[i].y &gt;&gt; t2[i].z;</span><br><span class="line">    <span class="keyword">double</span> ret = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> swp = <span class="number">0</span>; swp &lt; <span class="number">2</span>; swp++) &#123;</span><br><span class="line">      swap(t1, t2);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> rot1 = <span class="number">0</span>; rot1 &lt; <span class="number">3</span>; rot1++) &#123;</span><br><span class="line">        rotate(t1.begin(), t1.begin()+<span class="number">1</span>, t1.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> rot2 = <span class="number">0</span>; rot2 &lt; <span class="number">3</span>; rot2++) &#123;</span><br><span class="line">          rotate(t2.begin(), t2.begin()+<span class="number">1</span>, t2.end());</span><br><span class="line"> </span><br><span class="line">          <span class="comment">// Vertex-vertex</span></span><br><span class="line">          ret = min(ret, (t2[<span class="number">0</span>]-t1[<span class="number">0</span>]).len());</span><br><span class="line"> </span><br><span class="line">          <span class="comment">// Vertex-edge</span></span><br><span class="line">          <span class="keyword">double</span> dist = dotP(t2[<span class="number">0</span>]-t1[<span class="number">0</span>], t1[<span class="number">1</span>]-t1[<span class="number">0</span>]) / (t1[<span class="number">1</span>]-t1[<span class="number">0</span>]).lensqr();</span><br><span class="line">          <span class="keyword">if</span> (dist &gt; <span class="number">0</span> &amp;&amp; dist &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            Point p = t1[<span class="number">0</span>]*(<span class="number">1</span>-dist) + t1[<span class="number">1</span>]*dist;</span><br><span class="line">            ret = min(ret, (t2[<span class="number">0</span>]-p).len());</span><br><span class="line">          &#125;</span><br><span class="line"> </span><br><span class="line">          <span class="comment">// Vertex-triangle</span></span><br><span class="line">          Point normal = crossP(t1[<span class="number">1</span>]-t1[<span class="number">0</span>], t1[<span class="number">2</span>]-t1[<span class="number">0</span>]);</span><br><span class="line">          normal = normal / normal.len();</span><br><span class="line">          <span class="keyword">double</span> h = dotP(normal, t2[<span class="number">0</span>]-t1[<span class="number">0</span>]);</span><br><span class="line">          Point base = t2[<span class="number">0</span>] - normal*h;</span><br><span class="line">          <span class="keyword">if</span> (dotP(normal, crossP(t1[<span class="number">1</span>]-t1[<span class="number">0</span>], base-t1[<span class="number">0</span>])) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">              dotP(normal, crossP(t1[<span class="number">2</span>]-t1[<span class="number">1</span>], base-t1[<span class="number">1</span>])) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">              dotP(normal, crossP(t1[<span class="number">0</span>]-t1[<span class="number">2</span>], base-t1[<span class="number">2</span>])) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ret = min(ret, <span class="built_in">fabs</span>(h));</span><br><span class="line">          &#125;</span><br><span class="line"> </span><br><span class="line">          <span class="comment">// Edge-edge</span></span><br><span class="line">          normal = crossP(t1[<span class="number">1</span>]-t1[<span class="number">0</span>], t2[<span class="number">1</span>]-t2[<span class="number">0</span>]);</span><br><span class="line">          <span class="keyword">double</span> cp1 = dotP(normal, crossP(t2[<span class="number">1</span>]-t2[<span class="number">0</span>], t1[<span class="number">0</span>]-t2[<span class="number">0</span>]));</span><br><span class="line">          <span class="keyword">double</span> cp2 = dotP(normal, crossP(t2[<span class="number">1</span>]-t2[<span class="number">0</span>], t1[<span class="number">1</span>]-t2[<span class="number">0</span>]));</span><br><span class="line">          <span class="keyword">double</span> cp3 = dotP(normal, crossP(t1[<span class="number">1</span>]-t1[<span class="number">0</span>], t2[<span class="number">0</span>]-t1[<span class="number">0</span>]));</span><br><span class="line">          <span class="keyword">double</span> cp4 = dotP(normal, crossP(t1[<span class="number">1</span>]-t1[<span class="number">0</span>], t2[<span class="number">1</span>]-t1[<span class="number">0</span>]));</span><br><span class="line">          <span class="keyword">if</span> (cp1*cp2 &lt; <span class="number">0</span> &amp;&amp; cp3*cp4 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Point p1 = (t1[<span class="number">1</span>]*cp1 - t1[<span class="number">0</span>]*cp2) / (cp1-cp2);</span><br><span class="line">            Point p2 = (t2[<span class="number">1</span>]*cp3 - t2[<span class="number">0</span>]*cp4) / (cp3-cp4);</span><br><span class="line">            ret = min(ret, (p2-p1).len());</span><br><span class="line">          &#125;</span><br><span class="line"> </span><br><span class="line">          <span class="comment">// Edge-triangle (and triangle-triangle)</span></span><br><span class="line">          normal = crossP(t1[<span class="number">1</span>]-t1[<span class="number">0</span>], t1[<span class="number">2</span>]-t1[<span class="number">0</span>]);</span><br><span class="line">          normal = normal / normal.len();</span><br><span class="line">          cp1 = dotP(normal, t2[<span class="number">0</span>]-t1[<span class="number">0</span>]);</span><br><span class="line">          cp2 = dotP(normal, t2[<span class="number">1</span>]-t1[<span class="number">0</span>]);</span><br><span class="line">          <span class="keyword">if</span> (cp1*cp2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Point p = (t2[<span class="number">1</span>]*cp1 - t2[<span class="number">0</span>]*cp2) / (cp1-cp2);</span><br><span class="line">            <span class="keyword">if</span> (dotP(normal, crossP(t1[<span class="number">1</span>]-t1[<span class="number">0</span>], p-t1[<span class="number">0</span>])) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                dotP(normal, crossP(t1[<span class="number">2</span>]-t1[<span class="number">1</span>], p-t1[<span class="number">1</span>])) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                dotP(normal, crossP(t1[<span class="number">0</span>]-t1[<span class="number">2</span>], p-t1[<span class="number">2</span>])) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              ret = <span class="number">0.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.12lf\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Collected By Hope_Y…&lt;/p&gt;
    
    </summary>
    
      <category term="模板" scheme="http://yoursite.com/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
  </entry>
  
  <entry>
    <title>BSGS</title>
    <link href="http://yoursite.com/2019/08/05/BSGS/"/>
    <id>http://yoursite.com/2019/08/05/BSGS/</id>
    <published>2019-08-05T02:21:22.293Z</published>
    <updated>2019-08-06T03:45:07.699Z</updated>
    
    <content type="html"><![CDATA[<p>用于解决$y^x \equiv z\ (mod\ p)$，给定$y,z,p \geq 1$，求解$x$。</p><a id="more"></a><p>当$gcd(y,p)=1$，在这种情况下，有可能给定$p$为质数。设$x=a * m - b$ ，$m= \lceil \sqrt p \rceil$，$ a \in [0,m+1)$，$b \in [0,m)$，那么原式变成$y^{a * m}=z * y^{b}$，先枚举$b$，计算$z * y^{b}(mod\ p)$，存到$map$中，再枚举$a$就好了。</p><h2 id="SDOI2011"><a href="#SDOI2011" class="headerlink" title="SDOI2011"></a><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2242" target="_blank" rel="noopener">SDOI2011</a></h2><p>题意：给定$y,z,p$，计算1. $y^z (mod \ p)$；2. 满足$x * y \equiv z(mod \ p)$的最小非负整数的$x$；3.满足$y^x  \equiv  z\ (mod\ p)$的最小非负整数的$x$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll y,z,p;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll n,ll mod)</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) res=res*x%mod;</span><br><span class="line">        x=x*x%mod;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll x,ll mod)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> qpow(x,mod<span class="number">-2</span>,mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nnot</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Orz, I cannot find x!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BSGS</span><span class="params">(ll x,ll y)</span></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;ll,ll&gt;pw;</span><br><span class="line">    <span class="keyword">if</span>(y == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">-1</span>, m = <span class="built_in">sqrt</span>(p) + <span class="number">1</span>, xx, s = y;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        pw[s] = i;</span><br><span class="line">        s = s * x % p;</span><br><span class="line">    &#125;</span><br><span class="line">    xx = qpow(x, m, p), s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; ++i)&#123;</span><br><span class="line">        s = s * xx % p;</span><br><span class="line">        <span class="keyword">if</span>(pw.count(s))&#123;</span><br><span class="line">            ans = i * m - pw[s];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans &lt; <span class="number">0</span>) nnot();</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll t,op;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;t,&amp;op);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>,&amp;y,&amp;z,&amp;p);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,qpow(y,z,p));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>)&#123;</span><br><span class="line">            ll tm=y%p;</span><br><span class="line">            <span class="keyword">if</span>(tm==<span class="number">0</span> &amp;&amp; z%p!=<span class="number">0</span>)&#123;</span><br><span class="line">                nnot();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,z*inv(y,p)%p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(y%p) BSGS(y,z);</span><br><span class="line">            <span class="keyword">else</span> nnot();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>当$gcd(y,p) \neq 1$时，就要用到$exgcd$理论。</p><p>将原式写成$y * y^{x-1}+k * p=z,k \in Z$，根据$exgcd$，当$d=gcd(y,p)$不是$z$的约数就不会有解，有：$$\frac{y}{d} * y^{x-1}+k * \frac{p}{d}=\frac{z}{d}$$</p><p>一直递归直到$d=1$，设之间的所有的$d$的乘积为$g$，递归$c$次，令$x’=x-c\ ,\ p’=\frac{p}{g}\ ,\ z=\frac{z}{g}$，$y^{x’} * \frac{y^c}{g} \equiv z’(mod \ p’)$</p><p>然后再用BSGS求解。</p><h2 id="SPOJMOD-Power-Modulo-Inverted"><a href="#SPOJMOD-Power-Modulo-Inverted" class="headerlink" title="SPOJMOD Power Modulo Inverted"></a><a href="http://www.spoj.com/problems/MOD/" target="_blank" rel="noopener">SPOJMOD Power Modulo Inverted</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll y,z,p;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll n,ll mod)</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) res=res*x%mod;</span><br><span class="line">        x=x*x%mod;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll x,ll y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (y==<span class="number">0</span>)?x:gcd(y,x%y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">exBSGS</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(z==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;ll,ll&gt;pw;</span><br><span class="line">    ll cnt=<span class="number">0</span>,mul=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll d=gcd(y,p); d!=<span class="number">1</span>; d=gcd(y,p))&#123;</span><br><span class="line">        <span class="keyword">if</span>(z%d) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        ++cnt,z/=d,p/=d,mul=(mul*y/d%p);</span><br><span class="line">        <span class="keyword">if</span>(z == mul) <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    ll s=z,m=<span class="built_in">sqrt</span>(p)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">        pw[s]=i;</span><br><span class="line">        s=s*y%p;</span><br><span class="line">    &#125;</span><br><span class="line">    ll x=qpow(y,m,p);</span><br><span class="line">    s=mul;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>; i&lt;=m; i++)&#123;</span><br><span class="line">        s=s*x%p;</span><br><span class="line">        <span class="keyword">if</span>(pw.count(s)) <span class="keyword">return</span> i*m-pw[s]+cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>,&amp;y,&amp;p,&amp;z)&amp;&amp;(y||z||p))&#123;</span><br><span class="line">        y%=p;</span><br><span class="line">        z%=p;</span><br><span class="line">        ll ans=exBSGS();</span><br><span class="line">        <span class="keyword">if</span>(ans &lt; <span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">"No Solution"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="generator-2"><a href="#generator-2" class="headerlink" title="generator 2"></a><a href="https://ac.nowcoder.com/acm/contest/885/C" target="_blank" rel="noopener">generator 2</a></h2><p>2019年牛客多校第五场。</p><p>题意：你有一个$n$个数字的递推式：$x_{i} \equiv  (a * x_{i-1} + b)mod \ p$ ，给定$n$，$x_0$，$a$，$b$，$p$，其中$p$是素数，询问$Q$次，求一个最小的下标$i$，使得$x_i \equiv  v (mod \ p)$。</p><p>题解：很容易得到关于$x_i$的通项公式：$$x_i = a^i * x_0  + b * \sum_{j=0}^{i-1} a^j = a^i * x_0  + b * (\frac{a^i - 1}{a - 1}) = a ^ i * (\frac{b}{a-1}+x_0) - \frac{b}{a-1}$$</p><p>那么，可以化成$$a^i \equiv \frac{(a-1) * v+b}{(a-1) * x_0+b} (mod \ p)$$</p><p>由于题目需要查询的次数有$1000$次，直接套上面的$BSGS$复杂度太大，所以就需要预处理，我们看上面的代码，每次进行算法时其实都有一次for循环是预处理，我们把这一步放在查询前，改用unorder_map或者手写hash存值。</p><p>进一步优化，我们把预处理的时间增加，而减少查询时间，将预处理改成$\left \lceil p^{\frac{2}{3}} \right \rceil$，然后将查询的时间改成$\left \lceil p^{\frac{1}{3}} \right \rceil$。</p><p>注意这题$a$等于1或者0需要特判。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hash</span>&#123;</span></span><br><span class="line">    ll mod = <span class="number">2908361</span>;</span><br><span class="line">    ll cnt = <span class="number">0</span>, Head[<span class="number">2908361</span>], nxt[<span class="number">1000006</span>];</span><br><span class="line">    ll val[<span class="number">1000006</span>], pos[<span class="number">1000006</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(Head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(Head)); cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(ll x, ll v)</span></span>&#123;</span><br><span class="line">        ll key = x % mod;</span><br><span class="line">        pos[cnt] = x, val[cnt] = v, nxt[cnt] = Head[key];</span><br><span class="line">        Head[key] = cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">Find</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">        ll key = x % mod;</span><br><span class="line">        <span class="keyword">for</span>(ll i = Head[key]; ~i; i = nxt[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(pos[i] == x) <span class="keyword">return</span> val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1l</span>l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;hs;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll n,ll mod)</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) res=res*x%mod;</span><br><span class="line">        x=x*x%mod;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll x,ll p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> qpow(x,p<span class="number">-2</span>,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(ll y,ll p)</span></span>&#123;</span><br><span class="line">    hs.init();</span><br><span class="line">    ll m=<span class="built_in">ceil</span>(<span class="built_in">pow</span>(p,<span class="number">2.0</span>/<span class="number">3.0</span>));</span><br><span class="line">    ll s=<span class="number">1l</span>l;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>; i&lt;=m; i++)&#123;</span><br><span class="line">        hs.Insert(s,i);</span><br><span class="line">        s=s*y%p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">BSGS</span><span class="params">(ll y,ll z,ll p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(z == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll ans=<span class="number">-1</span>,m=<span class="built_in">ceil</span>(<span class="built_in">pow</span>(p,<span class="number">1.0</span>/<span class="number">3.0</span>)),s=inv(z,p);</span><br><span class="line">    ll up=<span class="built_in">ceil</span>(<span class="built_in">pow</span>(p,<span class="number">2.0</span>/<span class="number">3.0</span>));</span><br><span class="line">    ll x=qpow(y,up,p);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>; i&lt;=m; i++)&#123;</span><br><span class="line">        s=s*x%p;</span><br><span class="line">        ll fin=hs.Find(s);</span><br><span class="line">        <span class="keyword">if</span>(fin!=<span class="number">-1</span>)&#123;</span><br><span class="line">            ans=i*up-fin;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n,p,x,a,b,v,T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld %lld %lld"</span>,&amp;n,&amp;x,&amp;a,&amp;b,&amp;p);</span><br><span class="line">        ll q;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;q);</span><br><span class="line">        Init(a,p);</span><br><span class="line">        <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;v);</span><br><span class="line">            <span class="keyword">if</span>(a==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(x==v) <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(b==v) <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a==<span class="number">1</span>)&#123;</span><br><span class="line">                ll ans=((v-x)*inv(b,p)+p)%p;</span><br><span class="line">                <span class="keyword">if</span>(ans&gt;=n) ans=<span class="number">-1</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ll z=(((a<span class="number">-1</span>)*v+b)%p*(inv(((a<span class="number">-1</span>)*x+b)%p,p)))%p;</span><br><span class="line">            ll ans=BSGS(a,z,p);</span><br><span class="line">            <span class="keyword">if</span>(ans &gt;= n) ans=<span class="number">-1</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用于解决$y^x \equiv z\ (mod\ p)$，给定$y,z,p \geq 1$，求解$x$。&lt;/p&gt;
    
    </summary>
    
      <category term="数学" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>kmp&amp;exkmp</title>
    <link href="http://yoursite.com/2019/07/19/kmp/"/>
    <id>http://yoursite.com/2019/07/19/kmp/</id>
    <published>2019-07-19T15:28:41.647Z</published>
    <updated>2019-08-06T07:05:10.385Z</updated>
    
    <content type="html"><![CDATA[<p>之前写过kmp的算法，lwl给了我一个模板，现在再写就出问题了，<del>出来挨打！</del>，不过还好发现的及时。</p><a id="more"></a><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p><a href="https://www.spoj.com/problems/EPALIN/" target="_blank" rel="noopener">Extend to Palindrome</a></p><p>题意：就是在一个字符串最后添加最少的字符，使得字符串回文。</p><p>思路：求一个正序的串，和一个逆序的串，求其中的正向的后缀和逆向的前缀相等的长度最大值，最后先输出正向的串，在输出逆序中最大长度之后的字符。</p><p>比如说 正序：abaa，逆序：aaba ，那么最长的长度就是2，为aa，然后就输出abaa ba就好了，可以kmp或者hash求最长的长度。</p><p>KMP法（模板拿稳了）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">char</span> t[maxn];</span><br><span class="line"><span class="keyword">int</span> nex[maxn],len;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    nex[<span class="number">0</span>]=j=<span class="number">-1</span>;</span><br><span class="line">    i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;len)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j!=<span class="number">-1</span> &amp;&amp; s[j]!=s[i]) j=nex[j];</span><br><span class="line">        nex[++i]=++j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//原串t，目的串s</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;len&amp;&amp;j&lt;len)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j!=<span class="number">-1</span> &amp;&amp; t[i]!=s[j]) j=nex[j];</span><br><span class="line">        i++;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in.txt","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("out.txt","w",stdout);</span></span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s"</span>,t))&#123;</span><br><span class="line">        len=<span class="built_in">strlen</span>(t);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            s[i]=t[len-i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        s[len]=<span class="string">'\0'</span>;</span><br><span class="line">        cal();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>,t);</span><br><span class="line">        <span class="keyword">int</span> tt=kmp();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=tt; i&lt;len; i++) <span class="built_in">putchar</span>(s[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hash留坑吧……</p><p>后记：如果是求在任意位置插入任意字符，求插入的最少字符的个数，做法就是区间dp。</p><hr><h2 id="扩展KMP"><a href="#扩展KMP" class="headerlink" title="扩展KMP"></a>扩展KMP</h2><p>用kmp硬刚扩展kmp算法，我哭了。😭</p><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6629" target="_blank" rel="noopener">HDU6629</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll maxn=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">char</span> t[maxn];</span><br><span class="line">ll nex[maxn],len;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(nex,<span class="number">0</span>,<span class="keyword">sizeof</span> nex);</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    nex[<span class="number">0</span>]=j=<span class="number">-1</span>;</span><br><span class="line">    i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;len)&#123;</span><br><span class="line">        <span class="keyword">while</span>(s[j]!=s[i] &amp;&amp; j!=<span class="number">-1</span>) j=nex[j];</span><br><span class="line">        nex[++i]=++j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll Next[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">char</span> t[],ll m)</span></span>&#123;</span><br><span class="line">    Next[<span class="number">0</span>]=m;</span><br><span class="line">    ll j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j+<span class="number">1</span>&lt;m&amp;&amp;t[j]==t[j+<span class="number">1</span>]) j++;</span><br><span class="line">    Next[<span class="number">1</span>]=j;</span><br><span class="line">    ll k=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;m;i++)&#123;</span><br><span class="line">        ll p=Next[k]+k<span class="number">-1</span>;</span><br><span class="line">        ll L=Next[i-k];</span><br><span class="line">        <span class="keyword">if</span>(i+L&lt;p+<span class="number">1</span>) Next[i]=L;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            j=max(<span class="number">0L</span>L,p-i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(i+j&lt;m&amp;&amp;t[i+j]==t[j]) j++;</span><br><span class="line">            Next[i]=j;</span><br><span class="line">            k=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">        len=<span class="built_in">strlen</span>(s);</span><br><span class="line">        cal();</span><br><span class="line">        getNext(s,len);</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="comment">//printf("%d\n",Next[i]);</span></span><br><span class="line">            ans+=(Next[i]);</span><br><span class="line">            <span class="keyword">if</span>(Next[i]+i&gt;=len)ans+=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> ans++; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>（感谢清巨orz）</p><h3 id="1-KMP"><a href="#1-KMP" class="headerlink" title="1.KMP"></a>1.KMP</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//next[i] 表示t[i-next[i]...i-1]=t[0...next[i]-1]</span></span><br><span class="line"><span class="comment">//循环节len=m%(m-next[m])==0?m-next[m]:1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">char</span> t[],<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    j=Next[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;m)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j!=<span class="number">-1</span>&amp;&amp;t[i]!=t[j]) j=Next[j];</span><br><span class="line">        Next[++i]=++j;</span><br><span class="line">        <span class="comment">//if(t[++i]==t[++j]) Next[i]=Next[j]; //优化</span></span><br><span class="line">        <span class="comment">//else Next[i]=j;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span> s[],<span class="keyword">int</span> n,<span class="keyword">char</span> t[],<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    getNext(t,m);</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j==<span class="number">-1</span>&amp;&amp;s[i]!=t[j]) j=next[j];</span><br><span class="line">        i++,j++;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=m)&#123;<span class="comment">//匹配成功</span></span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-扩展KMP"><a href="#2-扩展KMP" class="headerlink" title="2.扩展KMP"></a>2.扩展KMP</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//next[i]表示t[i...m-1]与t[0...m-1]的最长公共前缀</span></span><br><span class="line"><span class="comment">//extend[i]表示s[i...n-1]与t[0...m-1]的最长公共前缀</span></span><br><span class="line"><span class="keyword">int</span> Next[maxn],extend[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">char</span> t[],<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    Next[<span class="number">0</span>]=m;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j+<span class="number">1</span>&lt;m&amp;&amp;t[j]==t[j+<span class="number">1</span>]) j++;</span><br><span class="line">    Next[<span class="number">1</span>]=j;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> p=Next[k]+k<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> L=Next[i-k];</span><br><span class="line">        <span class="keyword">if</span>(i+L&lt;p+<span class="number">1</span>) Next[i]=L;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            j=max(<span class="number">0</span>,p-i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(i+j&lt;m&amp;&amp;t[i+j]==t[j]) j++;</span><br><span class="line">            Next[i]=j;</span><br><span class="line">            k=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extendkmp</span><span class="params">(<span class="keyword">char</span> t[],<span class="keyword">int</span> m,<span class="keyword">char</span> s[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    getNext(t,m);</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;n&amp;&amp;j&lt;m&amp;&amp;t[j]==s[j]) j++;</span><br><span class="line">    extend[<span class="number">0</span>]=j;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> p=extend[k]+k<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> L=Next[i-k];</span><br><span class="line">        <span class="keyword">if</span>(i+L&lt;p+<span class="number">1</span>) extend[i]=L;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            j=max(<span class="number">0</span>,p-i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(i+j&lt;n&amp;&amp;j&lt;m&amp;&amp;s[i+j]==t[j]) j++;</span><br><span class="line">            extend[i]=j;</span><br><span class="line">            k=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前写过kmp的算法，lwl给了我一个模板，现在再写就出问题了，&lt;del&gt;出来挨打！&lt;/del&gt;，不过还好发现的及时。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>Codeforces Round</title>
    <link href="http://yoursite.com/2019/07/18/cf190717/"/>
    <id>http://yoursite.com/2019/07/18/cf190717/</id>
    <published>2019-07-18T02:57:16.330Z</published>
    <updated>2019-07-18T03:04:16.506Z</updated>
    
    <content type="html"><![CDATA[<p><del>差点掉分</del>，D2有思路最后bug多多。然后A题让我们知道了自己英语是白学了</p><a id="more"></a><h2 id="A-Drinks-Choosing"><a href="#A-Drinks-Choosing" class="headerlink" title="A.Drinks Choosing"></a><a href="https://codeforces.com/contest/1195/problem/A" target="_blank" rel="noopener">A.Drinks Choosing</a></h2><p>题意：#%…￥%￥%…￥%……&amp;………&amp;%#￥%#￥…#^#**&amp;#@$#()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1100</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> b[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="comment">//memset(vis,2,sizeof vis);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        b[a[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(b+<span class="number">1</span>,b+<span class="number">1</span>+k);</span><br><span class="line">    <span class="keyword">int</span> all=n/<span class="number">2</span>+n%<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=k; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i]%<span class="number">2</span>==<span class="number">0</span> &amp;&amp; b[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">            ans+=b[i];</span><br><span class="line">            all-=(b[i]/<span class="number">2</span>);</span><br><span class="line">            b[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(b[i]%<span class="number">2</span>==<span class="number">1</span> &amp;&amp; b[i]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            ans+=(b[i]<span class="number">-1</span>);</span><br><span class="line">            all-=(b[i]/<span class="number">2</span>);</span><br><span class="line">            b[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans+all);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Sport-Mafia"><a href="#B-Sport-Mafia" class="headerlink" title="B.Sport Mafia"></a><a href="https://codeforces.com/contest/1195/problem/B" target="_blank" rel="noopener">B.Sport Mafia</a></h2><p>推公式，答案就是: $n- \frac { { \sqrt {8 * k + 8 * n + 9 }  } - 3 } {2}$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;n,&amp;k);</span><br><span class="line">    ll tmp=n-(<span class="number">-3</span>+(ll)<span class="built_in">sqrt</span>(<span class="number">9</span>+<span class="number">8</span>*n+<span class="number">8</span>*k))/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Basketball-Exercise"><a href="#C-Basketball-Exercise" class="headerlink" title="C.Basketball Exercise"></a><a href="https://codeforces.com/contest/1195/problem/C" target="_blank" rel="noopener">C.Basketball Exercise</a></h2><p>dp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll maxn=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">ll a[maxn],b[maxn];</span><br><span class="line">ll n;</span><br><span class="line">ll dp[maxn][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=a[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>]=b[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>]=a[<span class="number">1</span>]+b[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>]=a[<span class="number">0</span>]+b[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">2</span>; i&lt;n; i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>]=max(dp[i<span class="number">-1</span>][<span class="number">1</span>],max(dp[i<span class="number">-2</span>][<span class="number">0</span>],dp[i<span class="number">-2</span>][<span class="number">1</span>]))+a[i];</span><br><span class="line">        dp[i][<span class="number">1</span>]=max(dp[i<span class="number">-1</span>][<span class="number">0</span>],max(dp[i<span class="number">-2</span>][<span class="number">1</span>],dp[i<span class="number">-2</span>][<span class="number">0</span>]))+b[i];</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,max(dp[n<span class="number">-1</span>][<span class="number">0</span>],dp[n<span class="number">-1</span>][<span class="number">1</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D1-Submarine-in-the-Rybinsk-Sea"><a href="#D1-Submarine-in-the-Rybinsk-Sea" class="headerlink" title="D1.Submarine in the Rybinsk Sea"></a><a href="https://codeforces.com/contest/1195/problem/D1" target="_blank" rel="noopener">D1.Submarine in the Rybinsk Sea</a></h2><p>求贡献</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line">ll n;</span><br><span class="line">ll a[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">        ll len=<span class="built_in">strlen</span>(s);</span><br><span class="line">        ll tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            tmp=(tmp+(s[i]-<span class="string">'0'</span>))%mod;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;len<span class="number">-1</span>) tmp=(tmp*<span class="number">100</span>)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//printf("%lld %lld\n",tmp,tmp*10);</span></span><br><span class="line">        ans=(ans+tmp)%mod;</span><br><span class="line">        ans=(ans+tmp*<span class="number">10</span>)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans*n%mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D2-Submarine-in-the-Rybinsk-Sea"><a href="#D2-Submarine-in-the-Rybinsk-Sea" class="headerlink" title="D2.Submarine in the Rybinsk Sea"></a><a href="https://codeforces.com/contest/1195/problem/D2" target="_blank" rel="noopener">D2.Submarine in the Rybinsk Sea</a></h2><p>与D1不同的是，每个数的长度不一样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line">ll n;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100010</span>][<span class="number">20</span>];</span><br><span class="line">ll vis[<span class="number">20</span>];</span><br><span class="line">ll ba[<span class="number">25</span>];</span><br><span class="line">ll sum[<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ba[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>; i&lt;<span class="number">25</span>; i++)&#123;</span><br><span class="line">        ba[i]=ba[i<span class="number">-1</span>]*<span class="number">10</span>%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s[i]);</span><br><span class="line">        ll len=<span class="built_in">strlen</span>(s[i]);</span><br><span class="line">        vis[len]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">18</span>; i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">        sum[i]=sum[i+<span class="number">1</span>]+vis[i];</span><br><span class="line">        <span class="comment">//printf("%lld %lld %lld\n",i,sum[i],vis[2]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    ll cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll ii=<span class="number">0</span>; ii&lt;n; ii++)&#123;</span><br><span class="line">        ll c=<span class="built_in">strlen</span>(s[ii]);</span><br><span class="line">        <span class="keyword">for</span>(ll i=c; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            ll tmp=<span class="number">0</span>;</span><br><span class="line">            ll f=<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">//puts(s[ii]);</span></span><br><span class="line">            <span class="keyword">for</span>(ll k=<span class="number">0</span>; k&lt;c-i; k++)&#123;</span><br><span class="line">                tmp=(tmp*<span class="number">10</span>)%mod;</span><br><span class="line">                tmp=(tmp+s[ii][k]-<span class="string">'0'</span>)%mod;</span><br><span class="line">                f=k;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp=(tmp*ba[(i)*<span class="number">2</span>])%mod*(vis[i]*<span class="number">2</span>)%mod;</span><br><span class="line">            <span class="comment">//printf("%lld &amp;&amp; %lld %lld %lld\n",tmp,f,ba[i*2],c);</span></span><br><span class="line">            f++;</span><br><span class="line">            ll tmpp=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(ll k=f; k&lt;c; k++)&#123;</span><br><span class="line">                tmpp=(tmpp+(s[ii][k]-<span class="string">'0'</span>))%mod;</span><br><span class="line">                <span class="comment">//printf("%c %lld\n",s[ii][k],tmpp);</span></span><br><span class="line">                <span class="keyword">if</span>(k&lt;c<span class="number">-1</span>) tmpp=(tmpp*<span class="number">100</span>)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//printf("%lld %lld %lld\n",tmpp,tmpp*10,sum[c]);</span></span><br><span class="line">            <span class="keyword">if</span>(tmp==<span class="number">0</span>) tmp=(tmp+((tmpp+tmpp*<span class="number">10</span>)*sum[c]%mod))%mod;</span><br><span class="line">            <span class="keyword">else</span> tmp=(tmp+((tmpp+tmpp*<span class="number">10</span>)*vis[i]%mod))%mod;</span><br><span class="line">            ans=(ans+tmp)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//printf("%lld %lld\n",tmp,tmp*10);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans%mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;del&gt;差点掉分&lt;/del&gt;，D2有思路最后bug多多。然后A题让我们知道了自己英语是白学了&lt;/p&gt;
    
    </summary>
    
      <category term="codeforces" scheme="http://yoursite.com/categories/codeforces/"/>
    
    
  </entry>
  
</feed>
