<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hope_Y&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-10T11:43:17.697Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Hope_Y</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>主席树</title>
    <link href="http://yoursite.com/2019/07/10/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    <id>http://yoursite.com/2019/07/10/主席树/</id>
    <published>2019-07-10T02:56:42.874Z</published>
    <updated>2019-07-10T11:43:17.697Z</updated>
    
    <content type="html"><![CDATA[<p><del>狂补数据结构的知识！！还需慢慢消化🐷</del>主席树的本质就是线段树，叫做可持久化线段树，最为经典的问题就是查询区间第k小的数<del>(说是第k大，<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2665" target="_blank" rel="noopener">HDU2665</a>上面说$the \  k_{th} \ big \ number$)</del>，分静态(不带修改)和动态(带修改)两种。</p><a id="more"></a><h2 id="POJ2104-HDU2665-静态"><a href="#POJ2104-HDU2665-静态" class="headerlink" title="POJ2104||HDU2665(静态)"></a><a href="http://poj.org/problem?id=2104" target="_blank" rel="noopener">POJ2104</a>||<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2665" target="_blank" rel="noopener">HDU2665</a>(静态)</h2><p>题意：主席树入门题，题意是查询区间内第k小，主席树入门模板题，可以参考这篇<a href="https://blog.csdn.net/williamsun0122/article/details/77871278" target="_blank" rel="noopener">blog</a>。<del>POJ上面的数据好像有点弱</del>。</p><p>每次加入一个新的节点，就要更新线段树，T[i]代表第i颗线段树的根节点，sum[i]表示节点i对应区间的个数，然后根据线段树的性质，左边的子节点总比右边的子节点的数小，那么左边子节点总数就说明左边子节点的最小的数还要小，然后根据左右子节点的个数可以判断出我要找的第k小数在哪个区间内，递归查找就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=maxn*<span class="number">40</span>;</span><br><span class="line"><span class="keyword">int</span> T[maxn],L[maxm],R[maxm],sum[maxm];</span><br><span class="line"><span class="keyword">int</span> sz[maxn],h[maxn]; <span class="comment">//sz为原序列,h为离散化之后的序列</span></span><br><span class="line"><span class="keyword">int</span> n,q,ql,qr,k,tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span>&amp; rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    rt=++tot;</span><br><span class="line">    sum[rt]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(L[rt],l,mid);</span><br><span class="line">    build(R[rt],mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span>&amp; rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> pre,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    rt=++tot;</span><br><span class="line">    L[rt]=L[pre];</span><br><span class="line">    R[rt]=R[pre];</span><br><span class="line">    sum[rt]=sum[pre]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) update(L[rt],l,mid,L[pre],x);</span><br><span class="line">    <span class="keyword">else</span> update(R[rt],mid+<span class="number">1</span>,r,R[pre],x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> e,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res=sum[L[e]]-sum[L[s]];</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= res) <span class="keyword">return</span> query(L[s],L[e],l,mid,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(R[s],R[e],mid+<span class="number">1</span>,r,k-res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;q);</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;sz[i]);</span><br><span class="line">        h[i]=sz[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(h+<span class="number">1</span>,h+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">int</span> num=unique(h+<span class="number">1</span>,h+<span class="number">1</span>+n)-(h+<span class="number">1</span>);</span><br><span class="line">    build(T[<span class="number">0</span>],<span class="number">1</span>,num);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) update(T[i],<span class="number">1</span>,num,T[i<span class="number">-1</span>],lower_bound(h+<span class="number">1</span>,h+<span class="number">1</span>+num,sz[i])-(h));</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;ql,&amp;qr,&amp;k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,h[query(T[ql<span class="number">-1</span>],T[qr],<span class="number">1</span>,num,k)]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ZOJ-2122-Dynamic-Rankings-动态"><a href="#ZOJ-2122-Dynamic-Rankings-动态" class="headerlink" title="ZOJ-2122.Dynamic Rankings(动态)"></a><a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2112" target="_blank" rel="noopener">ZOJ-2122.Dynamic Rankings(动态)</a></h2><p>题意：动态求区间第k小，可参考<a href="https://blog.csdn.net/WilliamSun0122/article/details/77885781" target="_blank" rel="noopener">blog</a>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">6e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> T[maxn],S[maxn],L[maxn*<span class="number">32</span>],R[maxn*<span class="number">32</span>],sum[maxn*<span class="number">32</span>];</span><br><span class="line"><span class="keyword">int</span> sz[maxn],h[maxn];</span><br><span class="line"><span class="keyword">int</span> ul[maxn],ur[maxn];</span><br><span class="line"><span class="keyword">int</span> tot,num,n,q;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,k;</span><br><span class="line">    <span class="keyword">bool</span> flag; <span class="comment">//ture代表Q，false代表C</span></span><br><span class="line">&#125;Q[maxm];  <span class="comment">//存储询问</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span>&amp; rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    rt = ++tot;</span><br><span class="line">    sum[rt]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(L[rt],l,mid);</span><br><span class="line">    build(R[rt],mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span>&amp; rt,<span class="keyword">int</span> pre,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    rt = ++tot;</span><br><span class="line">    L[rt] = L[pre];</span><br><span class="line">    R[rt] = R[pre];</span><br><span class="line">    sum[rt] = sum[pre]+val;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) update(L[rt],L[pre],l,mid,x,val);</span><br><span class="line">    <span class="keyword">else</span> update(R[rt],R[pre],mid+<span class="number">1</span>,r,x,val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = lower_bound(h+<span class="number">1</span>,h+<span class="number">1</span>+num,sz[x])-h;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)&#123;</span><br><span class="line">        update(S[x],S[x],<span class="number">1</span>,num,res,val);</span><br><span class="line">        x += lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">bool</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag) res += sum[L[ur[x]]];</span><br><span class="line">        <span class="keyword">else</span> res += sum[L[ul[x]]];</span><br><span class="line">        x -= lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> e,<span class="keyword">int</span> ts,<span class="keyword">int</span> te,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = Sum(e,<span class="literal">true</span>)-Sum(s,<span class="literal">false</span>)+sum[L[te]]-sum[L[ts]];</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=res)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=e;i;i-=lowbit(i)) ur[i] = L[ur[i]];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=s;i;i-=lowbit(i)) ul[i] = L[ul[i]];</span><br><span class="line">        <span class="keyword">return</span> query(s,e,L[ts],L[te],l,mid,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=e;i;i-=lowbit(i)) ur[i] = R[ur[i]];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=s;i;i-=lowbit(i)) ul[i] = R[ul[i]];</span><br><span class="line">        <span class="keyword">return</span> query(s,e,R[ts],R[te],mid+<span class="number">1</span>,r,k-res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">char</span> str[<span class="number">5</span>];</span><br><span class="line">        num=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,sz+i),h[++num]=sz[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line">            <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">'Q'</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;Q[i].l,&amp;Q[i].r,&amp;Q[i].k);</span><br><span class="line">                Q[i].flag=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;Q[i].l,&amp;Q[i].r);</span><br><span class="line">                Q[i].flag=<span class="literal">false</span>;</span><br><span class="line">                h[++num]=Q[i].r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(h+<span class="number">1</span>,h+<span class="number">1</span>+num);</span><br><span class="line">        <span class="keyword">int</span> tmp = unique(h+<span class="number">1</span>,h+<span class="number">1</span>+num)-h<span class="number">-1</span>;</span><br><span class="line">        num = tmp;</span><br><span class="line">        tot=<span class="number">0</span>;</span><br><span class="line">        build(T[<span class="number">0</span>],<span class="number">1</span>,num);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) update(T[i],T[i<span class="number">-1</span>],<span class="number">1</span>,num,lower_bound(h+<span class="number">1</span>,h+<span class="number">1</span>+num,sz[i])-h,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) S[i] = T[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Q[i].flag)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=Q[i].r;j;j-=lowbit(j)) ur[j] = S[j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=Q[i].l<span class="number">-1</span>;j;j-=lowbit(j)) ul[j] = S[j];</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,h[query(Q[i].l<span class="number">-1</span>,Q[i].r,T[Q[i].l<span class="number">-1</span>],T[Q[i].r],<span class="number">1</span>,num,Q[i].k)]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                add(Q[i].l,<span class="number">-1</span>);</span><br><span class="line">                sz[Q[i].l] = Q[i].r;</span><br><span class="line">                add(Q[i].l,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;del&gt;狂补数据结构的知识！！还需慢慢消化🐷&lt;/del&gt;主席树的本质就是线段树，叫做可持久化线段树，最为经典的问题就是查询区间第k小的数&lt;del&gt;(说是第k大，&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=2665&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HDU2665&lt;/a&gt;上面说$the \  k_{th} \ big \ number$)&lt;/del&gt;，分静态(不带修改)和动态(带修改)两种。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>莫队算法</title>
    <link href="http://yoursite.com/2019/07/08/%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/07/08/莫队算法/</id>
    <published>2019-07-08T12:56:01.976Z</published>
    <updated>2019-07-09T09:25:46.630Z</updated>
    
    <content type="html"><![CDATA[<p><del>自从上次邀请赛之后说要学习莫队算法，一直拖到现在，💊</del>总的来说，莫队算法是一种离线分块的算法，将总区间分成若干个块($\sqrt{n}$)，然后对每一块更新查询$ans$的值。时间复杂度$O\ (n\sqrt{n})$</p><a id="more"></a><p>这里强烈安利一篇<a href="http://www.myblog.link/2016/01/26/MO-s-Algorithm/" target="_blank" rel="noopener">blog</a></p><h2 id="SPOJ-D-query"><a href="#SPOJ-D-query" class="headerlink" title="SPOJ D-query"></a><a href="https://www.spoj.com/problems/DQUERY/" target="_blank" rel="noopener">SPOJ D-query</a></h2><p>题意：给定一个长度为n序列，再给定m次查询，每次查询区间内出现元素的种类数</p><p>思路：<del>听说可以主席树或者离线树状数组做，</del>莫队算法的入门题，耗时270ms。将所有查询分成$\sqrt{n}$个块，再按照块排序，然后对于每个块可以利用之前算过的答案(即数量)来更新当前的答案(数量)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn],n,m,cnt[maxn],ans=<span class="number">0</span>,anss[maxn],block;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> L,R,i;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.L/block != y.L/block) <span class="keyword">return</span> x.L/block &lt; y.L/block;</span><br><span class="line">    <span class="keyword">return</span> x.R &lt; y.R;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    cnt[a[p]]++;</span><br><span class="line">    <span class="keyword">if</span>(cnt[a[p]] == <span class="number">1</span>) ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    cnt[a[p]]--;</span><br><span class="line">    <span class="keyword">if</span>(cnt[a[p]] == <span class="number">0</span>) ans--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    block=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;q[i].L,&amp;q[i].R);</span><br><span class="line">        q[i].i=i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q+<span class="number">1</span>,q+m+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">int</span> cL=<span class="number">1</span>,cR=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> L=q[i].L,R=q[i].R;</span><br><span class="line">        <span class="keyword">while</span>(cL &lt; L) del(cL++);</span><br><span class="line">        <span class="keyword">while</span>(cL &gt; L) add(--cL);</span><br><span class="line">        <span class="keyword">while</span>(cR &lt; R) add(++cR);</span><br><span class="line">        <span class="keyword">while</span>(cR &gt; R) del(cR--);</span><br><span class="line">        anss[q[i].i]=ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,anss[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="codeforces-Powerful-array"><a href="#codeforces-Powerful-array" class="headerlink" title="codeforces-Powerful array"></a><a href="https://codeforces.com/contest/86/problem/D" target="_blank" rel="noopener">codeforces-Powerful array</a></h2><p>题意：给定n个元素序列，m次询问，要统计区间内[l,r]元素个数乘以元素的值的和$\sum_{l}^{r}cnt_i^2*i$</p><p>思路：莫队算法，只需要修改del函数和add函数就行，在每次更新cnt前面，加上<code>ans-=(1LL*a[p]*cnt[a[p]]*cnt[a[p]]);</code>，更新之后再加上<code>ans+=(1LL*a[p]*cnt[a[p]]*cnt[a[p]]);</code>，注意不能把全部变量变成long long，会超时的😑。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn],n,m,cnt[maxn],block;</span><br><span class="line">ll ans=<span class="number">0</span>,anss[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> L,R,i;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.L/block != y.L/block) <span class="keyword">return</span> x.L/block &lt; y.L/block;</span><br><span class="line">    <span class="keyword">return</span> x.R &lt; y.R;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll p)</span></span>&#123;</span><br><span class="line">    ans-=(<span class="number">1L</span>L*a[p]*cnt[a[p]]*cnt[a[p]]);</span><br><span class="line">    cnt[a[p]]++;</span><br><span class="line">    ans+=(<span class="number">1L</span>L*a[p]*cnt[a[p]]*cnt[a[p]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(ll p)</span></span>&#123;</span><br><span class="line">    ans-=(<span class="number">1L</span>L*a[p]*cnt[a[p]]*cnt[a[p]]);</span><br><span class="line">    cnt[a[p]]--;</span><br><span class="line">    ans+=(<span class="number">1L</span>L*a[p]*cnt[a[p]]*cnt[a[p]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line">    block=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;q[i].L,&amp;q[i].R);</span><br><span class="line">        q[i].i=i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q+<span class="number">1</span>,q+m+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">int</span> cL=<span class="number">1</span>,cR=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> L=q[i].L,R=q[i].R;</span><br><span class="line">        <span class="keyword">while</span>(cL &lt; L) del(cL++);</span><br><span class="line">        <span class="keyword">while</span>(cL &gt; L) add(--cL);</span><br><span class="line">        <span class="keyword">while</span>(cR &lt; R) add(++cR);</span><br><span class="line">        <span class="keyword">while</span>(cR &gt; R) del(cR--);</span><br><span class="line">        anss[q[i].i]=ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>; i&lt;=m; i++) <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>,anss[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HDU-6534-Chika-and-Friendly-Pairs"><a href="#HDU-6534-Chika-and-Friendly-Pairs" class="headerlink" title="HDU-6534.Chika and Friendly Pairs"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6534" target="_blank" rel="noopener">HDU-6534.Chika and Friendly Pairs</a></h2><p><del>湘潭邀请赛C题，当时卡的题，现在补掉</del></p><p>题意：给定一个长度为$n$的序列，$m$次询问，一个数$k$。询问你在区间$[l\ ,\ r]$中，符合$|a_i-a_j|\leq k$并且$i &lt; j$有多少对这样的数。</p><p>思路：<strong>莫队+树状数组+离散化</strong>，首先对于每次查询$a_i$，我只要查询区间内$[a_i-k\ ,\ a_i+k]$的种数即可，利用树状数组就行，然后由于序列中的数最大有$10^9$，而数的个数只有$27000$，就可以通过离散化将其缩小，再用莫队算法。</p><p>对于新加进来的数$a_i$，<code>ans+=(query(up[l])-query(lowa[l]))</code>，然后再<code>add(mida[l],1)</code>，仔细想想就会发现，如果你先写add函数，就会把本身的值也算进去。</p><p>对于去掉的数$a_i$，则需要先<code>add(mida[l],-1)</code>，然后再更新ans，<code>ans-=(query(up[l])-query(lowa[l]))</code>，因为query查询的时候会把mida[l]也计算进来。</p><p>离散化的模版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//n 原数组大小 num 原数组中的元素 lsh 离散化的数组 cnt 离散化后的数组大小 </span></span><br><span class="line"><span class="keyword">int</span> lsh[MAXN],cnt,num[MAXN],n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num[i]);</span><br><span class="line">lsh[i]=num[i];</span><br><span class="line">&#125;</span><br><span class="line">sort(lsh+<span class="number">1</span>,lsh+n+<span class="number">1</span>);</span><br><span class="line">cnt = unique(lsh+<span class="number">1</span>,lsh+n+<span class="number">1</span>)-(lsh+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">num[i]=lower_bound(lsh+<span class="number">1</span>,lsh+cnt+<span class="number">1</span>,num[i])-lsh;</span><br></pre></td></tr></table></figure><p>该题ac的代码（390MS）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">27010</span>;</span><br><span class="line"><span class="keyword">int</span> mp[maxn*<span class="number">3</span>],a[maxn],upa[maxn],lowa[maxn],mida[maxn];</span><br><span class="line"><span class="keyword">int</span> tree[maxn*<span class="number">3</span>],ans=<span class="number">0</span>,anss[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m,block,k;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node i,node j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i.l/block != j.l/block) <span class="keyword">return</span> i.l/block &lt; j.l/block;</span><br><span class="line">    <span class="keyword">return</span> i.r &lt; j.r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x; i&lt;maxn*<span class="number">3</span>; i+=lowbit(i)) tree[i]+=val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x; i; i-=lowbit(i)) ans+=tree[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">1</span>;</span><br><span class="line">    block=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        mp[sum++]=a[i];</span><br><span class="line">        mp[sum++]=a[i]+k;</span><br><span class="line">        mp[sum++]=a[i]-k<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(mp+<span class="number">1</span>,mp+sum);</span><br><span class="line">    <span class="keyword">int</span> num=unique(mp+<span class="number">1</span>,mp+sum)-(mp+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        pos=lower_bound(mp+<span class="number">1</span>,mp+num+<span class="number">1</span>,a[i]+k)-mp;</span><br><span class="line">        upa[i]=pos;</span><br><span class="line">        pos=lower_bound(mp+<span class="number">1</span>,mp+num+<span class="number">1</span>,a[i]-k<span class="number">-1</span>)-mp;</span><br><span class="line">        lowa[i]=pos;</span><br><span class="line">        pos=lower_bound(mp+<span class="number">1</span>,mp+num+<span class="number">1</span>,a[i])-mp;</span><br><span class="line">        mida[i]=pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;q[i].l,&amp;q[i].r);</span><br><span class="line">        q[i].i=i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q+<span class="number">1</span>,q+m+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">int</span> cL=<span class="number">1</span>,cR=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> L=q[i].l;</span><br><span class="line">        <span class="keyword">int</span> R=q[i].r;</span><br><span class="line">        <span class="keyword">while</span>(cR&lt;R)&#123;</span><br><span class="line">            cR++;</span><br><span class="line">            ans+=(query(upa[cR])-query(lowa[cR]));</span><br><span class="line">            add(mida[cR],<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cR&gt;R)&#123;</span><br><span class="line">            add(mida[cR],<span class="number">-1</span>);</span><br><span class="line">            ans-=(query(upa[cR])-query(lowa[cR]));</span><br><span class="line">            cR--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cL&lt;L)&#123;</span><br><span class="line">            add(mida[cL],<span class="number">-1</span>);</span><br><span class="line">            ans-=(query(upa[cL])-query(lowa[cL]));</span><br><span class="line">            cL++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cL&gt;L)&#123;</span><br><span class="line">            cL--;</span><br><span class="line">            ans+=(query(upa[cL])-query(lowa[cL]));</span><br><span class="line">            add(mida[cL],<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        anss[q[i].i]=ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,anss[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;del&gt;自从上次邀请赛之后说要学习莫队算法，一直拖到现在，💊&lt;/del&gt;总的来说，莫队算法是一种离线分块的算法，将总区间分成若干个块($\sqrt{n}$)，然后对每一块更新查询$ans$的值。时间复杂度$O\ (n\sqrt{n})$&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>牛客练习赛49</title>
    <link href="http://yoursite.com/2019/07/06/newcoder190705/"/>
    <id>http://yoursite.com/2019/07/06/newcoder190705/</id>
    <published>2019-07-06T11:15:20.753Z</published>
    <updated>2019-07-07T13:17:16.754Z</updated>
    
    <content type="html"><![CDATA[<p><del>说好的人均3.5道题呢？骗我们打代码</del></p><a id="more"></a><h4 id="A筱玛爱地理"><a href="#A筱玛爱地理" class="headerlink" title="A筱玛爱地理"></a><a href="https://ac.nowcoder.com/acm/contest/946/A" target="_blank" rel="noopener">A筱玛爱地理</a></h4><p>  在经济地理学中，交通的联结度表示交通网络的发达程度，通常用贝塔指数来计算与比较。若用$V$表示一个交通网络中结点的数量，用$E$表示边的数量，则贝塔指数的计算方式为：$ \beta = \frac{E}{V}$。 </p><p>“实践是检验真理的唯一标准”。作为一个热爱地理的好筱玛，她马上就把新学的知识应用到实践当中去。筱玛一口气出了$n$张交通网络规划图，其中第$i$张交通网络$G_i$有$V_i$个结点和$E_i$条边。筱玛一眼就看出了哪张图好、哪张图坏。但是作为一个负责任的好筱玛，她必须带领同学们一起进步。因此，她需要你将所有的$n$张图按照贝塔指数排序，并求出它们各自的贝塔指数在模$10^9+7$意义下的值</p><p>直接计算$\beta$(浮点数)，然后排序，再求逆元输出取模之后的结果就好了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll t;</span><br><span class="line">ll x,y;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll n,ll mod)</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) res=res*x%mod;</span><br><span class="line">        x=x*x%mod;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    ll v,e;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    ll y;</span><br><span class="line">&#125;a[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node i,node j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i.x&gt;j.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>; i&lt;t; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;a[i].v,&amp;a[i].e);</span><br><span class="line">        <span class="comment">//printf("%lld\n",y*qpow(x,mod-2,mod)%mod);</span></span><br><span class="line">        a[i].y=a[i].e*qpow(a[i].v,mod<span class="number">-2</span>,mod)%mod;</span><br><span class="line">        <span class="comment">//a[i++]=y*qpow(x,mod-2,mod)%mod;</span></span><br><span class="line">        a[i].x=a[i].e*<span class="number">1.0</span>/a[i].v*<span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a,a+t,cmp);</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">0</span>; j&lt;t; j++) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,a[j].y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="D筱玛爱线段树"><a href="#D筱玛爱线段树" class="headerlink" title="D筱玛爱线段树"></a><a href="https://ac.nowcoder.com/acm/contest/946/D" target="_blank" rel="noopener">D筱玛爱线段树</a></h4><p>筱玛的爷爷马爷在游戏中被筱玛吊打了，于是他恼羞成怒，决定给筱玛出这样一道数据结构题：<br>给定一个长度为n的数组A，刚开始每一项的值均为0。<br>支持以下两种操作，操作共m次：<br> 1 l r ：将$A_i \sim A_j$的每一项的值加上1。<br> 2 l r ：执行操作编号在[l,r]内的所有操作各一次，保证r小于当前操作的编号。<br>m次操作结束后，你要告诉马爷A数组变成什么样子了。<br>由于答案可能会很大，你只需要输出数组<br>A中的每个数在模 $10^9+7$ 意义下的值</p><p>方法一：线段树，维护了两棵线段树即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll maxn=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seg</span>&#123;</span></span><br><span class="line">    ll l,r;</span><br><span class="line">    ll mark;</span><br><span class="line">    ll val;</span><br><span class="line">&#125;s[maxn*<span class="number">4</span>],ss[maxn*<span class="number">4</span>];</span><br><span class="line">ll a[maxn];</span><br><span class="line">ll b[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    ll op;</span><br><span class="line">    ll l,r;</span><br><span class="line">&#125;x[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(ll i)</span></span>&#123;</span><br><span class="line">    s[i].val=(s[i&lt;&lt;<span class="number">1L</span>L].val+s[(i&lt;&lt;<span class="number">1L</span>L)|<span class="number">1L</span>L].val)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(ll i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[i].mark)&#123;</span><br><span class="line">        s[i&lt;&lt;<span class="number">1L</span>L].val=(s[i&lt;&lt;<span class="number">1L</span>L].val+((s[i&lt;&lt;<span class="number">1L</span>L].r-s[i&lt;&lt;<span class="number">1L</span>L].l+<span class="number">1L</span>L)*s[i].mark%mod))%mod;</span><br><span class="line">        s[(i&lt;&lt;<span class="number">1L</span>L)|<span class="number">1L</span>L].val=(s[(i&lt;&lt;<span class="number">1L</span>L)|<span class="number">1L</span>L].val+((s[(i&lt;&lt;<span class="number">1L</span>L)|<span class="number">1L</span>L].r-s[(i&lt;&lt;<span class="number">1L</span>L)|<span class="number">1L</span>L].l+<span class="number">1L</span>L)*s[i].mark%mod))%mod;</span><br><span class="line">        s[i&lt;&lt;<span class="number">1L</span>L].mark=(s[i&lt;&lt;<span class="number">1L</span>L].mark+s[i].mark)%mod;</span><br><span class="line">        s[(i&lt;&lt;<span class="number">1L</span>L)|<span class="number">1L</span>L].mark=(s[(i&lt;&lt;<span class="number">1L</span>L)|<span class="number">1L</span>L].mark+s[i].mark)%mod;</span><br><span class="line">        s[i].mark=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll i,ll l,ll r)</span></span>&#123;</span><br><span class="line">    s[i].l=l;</span><br><span class="line">    s[i].r=r;</span><br><span class="line">    s[i].mark=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        s[i].val=a[l];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mid=(l+r)&gt;&gt;<span class="number">1L</span>L;</span><br><span class="line">    build(i&lt;&lt;<span class="number">1L</span>L,l,mid);</span><br><span class="line">    build((i&lt;&lt;<span class="number">1L</span>L)|<span class="number">1L</span>L,mid+<span class="number">1L</span>L,r);</span><br><span class="line">    pushup(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll i,ll l,ll r,ll sl,ll sr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=sl &amp;&amp; r&lt;=sr) <span class="keyword">return</span> s[i].val;</span><br><span class="line">    pushdown(i);</span><br><span class="line">    ll mid=(l+r)&gt;&gt;<span class="number">1L</span>L;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid&gt;=sl) sum=(sum+query(i&lt;&lt;<span class="number">1L</span>L,l,mid,sl,sr))%mod;</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;sr) sum=(sum+query((i&lt;&lt;<span class="number">1L</span>L)|<span class="number">1L</span>L,mid+<span class="number">1L</span>L,r,sl,sr))%mod;</span><br><span class="line">    <span class="keyword">return</span> sum%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata</span><span class="params">(ll i,ll l,ll r,ll sl,ll sr,ll val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=sl &amp;&amp; r&lt;=sr)&#123;</span><br><span class="line">        s[i].val=(s[i].val+(s[i].r-s[i].l+<span class="number">1L</span>L)*val%mod)%mod;</span><br><span class="line">        s[i].mark=(s[i].mark+val)%mod;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mid=(l+r)&gt;&gt;<span class="number">1L</span>L;</span><br><span class="line">    pushdown(i);</span><br><span class="line">    <span class="keyword">if</span>(mid&gt;=sl) updata(i&lt;&lt;<span class="number">1L</span>L,l,mid,sl,sr,val);</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;sr) updata((i&lt;&lt;<span class="number">1L</span>L)|<span class="number">1L</span>L,mid+<span class="number">1L</span>L,r,sl,sr,val);</span><br><span class="line">    pushup(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup1</span><span class="params">(ll i)</span></span>&#123;</span><br><span class="line">    ss[i].val=(ss[i&lt;&lt;<span class="number">1L</span>L].val+ss[(i&lt;&lt;<span class="number">1L</span>L)|<span class="number">1L</span>L].val)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown1</span><span class="params">(ll i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ss[i].mark)&#123;</span><br><span class="line">        ss[i&lt;&lt;<span class="number">1L</span>L].val=(ss[i&lt;&lt;<span class="number">1L</span>L].val+((ss[i&lt;&lt;<span class="number">1L</span>L].r-ss[i&lt;&lt;<span class="number">1L</span>L].l+<span class="number">1L</span>L)*ss[i].mark%mod))%mod;</span><br><span class="line">        ss[(i&lt;&lt;<span class="number">1L</span>L)|<span class="number">1L</span>L].val=(ss[(i&lt;&lt;<span class="number">1L</span>L)|<span class="number">1L</span>L].val+((ss[(i&lt;&lt;<span class="number">1L</span>L)|<span class="number">1L</span>L].r-ss[(i&lt;&lt;<span class="number">1L</span>L)|<span class="number">1L</span>L].l+<span class="number">1L</span>L)*ss[i].mark%mod))%mod;</span><br><span class="line">        ss[i&lt;&lt;<span class="number">1L</span>L].mark=(ss[i&lt;&lt;<span class="number">1L</span>L].mark+ss[i].mark)%mod;</span><br><span class="line">        ss[(i&lt;&lt;<span class="number">1L</span>L)|<span class="number">1L</span>L].mark=(ss[(i&lt;&lt;<span class="number">1L</span>L)|<span class="number">1L</span>L].mark+ss[i].mark)%mod;</span><br><span class="line">        ss[i].mark=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build1</span><span class="params">(ll i,ll l,ll r)</span></span>&#123;</span><br><span class="line">    ss[i].l=l;</span><br><span class="line">    ss[i].r=r;</span><br><span class="line">    ss[i].mark=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        ss[i].val=b[l];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mid=(l+r)&gt;&gt;<span class="number">1L</span>L;</span><br><span class="line">    build1(i&lt;&lt;<span class="number">1L</span>L,l,mid);</span><br><span class="line">    build1((i&lt;&lt;<span class="number">1L</span>L)|<span class="number">1L</span>L,mid+<span class="number">1L</span>L,r);</span><br><span class="line">    pushup1(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query1</span><span class="params">(ll i,ll l,ll r,ll ssl,ll ssr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=ssl &amp;&amp; r&lt;=ssr) <span class="keyword">return</span> ss[i].val;</span><br><span class="line">    pushdown1(i);</span><br><span class="line">    ll mid=(l+r)&gt;&gt;<span class="number">1L</span>L;</span><br><span class="line">    ll ssum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid&gt;=ssl) ssum=(ssum+query1(i&lt;&lt;<span class="number">1L</span>L,l,mid,ssl,ssr))%mod;</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;ssr) ssum=(ssum+query1((i&lt;&lt;<span class="number">1L</span>L)|<span class="number">1L</span>L,mid+<span class="number">1L</span>L,r,ssl,ssr))%mod;</span><br><span class="line">    <span class="keyword">return</span> ssum%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata1</span><span class="params">(ll i,ll l,ll r,ll ssl,ll ssr,ll val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=ssl &amp;&amp; r&lt;=ssr)&#123;</span><br><span class="line">        ss[i].val=(ss[i].val+(ss[i].r-ss[i].l+<span class="number">1L</span>L)*val%mod)%mod;</span><br><span class="line">        ss[i].mark=(ss[i].mark+val)%mod;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mid=(l+r)&gt;&gt;<span class="number">1L</span>L;</span><br><span class="line">    pushdown1(i);</span><br><span class="line">    <span class="keyword">if</span>(mid&gt;=ssl) updata1(i&lt;&lt;<span class="number">1L</span>L,l,mid,ssl,ssr,val);</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;ssr) updata1((i&lt;&lt;<span class="number">1L</span>L)|<span class="number">1L</span>L,mid+<span class="number">1L</span>L,r,ssl,ssr,val);</span><br><span class="line">    pushup1(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span> a);</span><br><span class="line">    build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;m);</span><br><span class="line">    <span class="comment">//m=100000;</span></span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>; i&lt;=m; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>,&amp;x[i].op,&amp;x[i].l,&amp;x[i].r);</span><br><span class="line">        <span class="comment">//if(i == 1) x[i].op=1,x[i].l=1,x[i].r=n;</span></span><br><span class="line">        <span class="comment">//else x[i].op=2,x[i].l=1,x[i].r=i-1;</span></span><br><span class="line">        b[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for(ll i=1; i&lt;=m; i++) b[i]=1;</span></span><br><span class="line">    build1(<span class="number">1</span>,<span class="number">1</span>,m);</span><br><span class="line">    <span class="comment">//cout&lt;&lt;query1(1,1,m,1,1)&lt;&lt;endl;;</span></span><br><span class="line">    <span class="keyword">for</span>(ll i=m; i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x[i].op == <span class="number">1</span>)&#123;</span><br><span class="line">            updata(<span class="number">1</span>,<span class="number">1</span>,n,x[i].l,x[i].r,query1(<span class="number">1</span>,<span class="number">1</span>,m,i,i));</span><br><span class="line">            <span class="comment">//printf("%d\n",query1(1,1,m,i,i));</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            updata1(<span class="number">1</span>,<span class="number">1</span>,m,x[i].l,x[i].r,query1(<span class="number">1</span>,<span class="number">1</span>,m,i,i));</span><br><span class="line">            <span class="comment">//printf("%lld\n",query1(1,1,m,i,i));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld%c"</span>,query(<span class="number">1</span>,<span class="number">1</span>,n,i,i),i&lt;n?<span class="string">' '</span>:<span class="string">'\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：差分(留坑待补……)</p><h4 id="E筱玛爱游戏"><a href="#E筱玛爱游戏" class="headerlink" title="E筱玛爱游戏"></a><a href="https://ac.nowcoder.com/acm/contest/946/E" target="_blank" rel="noopener">E筱玛爱游戏</a></h4><p>  两个人轮流从桌面上取走一个数，并把这个数放入集合中。 </p><p>  如果在某次操作结束后，集合中存在一个异或和为0的<strong>非空</strong>子集，那么进行这次操作的人输。 </p><p>  如果全部取完，则最后操作的人赢。 </p><p>  筱玛和马爷都聪明绝顶，他们都会按照最优策略进行游戏。 </p><p>  马爷作为筱玛的爷爷，决定让筱玛选择先手还是后手。 </p><p>  筱玛为了稳操胜券，想提前知道对于当前的游戏，是先手必胜还是后手必胜。 </p><p>  筱玛想考考你，让你帮他解决这个问题</p><p>   思路：每一个数都是一个向量，以二进制形式的向量，此时数的异或就是向量的加法(不带进位)，就是求所有向量不相关的集合，其实就是矩阵的秩。然后就要求所有的向量组矩阵的秩，如果秩为偶数，后手赢，否则先手赢。可以通过高斯消元或者线性基，这里是线性基的方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n,m,a[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ran</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">60</span>; ~i; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;&gt;i &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!a[i])&#123;</span><br><span class="line">                a[i]=x;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> x^=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;m);</span><br><span class="line">        ans+=ran(m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans&amp;<span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">"First"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"Second"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;del&gt;说好的人均3.5道题呢？骗我们打代码&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Codeforces Round#572(Div 2)</title>
    <link href="http://yoursite.com/2019/07/06/cf190705/"/>
    <id>http://yoursite.com/2019/07/06/cf190705/</id>
    <published>2019-07-06T09:39:24.253Z</published>
    <updated>2019-07-07T13:17:11.088Z</updated>
    
    <content type="html"><![CDATA[<p><del>这场比较简单</del>，深夜肝题，精神抖擞.jpg，不过涨分就很舒服</p><a id="more"></a><h2 id="A-Keanu-Reeves"><a href="#A-Keanu-Reeves" class="headerlink" title="A. Keanu Reeves"></a><a href="https://codeforces.com/contest/1189/problem/A" target="_blank" rel="noopener">A. Keanu Reeves</a></h2><p>题意: 是给定一个只含0和1的串，问能否能分成最少的子串，并且这些子串的0和1数量不相等</p><p>解析: 如果该串本身01数量不等，直接输出，否则就分成两部分就好，第一个字符单独一部分，剩下的为另一部分(我的代码是最后一个字符单独一部分)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">200</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">    <span class="keyword">int</span> cnt0=<span class="number">0</span>,cnt1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">'0'</span>) cnt0++;</span><br><span class="line">        <span class="keyword">else</span> cnt1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt0 != cnt1)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1\n%s\n"</span>,s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"2"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>,s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %c\n"</span>,s[n<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Number-Circle"><a href="#B-Number-Circle" class="headerlink" title="B. Number Circle"></a><a href="https://codeforces.com/contest/1189/problem/B" target="_blank" rel="noopener">B. Number Circle</a></h2><p>题意: 给定一个序列，问你能否组成一个首尾相接循环的序列，使得每个数都比相邻的两个数的和小</p><p>解析: 对数组a首先排序，直接从最后一个元素a[n]开始找，找从前面找a[i]，使得a[n-1]+a[i] &gt; a[n]，如果找到a[i]，那么序列就是a[n-1] a[n] a[i] a[1] … a[n-2] (假设i不是1或者n-2)，具体看代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a,a+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-2</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]+a[n<span class="number">-2</span>] &gt; a[n<span class="number">-1</span>])&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d %d"</span>,a[n<span class="number">-2</span>],a[n<span class="number">-1</span>],a[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n<span class="number">-2</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j!=i) <span class="built_in">printf</span>(<span class="string">" %d"</span>,a[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Candies"><a href="#C-Candies" class="headerlink" title="C. Candies!"></a><a href="https://codeforces.com/contest/1189/problem/C" target="_blank" rel="noopener">C. Candies!</a></h2><p> 题意: 有这么一个操作，对于a[i], a[i+1],…,a[j],其中，j-i+1是2的幂次方，然后对于每两个数，相加得到一个新数，然后个数就变成了原来的一半，比如说{1,2,3,4}，经过一次变换之后就变成了{3，7},一直操作直到个数为1; 然后对于每次操作，如果相加得到的新数大于10，我就能得到一颗糖，并且将新数对10取模; 然后我有k次询问，对于区间内的数，经过若干次操作之后，我能拿多少糖。</p><p> 解析: 题目给的限制，每个数小于10，我只要统计区间内的总数，然后除以10取整就是答案，证明略。<del>(盲猜结论直接莽一发)</del></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        dp[i]=dp[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m,l,r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,(dp[r]-dp[l<span class="number">-1</span>])/<span class="number">10</span>);;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D1-Add-on-a-Tree"><a href="#D1-Add-on-a-Tree" class="headerlink" title="D1. Add on a Tree"></a><a href="https://codeforces.com/contest/1189/problem/D1" target="_blank" rel="noopener">D1. Add on a Tree</a></h2><p>题意: 有一棵树，然后有一种操作，任意选择两个叶子节点，然后得到一条路径，我能在这条路径上加上某个实数(初始化每条边都是0)，这样每条边都有一个数，问对于任意一组边上的数，我能否通过有限次操作实现</p><p>解析: 透过题目看本质，其实就是一道水题，当一个节点只连接两条边，就是NO，否则就是YES</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,x,y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x,&amp;y);</span><br><span class="line">        vis[x]++;</span><br><span class="line">        vis[y]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i] == <span class="number">2</span>)&#123;</span><br><span class="line">            flag=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-Count-Pairs"><a href="#E-Count-Pairs" class="headerlink" title="E. Count Pairs"></a><a href="https://codeforces.com/contest/1189/problem/E" target="_blank" rel="noopener">E. Count Pairs</a></h2><p>题意: 有一个数组a，给定一个素数p和一个小于p的数k，问能找到多少组(i,j),使得 $(a_i+a_j)*(a_i^2+a_j^2) \equiv k\ mod \ p$</p><p>解析: 两边同时乘$a_i - a_j$，就变成了$(a_i^4-a_j^4)$ $ \equiv $ $(k * a_i-k * a_j)$ $\ mod \ p$ ,转换就是$({a_i^4}-k * {a_i})$ $ \equiv $ $(k * {a_j^4} - k * {a_j}) $ $\ mod \ p$</p><p>只要另$b_i = a_i^4 - k* a_i$ 就可以通过map统计个数了,注意取模</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a,b;</span><br><span class="line">ll n,p,k;</span><br><span class="line"><span class="built_in">map</span>&lt;ll,ll&gt;ma;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>,&amp;n,&amp;p,&amp;k);</span><br><span class="line">    ll cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a);</span><br><span class="line">        b=(a*a%p*a%p*a%p-a*k%p+p)%p;</span><br><span class="line">        <span class="comment">//printf("%lld %lld\n",b,(a*a*a*a-a*k+p)%p);</span></span><br><span class="line">        ma[b]++;</span><br><span class="line">        cnt+=(ma[b]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;del&gt;这场比较简单&lt;/del&gt;，深夜肝题，精神抖擞.jpg，不过涨分就很舒服&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
